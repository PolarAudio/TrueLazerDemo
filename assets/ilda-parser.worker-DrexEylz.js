(function(){"use strict";const y=[{r:255,g:0,b:0},{r:0,g:255,b:0},{r:0,g:0,b:255},{r:255,g:255,b:0},{r:0,g:255,b:255},{r:255,g:0,b:255},{r:255,g:128,b:0},{r:128,g:255,b:0},{r:0,g:255,b:128},{r:0,g:128,b:255},{r:128,g:0,b:255},{r:255,g:0,b:128},{r:255,g:255,b:255},{r:128,g:128,b:128},{r:255,g:128,b:128},{r:128,g:255,b:128},{r:128,g:128,b:255},{r:255,g:255,b:128},{r:128,g:255,b:255},{r:255,g:128,b:255}],S=new Map,P=s=>{if(!s||s.length===0)return{minX:0,maxX:0,minY:0,maxY:0};let e=s[0].x,l=s[0].x,g=s[0].y,a=s[0].y;for(let t=1;t<s.length;t++){const i=s[t];e=Math.min(e,i.x),l=Math.max(l,i.x),g=Math.min(g,i.y),a=Math.max(a,i.y)}return{minX:e,maxX:l,minY:g,maxY:a}};function D(s){console.log("[ilda-parser.worker.js] parseIldaFile - Starting parsing.");const e=new DataView(s),l=[];let g=null,a=0;for(;a+32<=s.byteLength;){const t=a,i=String.fromCharCode(e.getUint8(t),e.getUint8(t+1),e.getUint8(t+2),e.getUint8(t+3));if(i!=="ILDA"){console.warn(`[ilda-parser.worker.js] Parser: Invalid ILDA signature at offset ${t}, got: ${i}. Skipping 32 bytes.`),a+=32;continue}const r=e.getUint8(t+7);if(g===null&&(g=r),r>5){console.warn(`[ilda-parser.worker.js] Parser: Unknown format code: ${r} at offset ${t}. Skipping 32 bytes.`),a+=32;continue}let d=e.getUint16(t+24,!1);const n=e.getUint16(t+26,!1),p=e.getUint16(t+28,!1),C=e.getUint8(t+30);let c;switch(r){case 0:c=8;break;case 1:c=6;break;case 2:c=3;break;case 4:c=10;break;case 5:c=8;break;default:console.warn(`Parser: Unsupported format ${r}, skipping 32 bytes.`),a+=32;continue}let I=d*c,m=32+I;const $=s.byteLength-a;if(m<$){const f=$-m;f>0&&f<=32&&(console.warn(`Parser: Malformed frame, ${f} leftover bytes. Adjusting size.`),m+=f,I+=f,d=Math.floor(I/c))}if(t+m>s.byteLength){console.warn(`Parser: Incomplete frame data for ${d} points at offset ${t}. Expected ${m} bytes, but only ${s.byteLength-t} bytes remaining. Breaking.`);break}if(d===0){console.log("[ilda-parser.worker.js] Parser: Empty frame, skipping"),a+=m;continue}const b=[];let o=t+32;try{for(let f=0;f<d;f++){if(r===2){o+=c;continue}let U,x,M=0,u,k,h,w;r===0||r===4?(U=e.getInt16(o,!1)/32768,x=e.getInt16(o+2,!1)/32768,M=e.getInt16(o+4,!1)/32768,w=e.getUint8(o+6)):(U=e.getInt16(o,!1)/32768,x=e.getInt16(o+2,!1)/32768,w=e.getUint8(o+4));const L=(w&64)===64,j=(w&128)===128;if(r===0||r===1){const v=e.getUint8(o+(r===0?7:5)),F=y[v%y.length]||y[0];u=F.r,k=F.g,h=F.b}else(r===4||r===5)&&(h=e.getUint8(o+(r===4?7:5)),k=e.getUint8(o+(r===4?8:6)),u=e.getUint8(o+(r===4?9:7)));if(b.push({x:U,y:x,z:M,r:u===void 0?255:u,g:k===void 0?255:k,b:h===void 0?255:h,blanking:L,lastPoint:j}),o+=c,j)break}}catch(f){console.warn("Parser: Error reading points:",f);break}b.length>0&&l.push({frameNumber:n,totalFrames:p,projectorNumber:C,points:b,bounds:P(b)}),a+=m}return console.log(`[ilda-parser.worker.js] parseIldaFile - Finished parsing. Found ${l.length} frames.`),{frames:l,error:l.length===0?"No valid frames found":null,firstFormatCode:g}}self.onmessage=function(s){const{arrayBuffer:e,type:l,fileName:g,layerIndex:a,colIndex:t,workerId:i,frameIndex:r,isStillFrame:d}=s.data;if(l==="parse-ilda")try{console.log("[ilda-parser.worker.js] Calling parseIldaFile for:",g);const n=D(e);console.log("[ilda-parser.worker.js] parseIldaFile returned:",n);const p=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;S.set(p,n.frames),console.log("[ilda-parser.worker.js] Posting success message for parse-ilda."),self.postMessage({success:!0,workerId:p,totalFrames:n.frames.length,ildaFormat:n.firstFormatCode,fileName:g,layerIndex:a,colIndex:t,type:"parse-ilda"})}catch(n){console.error("[ilda-parser.worker.js] Error parsing file in onmessage handler:",n),self.postMessage({success:!1,error:n.message,type:"parse-ilda"})}else if(l==="get-frame"){const n=S.get(i);n&&n[r]?self.postMessage({success:!0,frame:n[r],workerId:i,frameIndex:r,type:"get-frame",isStillFrame:d}):self.postMessage({success:!1,error:"Frame not found",workerId:i,frameIndex:r,type:"get-frame",isStillFrame:d})}}})();
