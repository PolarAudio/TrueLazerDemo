(function(){"use strict";const k=[{r:255,g:0,b:0},{r:0,g:255,b:0},{r:0,g:0,b:255},{r:255,g:255,b:0},{r:0,g:255,b:255},{r:255,g:0,b:255},{r:255,g:128,b:0},{r:128,g:255,b:0},{r:0,g:255,b:128},{r:0,g:128,b:255},{r:128,g:0,b:255},{r:255,g:0,b:128},{r:255,g:255,b:255},{r:128,g:128,b:128},{r:255,g:128,b:128},{r:128,g:255,b:128},{r:128,g:128,b:255},{r:255,g:255,b:128},{r:128,g:255,b:255},{r:255,g:128,b:255}],M=new Map;function x(g,s,u,y,p=k){const d=[],t=new DataView(g);let r=0;try{for(let i=0;i<y;i++){if(s===2){r+=u;continue}let w,I,e=0,n,f,m,l;s===0||s===4?(w=t.getInt16(r,!1)/32768,I=t.getInt16(r+2,!1)/32768,e=t.getInt16(r+4,!1)/32768,l=t.getUint8(r+6)):(w=t.getInt16(r,!1)/32768,I=t.getInt16(r+2,!1)/32768,l=t.getUint8(r+4));const o=(l&64)!==0,a=(l&128)!==0;if(o)n=0,f=0,m=0;else if(s===0||s===1){const b=t.getUint8(r+(s===0?7:5)),c=p||k,h=c[b%c.length]||k[0];n=h.r,f=h.g,m=h.b}else(s===4||s===5)&&(m=t.getUint8(r+(s===4?7:5)),f=t.getUint8(r+(s===4?8:6)),n=t.getUint8(r+(s===4?9:7)));if(d.push({x:w,y:I,z:e,r:n===void 0?255:n,g:f===void 0?255:f,b:m===void 0?255:m,blanking:o,lastPoint:a}),r+=u,a)break}}catch(i){console.warn("Parser: Error reading points:",i)}return d}function D(g){console.log("[ilda-parser.worker.js] parseIldaFile - Starting parsing.");const s=new DataView(g),u=[];let y=null,p=0,d=null;for(;p+32<=g.byteLength;){const t=p,r=String.fromCharCode(s.getUint8(t),s.getUint8(t+1),s.getUint8(t+2),s.getUint8(t+3));if(r!=="ILDA"){console.warn(`[ilda-parser.worker.js] Parser: Invalid ILDA signature at offset ${t}, got: ${r}. Skipping 32 bytes.`),p+=32;continue}const i=s.getUint8(t+7);if(y===null&&(y=i),i>5){console.warn(`[ilda-parser.worker.js] Parser: Unknown format code: ${i} at offset ${t}. Skipping 32 bytes.`),p+=32;continue}const w=String.fromCharCode(...new Uint8Array(g,t+8,8)).trim(),I=String.fromCharCode(...new Uint8Array(g,t+16,8)).trim();let e=s.getUint16(t+24,!1);const n=s.getUint16(t+26,!1),f=s.getUint16(t+28,!1),m=s.getUint8(t+30);let l;switch(i){case 0:l=8;break;case 1:l=6;break;case 2:l=4;break;case 4:l=10;break;case 5:l=8;break;default:console.warn(`Parser: Unsupported format ${i}, skipping 32 bytes.`),p+=32;continue}if(i===2){d=[];const c=p+32;for(let h=0;h<e;h++){const P=s.getUint8(c+h*4),U=s.getUint8(c+h*4+1),S=s.getUint8(c+h*4+2);d.push({r:P,g:U,b:S})}}let o=e*l,a=32+o;const b=g.byteLength-p;if(a<b){const c=b-a;c>0&&c<=32&&(console.warn(`Parser: Malformed frame, ${c} leftover bytes. Adjusting size.`),a+=c,o+=c,e=Math.floor(o/l))}if(t+a>g.byteLength){console.warn(`Parser: Incomplete frame data for ${e} points at offset ${t}. Expected ${a} bytes, but only ${g.byteLength-t} bytes remaining. Breaking.`);break}if(e===0){console.log("[ilda-parser.worker.js] Parser: Empty frame, skipping"),p+=a;continue}u.push({frameName:w,companyName:I,frameNumber:n,totalFrames:f,scannerHead:m,formatCode:i,recordSize:l,pointCount:e,pointDataOffset:t+32,pointDataSize:o,frameEndOffset:t+a,bounds:{minX:0,maxX:0,minY:0,maxY:0}}),p+=a}return console.log(`[ilda-parser.worker.js] parseIldaFile - Finished parsing. Found ${u.length} frames.`),{frames:u,error:u.length===0?"No valid frames found":null,firstFormatCode:y,ildaFileBuffer:g,colorPalette:d}}const F=new Map;self.onmessage=function(g){const{arrayBuffer:s,type:u,fileName:y,filePath:p,layerIndex:d,colIndex:t,workerId:r,frameIndex:i,isStillFrame:w,requestId:I}=g.data;if(u==="parse-ilda"){if(!s){self.postMessage({success:!1,error:"ArrayBuffer missing for parse-ilda command",type:"parse-ilda"});return}try{console.log("[ilda-parser.worker.js] Calling parseIldaFile for:",y);const e=D(s),n=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;M.set(n,{ildaFileBuffer:e.ildaFileBuffer,framesMetadata:e.frames,colorPalette:e.colorPalette}),console.log("[ilda-parser.worker.js] Posting success message for parse-ilda."),self.postMessage({success:!0,workerId:n,totalFrames:e.frames.length,ildaFormat:e.firstFormatCode,fileName:y,filePath:p,layerIndex:d,colIndex:t,type:"parse-ilda"}),self.postMessage({type:"parsing-status",status:!1,layerIndex:d,colIndex:t})}catch(e){console.error("[ilda-parser.worker.js] Error parsing file in onmessage handler:",e),self.postMessage({success:!1,error:e.message,type:"parse-ilda"}),self.postMessage({type:"parsing-status",status:!1,layerIndex:d,colIndex:t})}}else if(u==="load-and-parse-ilda"){const e=Math.random().toString(36).substring(2,15);F.set(e,{fileName:y,filePath:p,layerIndex:d,colIndex:t}),self.postMessage({type:"parsing-status",status:!0,layerIndex:d,colIndex:t}),self.postMessage({type:"request-file-content",filePath:p,requestId:e})}else if(u==="file-content-response"){const e=F.get(I);if(!e){console.error(`Worker: No context found for requestId: ${I}`);return}if(F.delete(I),g.data.error){console.error(`Worker: Error receiving file content: ${g.data.error}`),self.postMessage({success:!1,error:g.data.error,type:"parse-ilda",...e}),self.postMessage({type:"parsing-status",status:!1,layerIndex:e.layerIndex,colIndex:e.colIndex});return}try{console.log(`[ilda-parser.worker.js] Calling parseIldaFile for: ${e.fileName} (from file-content-response)`);const n=D(s),f=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;M.set(f,{ildaFileBuffer:n.ildaFileBuffer,framesMetadata:n.frames,colorPalette:n.colorPalette}),self.postMessage({success:!0,workerId:f,totalFrames:n.frames.length,ildaFormat:n.firstFormatCode,type:"parse-ilda",...e}),self.postMessage({type:"parsing-status",status:!1,layerIndex:e.layerIndex,colIndex:e.colIndex})}catch(n){console.error("[ilda-parser.worker.js] Error parsing file from content response:",n),self.postMessage({success:!1,error:n.message,type:"parse-ilda",...e}),self.postMessage({type:"parsing-status",status:!1,layerIndex:e.layerIndex,colIndex:e.colIndex})}}else if(u==="get-frame"){const e=M.get(r);if(!e){self.postMessage({success:!1,error:"ILDA data not found",type:"get-frame",workerId:r});return}const{ildaFileBuffer:n,framesMetadata:f,colorPalette:m}=e,l=Math.floor(i);if(!Number.isFinite(l)||l>=f.length||l<0){self.postMessage({success:!1,error:`Frame index ${i} out of bounds or invalid`,type:"get-frame",workerId:r});return}const o=f[l];if(!o){self.postMessage({success:!1,error:`Frame metadata not found for index ${l}`,type:"get-frame",workerId:r});return}let a=o.cachedPoints;if(!a){const c=n.slice(o.pointDataOffset,o.pointDataOffset+o.pointDataSize);a=x(c,o.formatCode,o.recordSize,o.pointCount,m),o.cachedPoints=a}const b={points:a};self.postMessage({success:!0,frame:b,type:"get-frame",workerId:r,frameIndex:i,isStillFrame:w,layerIndex:d,colIndex:t})}else if(u==="get-all-frames"){const e=M.get(r);if(!e){self.postMessage({success:!1,error:"ILDA data not found",type:"get-all-frames",workerId:r});return}const{ildaFileBuffer:n,framesMetadata:f,colorPalette:m}=e,l=[];try{for(let o=0;o<f.length;o++){const a=f[o];let b=a.cachedPoints;if(!b){const c=n.slice(a.pointDataOffset,a.pointDataOffset+a.pointDataSize);b=x(c,a.formatCode,a.recordSize,a.pointCount,m),a.cachedPoints=b}l.push({...a,points:b})}self.postMessage({success:!0,frames:l,type:"get-all-frames",workerId:r,layerIndex:d,colIndex:t})}catch(o){self.postMessage({success:!1,error:o.message,type:"get-all-frames",workerId:r})}}}})();
