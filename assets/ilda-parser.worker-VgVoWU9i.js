(function(){"use strict";const k=[{r:255,g:0,b:0},{r:0,g:255,b:0},{r:0,g:0,b:255},{r:255,g:255,b:0},{r:0,g:255,b:255},{r:255,g:0,b:255},{r:255,g:128,b:0},{r:128,g:255,b:0},{r:0,g:255,b:128},{r:0,g:128,b:255},{r:128,g:0,b:255},{r:255,g:0,b:128},{r:255,g:255,b:255},{r:128,g:128,b:128},{r:255,g:128,b:128},{r:128,g:255,b:128},{r:128,g:128,b:255},{r:255,g:255,b:128},{r:128,g:255,b:255},{r:255,g:128,b:255}],M=new Map;function U(f,s,u,m,c=k){const d=[],e=new DataView(f);let r=0;try{for(let i=0;i<m;i++){if(s===2){r+=u;continue}let w,b,t=0,a,p,y,n;s===0||s===4?(w=e.getInt16(r,!1)/32768,b=e.getInt16(r+2,!1)/32768,t=e.getInt16(r+4,!1)/32768,n=e.getUint8(r+6)):(w=e.getInt16(r,!1)/32768,b=e.getInt16(r+2,!1)/32768,n=e.getUint8(r+4));const o=(n&64)!==0,l=(n&128)!==0;if(o)a=0,p=0,y=0;else if(s===0||s===1){const h=e.getUint8(r+(s===0?7:5)),g=c||k,I=g[h%g.length]||k[0];a=I.r,p=I.g,y=I.b}else(s===4||s===5)&&(y=e.getUint8(r+(s===4?7:5)),p=e.getUint8(r+(s===4?8:6)),a=e.getUint8(r+(s===4?9:7)));if(d.push({x:w,y:b,z:t,r:a===void 0?255:a,g:p===void 0?255:p,b:y===void 0?255:y,blanking:o,lastPoint:l}),r+=u,l)break}}catch(i){console.warn("Parser: Error reading points:",i)}return d}function F(f){console.log("[ilda-parser.worker.js] parseIldaFile - Starting parsing.");const s=new DataView(f),u=[];let m=null,c=0,d=null;for(;c+32<=f.byteLength;){const e=c,r=String.fromCharCode(s.getUint8(e),s.getUint8(e+1),s.getUint8(e+2),s.getUint8(e+3));if(r!=="ILDA"){console.warn(`[ilda-parser.worker.js] Parser: Invalid ILDA signature at offset ${e}, got: ${r}. Skipping 32 bytes.`),c+=32;continue}const i=s.getUint8(e+7);if(m===null&&(m=i),i>5){console.warn(`[ilda-parser.worker.js] Parser: Unknown format code: ${i} at offset ${e}. Skipping 32 bytes.`),c+=32;continue}const w=String.fromCharCode(...new Uint8Array(f,e+8,8)).trim(),b=String.fromCharCode(...new Uint8Array(f,e+16,8)).trim();let t=s.getUint16(e+24,!1);const a=s.getUint16(e+26,!1),p=s.getUint16(e+28,!1),y=s.getUint8(e+30);let n;switch(i){case 0:n=8;break;case 1:n=6;break;case 2:n=4;break;case 4:n=10;break;case 5:n=8;break;default:console.warn(`Parser: Unsupported format ${i}, skipping 32 bytes.`),c+=32;continue}if(i===2){d=[];const g=c+32;for(let I=0;I<t;I++){const P=s.getUint8(g+I*4),$=s.getUint8(g+I*4+1),D=s.getUint8(g+I*4+2);d.push({r:P,g:$,b:D})}}let o=t*n,l=32+o;const h=f.byteLength-c;if(l<h){const g=h-l;g>0&&g<=32&&(console.warn(`Parser: Malformed frame, ${g} leftover bytes. Adjusting size.`),l+=g,o+=g,t=Math.floor(o/n))}if(e+l>f.byteLength){console.warn(`Parser: Incomplete frame data for ${t} points at offset ${e}. Expected ${l} bytes, but only ${f.byteLength-e} bytes remaining. Breaking.`);break}if(t===0){console.log("[ilda-parser.worker.js] Parser: Empty frame, skipping"),c+=l;continue}u.push({frameName:w,companyName:b,frameNumber:a,totalFrames:p,scannerHead:y,formatCode:i,recordSize:n,pointCount:t,pointDataOffset:e+32,pointDataSize:o,frameEndOffset:e+l,bounds:{minX:0,maxX:0,minY:0,maxY:0}}),c+=l}return console.log(`[ilda-parser.worker.js] parseIldaFile - Finished parsing. Found ${u.length} frames.`),{frames:u,error:u.length===0?"No valid frames found":null,firstFormatCode:m,ildaFileBuffer:f,colorPalette:d}}const x=new Map;self.onmessage=function(f){const{arrayBuffer:s,type:u,fileName:m,filePath:c,layerIndex:d,colIndex:e,workerId:r,frameIndex:i,isStillFrame:w,requestId:b}=f.data;if(u==="parse-ilda"){if(!s){self.postMessage({success:!1,error:"ArrayBuffer missing for parse-ilda command",type:"parse-ilda"});return}try{console.log("[ilda-parser.worker.js] Calling parseIldaFile for:",m);const t=F(s),a=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;M.set(a,{ildaFileBuffer:t.ildaFileBuffer,framesMetadata:t.frames,colorPalette:t.colorPalette}),console.log("[ilda-parser.worker.js] Posting success message for parse-ilda."),self.postMessage({success:!0,workerId:a,totalFrames:t.frames.length,ildaFormat:t.firstFormatCode,fileName:m,filePath:c,layerIndex:d,colIndex:e,type:"parse-ilda"}),self.postMessage({type:"parsing-status",status:!1,layerIndex:d,colIndex:e})}catch(t){console.error("[ilda-parser.worker.js] Error parsing file in onmessage handler:",t),self.postMessage({success:!1,error:t.message,type:"parse-ilda"}),self.postMessage({type:"parsing-status",status:!1,layerIndex:d,colIndex:e})}}else if(u==="load-and-parse-ilda"){const t=Math.random().toString(36).substring(2,15);x.set(t,{fileName:m,filePath:c,layerIndex:d,colIndex:e}),self.postMessage({type:"parsing-status",status:!0,layerIndex:d,colIndex:e}),self.postMessage({type:"request-file-content",filePath:c,requestId:t})}else if(u==="file-content-response"){const t=x.get(b);if(!t){console.error(`Worker: No context found for requestId: ${b}`);return}if(x.delete(b),f.data.error){console.error(`Worker: Error receiving file content: ${f.data.error}`),self.postMessage({success:!1,error:f.data.error,type:"parse-ilda",...t}),self.postMessage({type:"parsing-status",status:!1,layerIndex:t.layerIndex,colIndex:t.colIndex});return}try{console.log(`[ilda-parser.worker.js] Calling parseIldaFile for: ${t.fileName} (from file-content-response)`);const a=F(s),p=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;M.set(p,{ildaFileBuffer:a.ildaFileBuffer,framesMetadata:a.frames,colorPalette:a.colorPalette}),self.postMessage({success:!0,workerId:p,totalFrames:a.frames.length,ildaFormat:a.firstFormatCode,type:"parse-ilda",...t}),self.postMessage({type:"parsing-status",status:!1,layerIndex:t.layerIndex,colIndex:t.colIndex})}catch(a){console.error("[ilda-parser.worker.js] Error parsing file from content response:",a),self.postMessage({success:!1,error:a.message,type:"parse-ilda",...t}),self.postMessage({type:"parsing-status",status:!1,layerIndex:t.layerIndex,colIndex:t.colIndex})}}else if(u==="get-frame"){const t=M.get(r);if(!t){self.postMessage({success:!1,error:"ILDA data not found",type:"get-frame",workerId:r});return}const{ildaFileBuffer:a,framesMetadata:p,colorPalette:y}=t,n=Math.floor(i);if(!Number.isFinite(n)||n>=p.length||n<0){self.postMessage({success:!1,error:`Frame index ${i} out of bounds or invalid`,type:"get-frame",workerId:r});return}const o=p[n];if(!o){self.postMessage({success:!1,error:`Frame metadata not found for index ${n}`,type:"get-frame",workerId:r});return}let l=o.cachedPoints;if(!l){const g=a.slice(o.pointDataOffset,o.pointDataOffset+o.pointDataSize);l=U(g,o.formatCode,o.recordSize,o.pointCount,y),o.cachedPoints=l}const h={points:l};self.postMessage({success:!0,frame:h,type:"get-frame",workerId:r,frameIndex:i,isStillFrame:w,layerIndex:d,colIndex:e})}}})();
