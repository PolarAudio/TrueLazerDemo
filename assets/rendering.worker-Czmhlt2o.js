(function(){"use strict";class E{constructor(e,i){if(this.canvas=e,this.type=i,this.gl=e.getContext("webgl")||e.getContext("experimental-webgl"),this.animationFrameId=null,this.frameIndexes=Array(5).fill(0),this.showBeamEffect=!1,this.beamAlpha=.5,this.fadeAlpha=.13,this.beamRenderMode="lines",this.positionBuffer=null,this.colorBuffer=null,this.alphaBuffer=null,this.currentPointIndex=0,this.lastPointDrawTime=0,!this.gl){console.error("WebGL not supported");return}this.setup()}setup(){const e=this.gl,i=`
      attribute vec2 aPosition;
      attribute vec3 aColor;
      attribute float aAlpha;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        gl_PointSize = 2.0;
        vColor = aColor;
        vAlpha = aAlpha;
      }
    `,a=`
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(vColor, vAlpha);
      }
    `,r=this.createShader(e.VERTEX_SHADER,i),t=this.createShader(e.FRAGMENT_SHADER,a),o=this.createProgram(r,t);this.program=o,this.positionAttributeLocation=e.getAttribLocation(o,"aPosition"),this.colorAttributeLocation=e.getAttribLocation(o,"aColor"),this.alphaAttributeLocation=e.getAttribLocation(o,"aAlpha"),this.quadPositionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer);const f=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(f),e.STATIC_DRAW),this.quadColorUniformLocation=e.getUniformLocation(o,"uColor"),this.quadAlphaUniformLocation=e.getUniformLocation(o,"uAlpha");const l=`
      attribute vec2 aPosition;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `,d=`
      precision mediump float;
      uniform vec4 uColor;
      void main() {
        gl_FragColor = uColor;
      }
    `,R=this.createShader(e.VERTEX_SHADER,l),m=this.createShader(e.FRAGMENT_SHADER,d);this.fadeProgram=this.createProgram(R,m),this.fadePositionAttributeLocation=e.getAttribLocation(this.fadeProgram,"aPosition"),this.fadeColorUniformLocation=e.getUniformLocation(this.fadeProgram,"uColor"),e.useProgram(o);const g=131072;this.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.bufferData(e.ARRAY_BUFFER,g*2*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.colorBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.colorBuffer),e.bufferData(e.ARRAY_BUFFER,g*3*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.alphaBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.alphaBuffer),e.bufferData(e.ARRAY_BUFFER,g*1*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA)}reset(){this.currentPointIndex=0,this.frameIndexes.fill(0),this.clearCanvas()}createShader(e,i){const a=this.gl,r=a.createShader(e);if(a.shaderSource(r,i),a.compileShader(r),a.getShaderParameter(r,a.COMPILE_STATUS))return r;console.error(a.getShaderInfoLog(r)),a.deleteShader(r)}createProgram(e,i){const a=this.gl,r=a.createProgram();if(a.attachShader(r,e),a.attachShader(r,i),a.linkProgram(r),a.getProgramParameter(r,a.LINK_STATUS))return r;console.error(a.getProgramInfoLog(r)),a.deleteProgram(r)}render(e){e.showBeamEffect!==void 0&&this.setBeamEffect(e.showBeamEffect),e.beamAlpha!==void 0&&this.setBeamAlpha(e.beamAlpha),e.fadeAlpha!==void 0&&this.setFadeAlpha(e.fadeAlpha),e.beamRenderMode!==void 0&&(this.beamRenderMode=e.beamRenderMode),this.type==="world"?this.renderWorld(e.worldData,e.previewScanRate,e.layerIntensities,e.masterIntensity):this.renderSingle(e.ildaFrames,e.previewScanRate,e.intensity)}renderSingle(e,i,a){const r=this.gl;if(r.viewport(0,0,r.canvas.width,r.canvas.height),r.clear(r.COLOR_BUFFER_BIT),!e||e.length===0)return;const t=e[this.frameIndexes[0]%e.length];this.draw(t.points,this.showBeamEffect,this.beamAlpha,i,this.beamRenderMode,a),this.frameIndexes[0]++,this.frameIndexes[0]>=e.length&&(this.frameIndexes[0]=0)}renderWorld(e,i,a,r){const t=this.gl;t.viewport(0,0,t.canvas.width,t.canvas.height),t.clear(t.COLOR_BUFFER_BIT),e.forEach((o,f)=>{if(o&&o.frames&&o.frames.length>0){const l=o.frames[this.frameIndexes[f]%o.frames.length];if(l){const R=(a[o.layerIndex]!==void 0?a[o.layerIndex]:1)*r;this.draw(l.points,this.showBeamEffect,this.beamAlpha,i,this.beamRenderMode,R)}}}),e.forEach((o,f)=>{o&&o.frames&&(this.frameIndexes[f]++,this.frameIndexes[f]>=o.frames.length&&(this.frameIndexes[f]=0))})}setBeamEffect(e){this.showBeamEffect=e}setBeamAlpha(e){this.beamAlpha=e}setFadeAlpha(e){this.fadeAlpha=e}draw(e,i,a,r,t,o=1){if(this.gl,!e||e.length===0)return;const f=Math.max(1,Math.floor(e.length/r)),l=this.currentPointIndex,d=Math.min(l+f,e.length),R=()=>{let s=[],c=[];for(let h=l;h<d;h++){const n=e[h];if(n.blanking){s.length>0&&(this._drawSegment(new Float32Array(s),new Float32Array(c),1,s.length/2),s=[],c=[]);continue}s.push(n.x,n.y),c.push(n.r/255*o,n.g/255*o,n.b/255*o)}s.length>0&&this._drawSegment(new Float32Array(s),new Float32Array(c),1,s.length/2)},m=()=>{const s=[],c=[];for(let h=l;h<d;h++){const n=e[h];if(!n.blanking){s.push(0,0,n.x,n.y);const A=[n.r/255*o,n.g/255*o,n.b/255*o];c.push(...A,...A)}}s.length>0&&this._drawLines(new Float32Array(s),new Float32Array(c),a,s.length/2)},g=()=>{const s=[],c=[];for(let h=l+1;h<d;h++){const n=e[h-1],A=e[h];if(!n.blanking&&!A.blanking){s.push(0,0,n.x,n.y,A.x,A.y);const F=[n.r/255*o,n.g/255*o,n.b/255*o],B=[A.r/255*o,A.g/255*o,A.b/255*o],_=[(F[0]+B[0])/2,(F[1]+B[1])/2,(F[2]+B[2])/2];c.push(..._,...F,...B)}}s.length>0&&this._drawTriangles(new Float32Array(s),new Float32Array(c),a,s.length/2)};R(),i&&(t==="points"?m():t==="lines"?g():t==="both"&&(g(),m())),this.currentPointIndex=(this.currentPointIndex+f)%e.length}_drawSegment(e,i,a,r){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,i),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const o=new Float32Array(Array(r).fill(a));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,o),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINE_STRIP,0,r)}_drawLines(e,i,a,r){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,i),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const o=new Float32Array(Array(r).fill(a));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,o),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINES,0,r)}_drawTriangles(e,i,a,r){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,i),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const o=new Float32Array(Array(r).fill(a));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,o),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLES,0,r)}clearCanvas(){const e=this.gl;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT)}destroy(){cancelAnimationFrame(this.animationFrameId)}}const u=new Map;function p(b,e=0){const i=u.get(b);if(!i)return;const a=performance.now();i.renderer.render(i.data),self.postMessage({action:"frame-data-ready",payload:i.data}),e=a,i.animationFrameId=requestAnimationFrame(()=>p(b,e))}self.onmessage=b=>{const{action:e,payload:i}=b.data;if(e==="register"){const{id:a,canvas:r,type:t,data:o}=i,f=new E(r,t),l=requestAnimationFrame(()=>p(a));u.set(a,{renderer:f,type:t,data:o,animationFrameId:l})}else if(e==="deregister"){const{id:a}=i,r=u.get(a);r&&(cancelAnimationFrame(r.animationFrameId),u.delete(a))}else if(e==="update"){const{id:a,data:r}=i,t=u.get(a);t&&(t.renderer.reset(),t.data=r)}else if(e==="clear"){const{id:a}=i,r=u.get(a);r&&r.renderer.clearCanvas()}}})();
