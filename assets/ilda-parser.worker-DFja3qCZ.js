(function(){"use strict";const I=[{r:255,g:0,b:0},{r:0,g:255,b:0},{r:0,g:0,b:255},{r:255,g:255,b:0},{r:0,g:255,b:255},{r:255,g:0,b:255},{r:255,g:128,b:0},{r:128,g:255,b:0},{r:0,g:255,b:128},{r:0,g:128,b:255},{r:128,g:0,b:255},{r:255,g:0,b:128},{r:255,g:255,b:255},{r:128,g:128,b:128},{r:255,g:128,b:128},{r:128,g:255,b:128},{r:128,g:128,b:255},{r:255,g:255,b:128},{r:128,g:255,b:255},{r:255,g:128,b:255}],y=new Map;function F(g,r,c,p){const i=[],e=new DataView(g);let a=0;try{for(let o=0;o<p;o++){if(r===2){a+=c;continue}let l,m,u=0,s,t,f,n;r===0||r===4?(l=e.getInt16(a,!1)/32768,m=e.getInt16(a+2,!1)/32768,u=e.getInt16(a+4,!1)/32768,n=e.getUint8(a+6)):(l=e.getInt16(a,!1)/32768,m=e.getInt16(a+2,!1)/32768,n=e.getUint8(a+4));const b=(n&64)===64,d=(n&128)===128;if(r===0||r===1){const k=e.getUint8(a+(r===0?7:5)),M=I[k%I.length]||I[0];s=M.r,t=M.g,f=M.b}else(r===4||r===5)&&(f=e.getUint8(a+(r===4?7:5)),t=e.getUint8(a+(r===4?8:6)),s=e.getUint8(a+(r===4?9:7)));if(i.push({x:l,y:m,z:u,r:s===void 0?255:s,g:t===void 0?255:t,b:f===void 0?255:f,blanking:b,lastPoint:d}),a+=c,d)break}}catch(o){console.warn("Parser: Error reading points:",o)}return i}function h(g){console.log("[ilda-parser.worker.js] parseIldaFile - Starting parsing.");const r=new DataView(g),c=[];let p=null,i=0;for(;i+32<=g.byteLength;){const e=i,a=String.fromCharCode(r.getUint8(e),r.getUint8(e+1),r.getUint8(e+2),r.getUint8(e+3));if(a!=="ILDA"){console.warn(`[ilda-parser.worker.js] Parser: Invalid ILDA signature at offset ${e}, got: ${a}. Skipping 32 bytes.`),i+=32;continue}const o=r.getUint8(e+7);if(p===null&&(p=o),o>5){console.warn(`[ilda-parser.worker.js] Parser: Unknown format code: ${o} at offset ${e}. Skipping 32 bytes.`),i+=32;continue}let l=r.getUint16(e+24,!1);const m=r.getUint16(e+26,!1),u=r.getUint16(e+28,!1),s=r.getUint8(e+30);let t;switch(o){case 0:t=8;break;case 1:t=6;break;case 2:t=3;break;case 4:t=10;break;case 5:t=8;break;default:console.warn(`Parser: Unsupported format ${o}, skipping 32 bytes.`),i+=32;continue}let f=l*t,n=32+f;const b=g.byteLength-i;if(n<b){const d=b-n;d>0&&d<=32&&(console.warn(`Parser: Malformed frame, ${d} leftover bytes. Adjusting size.`),n+=d,f+=d,l=Math.floor(f/t))}if(e+n>g.byteLength){console.warn(`Parser: Incomplete frame data for ${l} points at offset ${e}. Expected ${n} bytes, but only ${g.byteLength-e} bytes remaining. Breaking.`);break}if(l===0){console.log("[ilda-parser.worker.js] Parser: Empty frame, skipping"),i+=n;continue}c.push({frameNumber:m,totalFrames:u,projectorNumber:s,formatCode:o,recordSize:t,pointCount:l,pointDataOffset:e+32,pointDataSize:f,frameEndOffset:e+n,bounds:{minX:0,maxX:0,minY:0,maxY:0}}),i+=n}return console.log(`[ilda-parser.worker.js] parseIldaFile - Finished parsing. Found ${c.length} frames.`),{frames:c,error:c.length===0?"No valid frames found":null,firstFormatCode:p,ildaFileBuffer:g}}const w=new Map;self.onmessage=function(g){const{arrayBuffer:r,type:c,fileName:p,filePath:i,layerIndex:e,colIndex:a,workerId:o,frameIndex:l,isStillFrame:m,requestId:u}=g.data;if(c==="parse-ilda"){if(!r){self.postMessage({success:!1,error:"ArrayBuffer missing for parse-ilda command",type:"parse-ilda"});return}try{console.log("[ilda-parser.worker.js] Calling parseIldaFile for:",p);const s=h(r);console.log("[ilda-parser.worker.js] parseIldaFile returned:",s);const t=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;y.set(t,{ildaFileBuffer:s.ildaFileBuffer,framesMetadata:s.frames}),console.log("[ilda-parser.worker.js] Posting success message for parse-ilda."),self.postMessage({success:!0,workerId:t,totalFrames:s.frames.length,ildaFormat:s.firstFormatCode,fileName:p,filePath:i,layerIndex:e,colIndex:a,type:"parse-ilda"}),self.postMessage({type:"parsing-status",status:!1,layerIndex:e,colIndex:a})}catch(s){console.error("[ilda-parser.worker.js] Error parsing file in onmessage handler:",s),self.postMessage({success:!1,error:s.message,type:"parse-ilda"}),self.postMessage({type:"parsing-status",status:!1,layerIndex:e,colIndex:a})}}else if(c==="load-and-parse-ilda"){const s=Math.random().toString(36).substring(2,15);w.set(s,{fileName:p,filePath:i,layerIndex:e,colIndex:a}),self.postMessage({type:"parsing-status",status:!0,layerIndex:e,colIndex:a}),self.postMessage({type:"request-file-content",filePath:i,requestId:s})}else if(c==="file-content-response"){const s=w.get(u);if(!s){console.error(`Worker: No context found for requestId: ${u}`);return}if(w.delete(u),g.data.error){console.error(`Worker: Error receiving file content: ${g.data.error}`),self.postMessage({success:!1,error:g.data.error,type:"parse-ilda",...s}),self.postMessage({type:"parsing-status",status:!1,layerIndex:s.layerIndex,colIndex:s.colIndex});return}try{console.log(`[ilda-parser.worker.js] Calling parseIldaFile for: ${s.fileName} (from file-content-response)`);const t=h(r),f=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;y.set(f,{ildaFileBuffer:t.ildaFileBuffer,framesMetadata:t.frames}),self.postMessage({success:!0,workerId:f,totalFrames:t.frames.length,ildaFormat:t.firstFormatCode,type:"parse-ilda",...s}),self.postMessage({type:"parsing-status",status:!1,layerIndex:s.layerIndex,colIndex:s.colIndex})}catch(t){console.error("[ilda-parser.worker.js] Error parsing file from content response:",t),self.postMessage({success:!1,error:t.message,type:"parse-ilda",...s}),self.postMessage({type:"parsing-status",status:!1,layerIndex:s.layerIndex,colIndex:s.colIndex})}}else if(c==="get-frame"){const s=y.get(o);if(!s){self.postMessage({success:!1,error:"ILDA data not found",type:"get-frame",workerId:o});return}const{ildaFileBuffer:t,framesMetadata:f}=s;if(l>=f.length||l<0){self.postMessage({success:!1,error:`Frame index ${l} out of bounds`,type:"get-frame",workerId:o});return}const n=f[l],b=t.slice(n.pointDataOffset,n.pointDataOffset+n.pointDataSize),k={points:F(b,n.formatCode,n.recordSize,n.pointCount)};self.postMessage({success:!0,frame:k,type:"get-frame",workerId:o,frameIndex:l,isStillFrame:m,layerIndex:e,colIndex:a})}}})();
