(function(){"use strict";const I=[{id:"rotate",name:"Rotate",type:"transform",description:"Rotates the shape around its center.",defaultParams:{angle:0,speed:0,direction:"CW"},paramControls:[{id:"angle",label:"Angle",type:"range",min:0,max:360,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["CW","CCW"]}]},{id:"scale",name:"Scale",type:"transform",description:"Scales the shape.",defaultParams:{scaleX:1,scaleY:1},paramControls:[{id:"scaleX",label:"Scale X",type:"range",min:.01,max:5,step:.01},{id:"scaleY",label:"Scale Y",type:"range",min:.01,max:5,step:.01}]},{id:"translate",name:"Translate",type:"transform",description:"Moves the shape.",defaultParams:{translateX:0,translateY:0},paramControls:[{id:"translateX",label:"Translate X",type:"range",min:-1,max:1,step:.01},{id:"translateY",label:"Translate Y",type:"range",min:-1,max:1,step:.01}]},{id:"color",name:"Color",type:"color",description:"Changes the color of the shape with solid or rainbow modes.",defaultParams:{mode:"solid",r:255,g:255,b:255,cycleSpeed:0,rainbowSpread:1,rainbowOffset:0,rainbowPalette:"rainbow"},paramControls:[{id:"mode",label:"Mode",type:"select",options:["solid","rainbow"]},{id:"r",label:"Red",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"g",label:"Green",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"b",label:"Blue",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"cycleSpeed",label:"Cycle Speed",type:"range",min:0,max:10,step:.1},{id:"rainbowSpread",label:"Rainbow Spread",type:"range",min:.1,max:10,step:.1,showIf:{mode:"rainbow"}},{id:"rainbowOffset",label:"Rainbow Offset",type:"range",min:0,max:360,step:1,showIf:{mode:"rainbow"}},{id:"rainbowPalette",label:"Palette",type:"select",options:["rainbow","fire","ice","cyber"],showIf:{mode:"rainbow"}}]},{id:"wave",name:"Wave",type:"animation",description:"Applies a wave distortion to the shape.",defaultParams:{amplitude:.1,frequency:10,speed:1,direction:"x"},paramControls:[{id:"amplitude",label:"Amplitude",type:"range",min:.01,max:1,step:.01},{id:"frequency",label:"Frequency",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["x","y"]}]},{id:"warp",name:"Warp",type:"animation",description:"Symmetrical chaotic wave distortion.",defaultParams:{amount:.1,chaos:.5,speed:1},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"chaos",label:"Chaos",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1}]},{id:"distortion",name:"Distortion",type:"transform",description:"Distorts the point data.",defaultParams:{amount:.1,scale:10,speed:.5},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"scale",label:"Scale",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:5,step:.1}]},{id:"move",name:"Move (Bounce)",type:"transform",description:"Moves points and bounces them off the borders.",defaultParams:{speedX:.1,speedY:.1},paramControls:[{id:"speedX",label:"Speed X",type:"range",min:0,max:2,step:.01},{id:"speedY",label:"Speed Y",type:"range",min:0,max:2,step:.01}]},{id:"delay",name:"Delay",type:"effect",description:"Frame or Channel based delay effect.",defaultParams:{mode:"frame",playstyle:"repeat",useCustomOrder:!1,delayDirection:"left_to_right",delayAmount:5,decay:.8,customOrder:[],enabled:!0},paramControls:[{id:"mode",label:"Mode",type:"select",options:["frame","channel"]},{id:"playstyle",label:"Playstyle",type:"select",options:["once","repeat"]},{id:"useCustomOrder",label:"Custom Order",type:"checkbox",showIf:{mode:"channel"}},{id:"delayDirection",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}},{id:"delayAmount",label:"Delay Time",type:"range",min:1,max:60,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01}]},{id:"chase",name:"Chase",type:"effect",description:"Frame or Channel based chase effect.",defaultParams:{mode:"frame",playstyle:"repeat",steps:4,decay:.8,speed:1,overlap:1,direction:"left_to_right",useCustomOrder:!1,customOrder:[],enabled:!0},paramControls:[{id:"mode",label:"Mode",type:"select",options:["frame","channel"]},{id:"playstyle",label:"Playstyle",type:"select",options:["once","repeat","bounce"]},{id:"steps",label:"Steps",type:"range",min:2,max:16,step:1,showIf:{mode:"frame"}},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:5,step:.1},{id:"overlap",label:"Overlap",type:"range",min:1,max:4,step:1},{id:"useCustomOrder",label:"Custom Order",type:"checkbox",showIf:{mode:"channel"}},{id:"direction",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}}]},{id:"blanking",name:"Blanking",type:"animation",description:"Controls the blanking of the laser output.",defaultParams:{blankingInterval:0,spacing:0},paramControls:[{id:"blankingInterval",label:"Blanking Interval",type:"range",min:0,max:10,step:1},{id:"spacing",label:"Spacing",type:"range",min:0,max:20,step:1}]},{id:"strobe",name:"Strobe",type:"animation",description:"Applies a strobe effect to the laser output.",defaultParams:{strobeSpeed:100,strobeAmount:.5},paramControls:[{id:"strobeSpeed",label:"Strobe Speed (ms)",type:"range",min:10,max:1e3,step:10},{id:"strobeAmount",label:"Strobe Amount (0-1)",type:"range",min:0,max:1,step:.01}]},{id:"mirror",name:"Mirror",type:"transform",description:"Mirrors the shape from the center.",defaultParams:{mode:"none"},paramControls:[{id:"mode",label:"Mirror Mode",type:"select",options:["none","x+","x-","y+","y-"]}]}],L=(s,e)=>({...e,...s});function N(s,e,p,o){if(!p)return e;const r=typeof p=="string"?{syncMode:p}:p;if(!r.syncMode)return e;const{time:t,progress:a=0,bpm:l=120,clipDuration:i=0,fftLevels:c={low:0,mid:0,high:0},activationTime:h=0}=o;let n=0;const f=r.speedMultiplier||1,d=r.style||"loop";if(d==="once"&&h>0){const y=(t-h)*.001;let A=1;if(r.syncMode==="timeline")A=Math.max(.01,r.duration||1);else if(r.syncMode==="bpm"){const F=Math.max(.1,r.beats||4),_=l/60;A=F/(_||2)}else if(r.syncMode==="fps")return n=y*f,calculateAnimPhase(n,r,e);n=y/A*f}else if(r.syncMode==="fps")n=t*.001*f;else if(r.syncMode==="timeline"){const y=Math.max(.01,r.duration||1);i>0?n=a*i/y*f:n=0}else if(r.syncMode==="bpm"){const y=Math.max(.1,r.beats||4),A=l/60,F=y/(A||2);i>0?n=a*i/F*f:n=0}else if(r.syncMode==="fft"){const y=r.fftRange||"low",A=c[y]||0;return X(A,e,r)}d==="bounce"&&(n*=2);const u=r.direction||"forward";if(u==="pause")return e;let m=0;if(d==="once")m=Math.min(n,1),u==="backward"&&(m=1-m);else if(d==="bounce"){let y=n%1;Math.floor(n)%2===1?m=1-y:m=y,u==="backward"&&(m=1-m)}else m=n%1,u==="backward"&&(m=1-m);const P=r.range;let g=0,R=1;if(P&&Array.isArray(P)&&P.length===2)g=P[0],R=P[1];else return e;return g+(R-g)*m}function X(s,e,p){const o=p.range;return o&&Array.isArray(o)&&o.length===2?o[0]+(o[1]-o[0])*s:e}function W(s,e,p={}){const{progress:o=0,time:r=performance.now(),effectStates:t,syncSettings:a={},fftLevels:l}=p;if(!e||e.length===0)return s;let i;if(Array.isArray(s.points)){i=new Float32Array(s.points.length*8);for(let n=0;n<s.points.length;n++){const f=s.points[n],d=n*8;i[d]=f.x,i[d+1]=f.y,i[d+2]=f.z||0,i[d+3]=f.r,i[d+4]=f.g,i[d+5]=f.b,i[d+6]=f.blanking?1:0,i[d+7]=f.lastPoint?1:0}}else i=new Float32Array(s.points);let c=i;const h=()=>c.length/8;for(const n of e){if(n.params.enabled===!1||!I.find(u=>u.id===n.id))continue;const d={...n.params};for(const u of Object.keys(d)){const m=n.instanceId?`${n.instanceId}.${u}`:`${n.id}.${u}`;a[m]&&(d[u]=N(u,d[u],a[m],p))}switch(n.id){case"rotate":q(c,h(),d,o,r);break;case"scale":V(c,h(),d);break;case"translate":G(c,h(),d);break;case"color":z(c,h(),d,r);break;case"wave":$(c,h(),d,r);break;case"blanking":Q(c,h(),d);break;case"strobe":K(c,h(),d,r);break;case"mirror":c=j(c,h(),d);break;case"warp":Z(c,h(),d,r);break;case"distortion":J(c,h(),d,r);break;case"move":ee(c,h(),d,r);break;case"delay":t&&n.instanceId&&(c=te(c,h(),d,t,n.instanceId,p));break;case"chase":c=ae(c,h(),d,r,p);break}}return{...s,points:c,isTypedArray:!0}}function q(s,e,p,o,r){const{angle:t,speed:a,direction:l}=L(p,I.find(d=>d.id==="rotate").defaultParams),i=l==="CCW"?-1:1,c=r*.001*a*i,h=t*Math.PI/180+c,n=Math.sin(h),f=Math.cos(h);for(let d=0;d<e;d++){const u=d*8,m=s[u],P=s[u+1];s[u]=m*f-P*n,s[u+1]=m*n+P*f}}function V(s,e,p){const{scaleX:o,scaleY:r}=L(p,I.find(t=>t.id==="scale").defaultParams);for(let t=0;t<e;t++){const a=t*8;s[a]*=o,s[a+1]*=r}}function G(s,e,p){const{translateX:o,translateY:r}=L(p,I.find(t=>t.id==="translate").defaultParams);for(let t=0;t<e;t++){const a=t*8;s[a]+=o,s[a+1]+=r}}function z(s,e,p,o){const{mode:r,r:t,g:a,b:l,cycleSpeed:i,rainbowSpread:c,rainbowOffset:h,rainbowPalette:n}=L(p,I.find(d=>d.id==="color").defaultParams),f=o*.001*i;if(r==="rainbow"){const d=n||"rainbow";for(let u=0;u<e;u++){const m=u*8,P=(u/e*c+f*.5+h/360)%1;let g,R,y;d==="rainbow"?[g,R,y]=O(P,1,.5):[g,R,y]=H(d,P),s[m+3]=g,s[m+4]=R,s[m+5]=y}}else if(i>0){const d=f*50%360,[u,m,P]=O(d/360,1,.5);for(let g=0;g<e;g++){const R=g*8;s[R+3]=u,s[R+4]=m,s[R+5]=P}}else for(let d=0;d<e;d++){const u=d*8;s[u+3]=t,s[u+4]=a,s[u+5]=l}}function H(s,e){const p={fire:[{r:255,g:0,b:0},{r:255,g:128,b:0},{r:255,g:255,b:0},{r:255,g:0,b:0}],ice:[{r:0,g:0,b:255},{r:0,g:255,b:255},{r:255,g:255,b:255},{r:0,g:0,b:255}],cyber:[{r:255,g:0,b:255},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:255,g:0,b:255}]},o=p[s]||p.fire,r=e*(o.length-1),t=Math.floor(r),a=r-t,l=o[t],i=o[t+1]||o[t];return[Math.round(l.r+(i.r-l.r)*a),Math.round(l.g+(i.g-l.g)*a),Math.round(l.b+(i.b-l.b)*a)]}function O(s,e,p){let o,r,t;{const a=(c,h,n)=>(n<0&&(n+=1),n>1&&(n-=1),n<.16666666666666666?c+(h-c)*6*n:n<.5?h:n<.6666666666666666?c+(h-c)*(.6666666666666666-n)*6:c),l=p+e-p*e,i=2*p-l;o=a(i,l,s+1/3),r=a(i,l,s),t=a(i,l,s-1/3)}return[Math.round(o*255),Math.round(r*255),Math.round(t*255)]}function $(s,e,p,o){const{amplitude:r,frequency:t,speed:a,direction:l}=L(p,I.find(c=>c.id==="wave").defaultParams),i=o*.001*a;for(let c=0;c<e;c++){const h=c*8;l==="x"?s[h+1]+=r*Math.sin(s[h]*t+i):l==="y"&&(s[h]+=r*Math.sin(s[h+1]*t+i))}}function Q(s,e,p){const{blankingInterval:o,spacing:r=0}=L(p,I.find(a=>a.id==="blanking").defaultParams);if(o<=0)return;const t=o+1+r;for(let a=0;a<e;a++)a%t>=o&&(s[a*8+6]=1)}function K(s,e,p,o){const{strobeSpeed:r,strobeAmount:t}=L(p,I.find(l=>l.id==="strobe").defaultParams);if(o%r/r<t)for(let l=0;l<e;l++)s[l*8+6]=1}function j(s,e,p){const{mode:o}=L(p,I.find(i=>i.id==="mirror").defaultParams);if(o==="none")return s;let r=[];for(let i=0;i<e;i++){const c=i*8,h=s[c],n=s[c+1];let f=!1;o==="x-"&&(h<=0||o==="x+"&&(h>=0||o==="y-"&&(n<=0||o==="y+"&&n>=0)))&&(f=!0),f&&r.push({x:s[c],y:s[c+1],z:s[c+2],r:s[c+3],g:s[c+4],b:s[c+5],blk:s[c+6],last:s[c+7]})}const t=r.length*2,a=new Float32Array(t*8);let l=0;for(const i of r)a[l++]=i.x,a[l++]=i.y,a[l++]=i.z,a[l++]=i.r,a[l++]=i.g,a[l++]=i.b,a[l++]=i.blk,a[l++]=i.last;for(const i of r)o==="x-"||o==="x+"?a[l++]=-i.x:a[l++]=i.x,o==="y-"||o==="y+"?a[l++]=-i.y:a[l++]=i.y,a[l++]=i.z,a[l++]=i.r,a[l++]=i.g,a[l++]=i.b,a[l++]=i.blk,a[l++]=i.last;return a}function Z(s,e,p,o){const{amount:r,chaos:t,speed:a}=L(p,I.find(i=>i.id==="warp").defaultParams),l=o*.001*a;for(let i=0;i<e;i++){const c=i*8,h=s[c],n=s[c+1],f=Math.abs(n);s[c]+=Math.sin(f*10*(1+t)+l)*r*Math.cos(l*t),s[c+1]+=Math.cos(Math.abs(h)*10*(1+t)+l)*r*Math.sin(l*t)}}function J(s,e,p,o){const{amount:r,scale:t,speed:a}=L(p,I.find(i=>i.id==="distortion").defaultParams),l=o*.001*a;for(let i=0;i<e;i++){const c=i*8,h=Math.sin(s[c]*t+l)*Math.cos(s[c+1]*t-l),n=Math.cos(s[c]*t-l)*Math.sin(s[c+1]*t+l);s[c]+=h*r,s[c+1]+=n*r}}function ee(s,e,p,o){const{speedX:r,speedY:t}=L(p,I.find(h=>h.id==="move").defaultParams),a=o*.001,l=a*r,i=a*t,c=4;for(let h=0;h<e;h++){const n=h*8;let f=s[n]+l,d=s[n+1]+i,u=(f+1)%c;u<0&&(u+=c),u>2&&(u=4-u),f=u-1;let m=(d+1)%c;m<0&&(m+=c),m>2&&(m=4-m),d=m-1,s[n]=f,s[n+1]=d}}function te(s,e,p,o,r,t){const{mode:a="frame",delayAmount:l,decay:i,delayDirection:c,useCustomOrder:h,customOrder:n}=L(p,I.find(d=>d.id==="delay").defaultParams);o.has(r)||o.set(r,[]);const f=o.get(r);if(f.unshift(new Float32Array(s)),a==="frame"){const u=l*10+1;f.length>u&&(f.length=u);const m=new Float32Array(s.length);for(let P=0;P<e;P++){let g=0;const R=P/e;c==="left_to_right"?g=Math.floor(R*9):c==="right_to_left"?g=Math.floor((1-R)*9):c==="center_to_out"?g=Math.floor(Math.abs(R-.5)*2*9):c==="out_to_center"&&(g=Math.floor((1-Math.abs(R-.5)*2)*9));const y=g*l,A=y<f.length?f[y]:null,F=Math.pow(i,g),_=P*8;A&&A.length===s.length?(m[_]=A[_],m[_+1]=A[_+1],m[_+2]=A[_+2],m[_+3]=A[_+3]*F,m[_+4]=A[_+4]*F,m[_+5]=A[_+5]*F,m[_+6]=A[_+6],m[_+7]=A[_+7]):(m.set(s.subarray(_,_+8),_),m[_+3]=0,m[_+4]=0,m[_+5]=0,m[_+6]=1)}return m}else{const{assignedDacs:d}=t||{};let u=new Map,m=0;if(h||p.delayMode==="channel")(n&&n.length>0?n.map(x=>x.originalIndex):d?d.map((x,w)=>w):[0]).forEach((x,w)=>{u.set(x,w),m=Math.max(m,w)});else{const x=(d||[]).length||1;for(let w=0;w<x;w++){let b=w;c==="right_to_left"?b=x-1-w:c==="center_to_out"?b=Math.floor(Math.abs(w-(x-1)/2)):c==="out_to_center"&&(b=Math.min(w,x-1-w)),u.set(w,b),m=Math.max(m,b)}}const g=m+1,R=l*g+1;f.length>R&&(f.length=R);const y=[];for(let M=0;M<g;M++){const x=M*l;y.push({points:x<f.length?f[x]:null,factor:Math.pow(i,M),index:M})}const A=y.reduce((M,x)=>M+(x.points?x.points.length/8:s.length/8),0),F=new Float32Array(A*8);let _=0;const E=new Array(y.length);for(let M=0;M<y.length;M++){const x=y[M],w=x.points,b=w?w.length/8:s.length/8;E[M]=_;for(let S=0;S<b;S++){const v=S*8,B=_+S*8;w?(F[B]=w[v],F[B+1]=w[v+1],F[B+2]=w[v+2],F[B+3]=w[v+3]*x.factor,F[B+4]=w[v+4]*x.factor,F[B+5]=w[v+5]*x.factor,F[B+6]=w[v+6],F[B+7]=w[v+7]):F[B+6]=1}_+=b*8}const C=new Map;return u.forEach((M,x)=>{M<y.length&&C.set(x,{start:E[M],length:y[M].points?y[M].points.length:s.length})}),F._channelDistributions=C,F}}function ae(s,e,p,o,r={}){const{mode:t="frame",steps:a,decay:l,speed:i,overlap:c,direction:h,useCustomOrder:n,customOrder:f,playstyle:d="loop"}=L(p,I.find(g=>g.id==="chase").defaultParams),{progress:u=0,clipDuration:m=1}=r,P=u!==void 0&&m>0;if(t==="frame"){const g=a;let R=(P?u*g:o*.001)*i;if(d==="bounce"){const A=g,F=R%(A*2);R=F>A?A*2-F:F}else d==="once"?R=Math.min(R,g):R=R%g;const y=new Float32Array(s.length);for(let A=0;A<e;A++){const F=A/e;let _=0;h==="left_to_right"?_=Math.min(g-1,Math.floor(F*g)):h==="right_to_left"?_=Math.min(g-1,Math.floor((1-F)*g)):h==="center_to_out"?_=Math.min(g-1,Math.floor(Math.abs(F-.5)*2*g)):h==="out_to_center"&&(_=Math.min(g-1,Math.floor((1-Math.abs(F-.5)*2)*g)));let E=Math.abs(R-_);E>g/2&&(E=g-E);let C=E<c?1-E/c:0;l>0&&(C=Math.pow(C,1-l));const M=A*8;y.set(s.subarray(M,M+8),M),y[M+3]*=C,y[M+4]*=C,y[M+5]*=C,C<.05&&(y[M+6]=1)}return y}else{const{assignedDacs:g}=r||{};let R=new Map,y=0;if(n)(f&&f.length>0?f.map(b=>b.originalIndex):g?g.map((b,S)=>S):[0]).forEach((b,S)=>{R.set(b,S),y++});else{y=(g?g.length:1)||1;for(let w=0;w<y;w++){let b=w;h==="right_to_left"?b=y-1-w:h==="center_to_out"?b=Math.floor(Math.abs(w-(y-1)/2)):h==="out_to_center"&&(b=Math.min(w,y-1-w)),R.set(w,b)}}const A=y;let F=(P?u*A:o*.001)*i;if(d==="bounce"){const w=A,b=F%(w*2);F=b>w?w*2-b:b}else d==="once"?F=Math.min(F,A):F=F%A;const _=e*y,E=new Float32Array(_*8),C=new Map;let M=0;const x=Array.from(R.keys());x.length===0&&x.push(0);for(const w of x){const b=R.get(w)||0;let S=Math.abs(F-b);S>A/2&&(S=A-S);let v=S<c?1-S/c:0;l>0&&(v=Math.pow(v,1-l));const B=M;for(let D=0;D<e;D++){const Y=D*8,T=M+D*8;E.set(s.subarray(Y,Y+8),T),E[T+3]*=v,E[T+4]*=v,E[T+5]*=v,v<.05&&(E[T+6]=1)}C.set(w,{start:B,length:e*8}),M+=e*8}return E._channelDistributions=C,E}}function re(s,e){if(!e||!s||!s.points)return s;const{safetyZones:p,outputArea:o,transformationEnabled:r,transformationMode:t,flipX:a,flipY:l}=e;let i=s.points;const c=s.isTypedArray||i instanceof Float32Array,h=c?i.length/8:i.length;let n=c?new Float32Array(i):i.map(f=>({...f}));for(let f=0;f<h;f++){let d,u,m,P,g,R;if(c?(d=n[f*8],u=n[f*8+1],m=n[f*8+3],P=n[f*8+4],g=n[f*8+5],R=n[f*8+6]):(d=n[f].x,u=n[f].y,m=n[f].r,P=n[f].g,g=n[f].b,R=n[f].blanking?1:0),r&&o){let y=(d+1)/2,A=(1-u)/2;t==="crop"?(y<o.x||y>o.x+o.w||A<o.y||A>o.y+o.h)&&(m=0,P=0,g=0,R=1):t==="scale"&&(y=o.x+y*o.w,A=o.y+A*o.h,d=y*2-1,u=1-A*2)}if(p&&p.length>0){let y=(d+1)/2,A=(1-u)/2;for(const F of p)if(y>=F.x&&y<=F.x+F.w&&A>=F.y&&A<=F.y+F.h){m=0,P=0,g=0,R=1;break}}a&&(d=-d),l&&(u=-u),d=Math.max(-1,Math.min(1,d)),u=Math.max(-1,Math.min(1,u)),c?(n[f*8]=d,n[f*8+1]=u,n[f*8+3]=m,n[f*8+4]=P,n[f*8+5]=g,n[f*8+6]=R):(n[f].x=d,n[f].y=u,n[f].r=m,n[f].g=P,n[f].b=g,n[f].blanking=R>.5)}return{...s,points:n,isTypedArray:c}}class oe{constructor(e,p){if(this.canvas=e,this.type=p,this.gl=e.getContext("webgl")||e.getContext("experimental-webgl"),this.animationFrameId=null,this.frameIndexes=Array(10).fill(0),this.pointIndexes=Array(10).fill(0),this.showBeamEffect=!1,this.beamAlpha=.5,this.fadeAlpha=.13,this.beamRenderMode="both",this.positionBuffer=null,this.colorBuffer=null,this.alphaBuffer=null,this.lastPointDrawTime=0,!this.gl){console.error("WebGL not supported");return}this.setup()}setup(){const e=this.gl,p=`
      attribute vec2 aPosition;
      attribute vec3 aColor;
      attribute float aAlpha;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        gl_PointSize = 2.0;
        vColor = aColor;
        vAlpha = aAlpha;
      }
    `,o=`
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(vColor, vAlpha);
      }
    `,r=this.createShader(e.VERTEX_SHADER,p),t=this.createShader(e.FRAGMENT_SHADER,o),a=this.createProgram(r,t);this.program=a,this.positionAttributeLocation=e.getAttribLocation(a,"aPosition"),this.colorAttributeLocation=e.getAttribLocation(a,"aColor"),this.alphaAttributeLocation=e.getAttribLocation(a,"aAlpha"),this.quadPositionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer);const l=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(l),e.STATIC_DRAW),this.quadColorUniformLocation=e.getUniformLocation(a,"uColor"),this.quadAlphaUniformLocation=e.getUniformLocation(a,"uAlpha");const i=`
      attribute vec2 aPosition;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `,c=`
      precision mediump float;
      uniform vec4 uColor;
      void main() {
        gl_FragColor = uColor;
      }
    `,h=this.createShader(e.VERTEX_SHADER,i),n=this.createShader(e.FRAGMENT_SHADER,c);this.fadeProgram=this.createProgram(h,n),this.fadePositionAttributeLocation=e.getAttribLocation(this.fadeProgram,"aPosition"),this.fadeColorUniformLocation=e.getUniformLocation(this.fadeProgram,"uColor"),e.useProgram(a);const f=131072;this.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.bufferData(e.ARRAY_BUFFER,f*2*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.colorBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.colorBuffer),e.bufferData(e.ARRAY_BUFFER,f*3*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.alphaBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.alphaBuffer),e.bufferData(e.ARRAY_BUFFER,f*1*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.clearColor(0,0,0,1)}reset(){this.frameIndexes.fill(0),this.pointIndexes.fill(0),this.clearCanvas()}createShader(e,p){const o=this.gl,r=o.createShader(e);if(o.shaderSource(r,p),o.compileShader(r),o.getShaderParameter(r,o.COMPILE_STATUS))return r;console.error(o.getShaderInfoLog(r)),o.deleteShader(r)}createProgram(e,p){const o=this.gl,r=o.createProgram();if(o.attachShader(r,e),o.attachShader(r,p),o.linkProgram(r),o.getProgramParameter(r,o.LINK_STATUS))return r;console.error(o.getProgramInfoLog(r)),o.deleteProgram(r)}render(e){e.showBeamEffect!==void 0&&this.setBeamEffect(e.showBeamEffect),e.beamAlpha!==void 0&&this.setBeamAlpha(e.beamAlpha),e.fadeAlpha!==void 0&&this.setFadeAlpha(e.fadeAlpha),e.beamRenderMode!==void 0&&(this.beamRenderMode=e.beamRenderMode),this.type==="world"?this.renderWorld(e.worldData,e.previewScanRate,e.layerIntensities,e.masterIntensity,e.dacSettings,e.previewTime,e.fftLevels):this.renderSingle(e.ildaFrames,e.previewScanRate,e.intensity,e.effects,e.syncSettings,e.bpm,e.clipDuration,e.progress,e.previewTime,e.fftLevels,e.effectStates)}renderSingle(e,p,o,r,t={},a=120,l=1,i=null,c=null,h={low:0,mid:0,high:0},n=null){const f=this.gl;if(f.viewport(0,0,f.canvas.width,f.canvas.height),this.drawFadeQuad(),!e||e.length===0)return;const d=this.frameIndexes[0]%e.length,u=e[d],m=i!==null?i:d/e.length,P=c!==null?c:performance.now();this.draw(u,r,this.showBeamEffect,this.beamAlpha,p,this.beamRenderMode,o,0,m,P,t,a,l,h,n),this.frameIndexes[0]++,this.frameIndexes[0]>=e.length&&(this.frameIndexes[0]=0)}renderWorld(e,p,o,r,t,a=null,l={low:0,mid:0,high:0}){const i=this.gl;i.viewport(0,0,i.canvas.width,i.canvas.height),this.drawFadeQuad();const c=a!==null?a:performance.now();e.forEach(h=>{if(h&&h.frames&&h.frames.length>0){const n=h.frames[0];if(n){const f=h.layerIndex||0;if(h.syncSettings,h.bpm,f>=this.frameIndexes.length){const m=f+5;for(;this.frameIndexes.length<m;)this.frameIndexes.push(0),this.pointIndexes.push(0)}const u=(o[f]!==void 0?o[f]:1)*r;if(u>.001){const m=h.progress!==void 0?h.progress:this.frameIndexes[f]%h.frames.length/h.frames.length,{syncSettings:P={},bpm:g=120,clipDuration:R=1,effectStates:y=null}=h;let A=n;if(t){let F=n;if(t.dimmer!==void 0&&t.dimmer<1){const _=n.points,E=n.isTypedArray||_ instanceof Float32Array,C=E?_.length/8:_.length,M=E?new Float32Array(_):_.map(x=>({...x}));for(let x=0;x<C;x++)E?(M[x*8+3]*=t.dimmer,M[x*8+4]*=t.dimmer,M[x*8+5]*=t.dimmer):(M[x].r*=t.dimmer,M[x].g*=t.dimmer,M[x].b*=t.dimmer);F={...n,points:M,isTypedArray:E}}A=re(F,t)}this.draw(A,h.effects,this.showBeamEffect,this.beamAlpha,p,this.beamRenderMode,u,f,m,c,P,g,R,l,y)}}}}),e.forEach(h=>{if(h&&h.frames){const n=h.layerIndex||0;this.frameIndexes[n]++,this.frameIndexes[n]>=h.frames.length&&(this.frameIndexes[n]=0)}})}drawFadeQuad(){const e=this.gl;this.fadeProgram&&(e.useProgram(this.fadeProgram),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer),e.enableVertexAttribArray(this.fadePositionAttributeLocation),e.vertexAttribPointer(this.fadePositionAttributeLocation,2,e.FLOAT,!1,0,0),e.uniform4f(this.fadeColorUniformLocation,0,0,0,this.fadeAlpha),e.drawArrays(e.TRIANGLES,0,6))}setBeamEffect(e){this.showBeamEffect=e}setBeamAlpha(e){this.beamAlpha=e}setFadeAlpha(e){this.fadeAlpha=e}draw(e,p,o,r,t,a,l=1,i=0,c=0,h=performance.now(),n={},f=120,d=1,u={low:0,mid:0,high:0},m=null){if(this.gl,!e||!e.points)return;const P=W(e,p,{progress:c,time:h,syncSettings:n,bpm:f,clipDuration:d,fftLevels:u,effectStates:m}),g=P.points,R=P.isTypedArray,y=R?g.length/8:g.length;if(y===0)return;const A=Math.max(1,Math.floor(y/t));let F=this.pointIndexes[i]||0;F>=y&&(F=0);const _=x=>{const w=(F+x)%y;if(R){const b=w*8;return{x:g[b],y:g[b+1],r:g[b+3],g:g[b+4],b:g[b+5],blanking:g[b+6]===1}}else{const b=g[w];return{x:b.x,y:b.y,r:b.r,g:b.g,b:b.b,blanking:b.blanking}}},E=()=>{const x=a==="points"||a==="both",w=a==="lines"||a==="both";let b=[],S=[];for(let v=0;v<A;v++){const B=_(v);if(B.blanking){b.length>0&&(w&&this._drawSegment(new Float32Array(b),new Float32Array(S),1,b.length/2,!1),x&&this._drawSegment(new Float32Array(b),new Float32Array(S),1,b.length/2,!0),b=[],S=[]);continue}b.push(B.x,B.y),S.push(B.r/255*l,B.g/255*l,B.b/255*l)}b.length>0&&(w&&this._drawSegment(new Float32Array(b),new Float32Array(S),1,b.length/2,!1),x&&this._drawSegment(new Float32Array(b),new Float32Array(S),1,b.length/2,!0))},C=()=>{const x=[],w=[];for(let b=0;b<A;b++){const S=_(b);if(!S.blanking){x.push(0,0,S.x,S.y);const v=[S.r/255*l,S.g/255*l,S.b/255*l];w.push(...v,...v)}}x.length>0&&this._drawLines(new Float32Array(x),new Float32Array(w),r,x.length/2)},M=()=>{const x=[],w=[];let b=_(0);for(let S=1;S<A;S++){const v=_(S);if(!b.blanking&&!v.blanking){x.push(0,0,b.x,b.y,v.x,v.y);const B=[b.r/255*l,b.g/255*l,b.b/255*l],D=[v.r/255*l,v.g/255*l,v.b/255*l],Y=[(B[0]+D[0])/2,(B[1]+D[1])/2,(B[2]+D[2])/2],T=.3,ne=[B[0]*T,B[1]*T,B[2]*T],se=[D[0]*T,D[1]*T,D[2]*T];w.push(...Y,...ne,...se)}b=v}x.length>0&&this._drawTriangles(new Float32Array(x),new Float32Array(w),r,x.length/2)};E(),o&&(a==="points"?C():a==="lines"?M():a==="both"&&(M(),C())),this.pointIndexes[i]=(F+A)%y}_drawSegment(e,p,o,r,t=!1){const a=this.gl;a.useProgram(this.program),a.bindBuffer(a.ARRAY_BUFFER,this.positionBuffer),a.bufferSubData(a.ARRAY_BUFFER,0,e),a.enableVertexAttribArray(this.positionAttributeLocation),a.vertexAttribPointer(this.positionAttributeLocation,2,a.FLOAT,!1,0,0),a.bindBuffer(a.ARRAY_BUFFER,this.colorBuffer),a.bufferSubData(a.ARRAY_BUFFER,0,p),a.enableVertexAttribArray(this.colorAttributeLocation),a.vertexAttribPointer(this.colorAttributeLocation,3,a.FLOAT,!1,0,0);const l=new Float32Array(Array(r).fill(o));a.bindBuffer(a.ARRAY_BUFFER,this.alphaBuffer),a.bufferSubData(a.ARRAY_BUFFER,0,l),a.enableVertexAttribArray(this.alphaAttributeLocation),a.vertexAttribPointer(this.alphaAttributeLocation,1,a.FLOAT,!1,0,0),a.drawArrays(t?a.POINTS:a.LINE_STRIP,0,r)}_drawLines(e,p,o,r){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,p),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const a=new Float32Array(Array(r).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,a),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINES,0,r)}_drawTriangles(e,p,o,r){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,p),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const a=new Float32Array(Array(r).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,a),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLES,0,r)}clearCanvas(){const e=this.gl;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT)}destroy(){if(cancelAnimationFrame(this.animationFrameId),this.gl){const e=this.gl.getExtension("WEBGL_losing_context");e&&e.loseContext()}}}const k=new Map;function U(s,e=0){const p=k.get(s);if(!p)return;const o=performance.now();p.renderer.render(p.data),e=o,p.animationFrameId=requestAnimationFrame(()=>U(s,e))}self.onmessage=s=>{const{action:e,payload:p}=s.data;if(e==="register"){const{id:o,canvas:r,type:t,data:a}=p,l=new oe(r,t),i=requestAnimationFrame(()=>U(o));k.set(o,{renderer:l,type:t,data:a,animationFrameId:i})}else if(e==="deregister"){const{id:o}=p,r=k.get(o);r&&(cancelAnimationFrame(r.animationFrameId),k.delete(o))}else if(e==="update"){const{id:o,data:r}=p,t=k.get(o);t&&(t.data=r)}else if(e==="clear"){const{id:o}=p,r=k.get(o);r&&r.renderer.clearCanvas()}}})();
