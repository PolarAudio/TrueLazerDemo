(function(){"use strict";const _=[{id:"rotate",name:"Rotate",type:"transform",description:"Rotates the shape around its center.",defaultParams:{angle:0,speed:0,direction:"CW"},paramControls:[{id:"angle",label:"Angle",type:"range",min:0,max:360,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["CW","CCW"]}]},{id:"scale",name:"Scale",type:"transform",description:"Scales the shape.",defaultParams:{scaleX:1,scaleY:1},paramControls:[{id:"scaleX",label:"Scale X",type:"range",min:.01,max:5,step:.01},{id:"scaleY",label:"Scale Y",type:"range",min:.01,max:5,step:.01}]},{id:"translate",name:"Translate",type:"transform",description:"Moves the shape.",defaultParams:{translateX:0,translateY:0},paramControls:[{id:"translateX",label:"Translate X",type:"range",min:-1,max:1,step:.01},{id:"translateY",label:"Translate Y",type:"range",min:-1,max:1,step:.01}]},{id:"color",name:"Color",type:"color",description:"Changes the color of the shape with solid or rainbow modes.",defaultParams:{mode:"solid",r:255,g:255,b:255,cycleSpeed:0,rainbowSpread:1,rainbowOffset:0},paramControls:[{id:"mode",label:"Mode",type:"select",options:["solid","rainbow"]},{id:"r",label:"Red",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"g",label:"Green",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"b",label:"Blue",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"cycleSpeed",label:"Cycle Speed",type:"range",min:0,max:10,step:.1},{id:"rainbowSpread",label:"Rainbow Spread",type:"range",min:.1,max:10,step:.1,showIf:{mode:"rainbow"}},{id:"rainbowOffset",label:"Rainbow Offset",type:"range",min:0,max:360,step:1,showIf:{mode:"rainbow"}},{id:"rainbowPalette",label:"Palette",type:"select",options:["rainbow","fire","ice","cyber"],showIf:{mode:"rainbow"}}]},{id:"wave",name:"Wave",type:"animation",description:"Applies a wave distortion to the shape.",defaultParams:{amplitude:.1,frequency:10,speed:1,direction:"x"},paramControls:[{id:"amplitude",label:"Amplitude",type:"range",min:.01,max:1,step:.01},{id:"frequency",label:"Frequency",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["x","y"]}]},{id:"warp",name:"Warp",type:"animation",description:"Symmetrical chaotic wave distortion.",defaultParams:{amount:.1,chaos:.5,speed:1},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"chaos",label:"Chaos",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1}]},{id:"distortion",name:"Distortion",type:"transform",description:"Distorts the point data.",defaultParams:{amount:.1,scale:10,speed:.5},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"scale",label:"Scale",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:5,step:.1}]},{id:"move",name:"Move (Bounce)",type:"transform",description:"Moves points and bounces them off the borders.",defaultParams:{speedX:.1,speedY:.1},paramControls:[{id:"speedX",label:"Speed X",type:"range",min:0,max:2,step:.01},{id:"speedY",label:"Speed Y",type:"range",min:0,max:2,step:.01}]},{id:"delay",name:"Delay",type:"effect",description:"Channel-based delay effect.",defaultParams:{useAssigned:!0,delayI:!0,delayC:!1,delayE:!1,delayMode:"linear",delayDirection:"left_to_right",delayAmount:5,decay:.8},paramControls:[{id:"useAssigned",label:"Use Assigned Channels",type:"checkbox"},{id:"delayI",label:"I (Intensity)",type:"checkbox"},{id:"delayC",label:"C (Color)",type:"checkbox"},{id:"delayE",label:"E (Effect)",type:"checkbox"},{id:"delayMode",label:"Mode",type:"select",options:["linear","symmetric"]},{id:"delayDirection",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"]},{id:"delayAmount",label:"Delay Time",type:"range",min:1,max:60,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01}]},{id:"chase",name:"Chase",type:"effect",description:"Step-based chase effect.",defaultParams:{steps:4,decay:.8,speed:1},paramControls:[{id:"steps",label:"Steps",type:"range",min:2,max:16,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:5,step:.1}]},{id:"blanking",name:"Blanking",type:"animation",description:"Controls the blanking of the laser output.",defaultParams:{blankingInterval:0},paramControls:[{id:"blankingInterval",label:"Blanking Interval",type:"range",min:0,max:10,step:1}]},{id:"strobe",name:"Strobe",type:"animation",description:"Applies a strobe effect to the laser output.",defaultParams:{strobeSpeed:100,strobeAmount:.5},paramControls:[{id:"strobeSpeed",label:"Strobe Speed (ms)",type:"range",min:10,max:1e3,step:10},{id:"strobeAmount",label:"Strobe Amount (0-1)",type:"range",min:0,max:1,step:.01}]},{id:"mirror",name:"Mirror",type:"transform",description:"Mirrors the shape from the center.",defaultParams:{mode:"none"},paramControls:[{id:"mode",label:"Mirror Mode",type:"select",options:["none","x+","x-","y+","y-"]}]}],C=(o,e)=>({...e,...o});function U(o,e,f={}){const{progress:n=0,time:r=performance.now(),effectStates:t}=f;if(!e||e.length===0)return o;let l;if(Array.isArray(o.points)){l=new Float32Array(o.points.length*8);for(let a=0;a<o.points.length;a++){const i=o.points[a],d=a*8;l[d]=i.x,l[d+1]=i.y,l[d+2]=i.z||0,l[d+3]=i.r,l[d+4]=i.g,l[d+5]=i.b,l[d+6]=i.blanking?1:0,l[d+7]=i.lastPoint?1:0}}else l=new Float32Array(o.points);let s=l;const c=()=>s.length/8;for(const a of e)if(_.find(d=>d.id===a.id))switch(a.id){case"rotate":O(s,c(),a.params,n,r);break;case"scale":X(s,c(),a.params);break;case"translate":N(s,c(),a.params);break;case"color":W(s,c(),a.params,r);break;case"wave":q(s,c(),a.params,r);break;case"blanking":G(s,c(),a.params);break;case"strobe":H(s,c(),a.params,r);break;case"mirror":z(s,c(),a.params);break;case"warp":Q(s,c(),a.params,r);break;case"distortion":K(s,c(),a.params,r);break;case"move":Z(s,c(),a.params,r);break;case"delay":t&&a.instanceId&&(s=$(s,c(),a.params,t,a.instanceId));break;case"chase":j(s,c(),a.params,r);break}return{...o,points:s,isTypedArray:!0}}function O(o,e,f,n,r){const{angle:t,speed:l,direction:s}=C(f,_.find(p=>p.id==="rotate").defaultParams),c=s==="CCW"?-1:1,a=r*.001*l*c,i=t*Math.PI/180+a,d=Math.sin(i),u=Math.cos(i);for(let p=0;p<e;p++){const h=p*8,g=o[h],w=o[h+1];o[h]=g*u-w*d,o[h+1]=g*d+w*u}}function X(o,e,f){const{scaleX:n,scaleY:r}=C(f,_.find(t=>t.id==="scale").defaultParams);for(let t=0;t<e;t++){const l=t*8;o[l]*=n,o[l+1]*=r}}function N(o,e,f){const{translateX:n,translateY:r}=C(f,_.find(t=>t.id==="translate").defaultParams);for(let t=0;t<e;t++){const l=t*8;o[l]+=n,o[l+1]+=r}}function W(o,e,f,n){const{mode:r,r:t,g:l,b:s,cycleSpeed:c,rainbowSpread:a,rainbowOffset:i,rainbowPalette:d}=C(f,_.find(p=>p.id==="color").defaultParams),u=n*.001*c;if(r==="rainbow"){const p=d||"rainbow";for(let h=0;h<e;h++){const g=h*8,w=(h/e*a+u*.5+i/360)%1;let m,x,A;p==="rainbow"?[m,x,A]=D(w,1,.5):[m,x,A]=V(p,w),o[g+3]=m,o[g+4]=x,o[g+5]=A}}else if(c>0){const p=u*50%360,[h,g,w]=D(p/360,1,.5);for(let m=0;m<e;m++){const x=m*8;o[x+3]=h,o[x+4]=g,o[x+5]=w}}else for(let p=0;p<e;p++){const h=p*8;o[h+3]=t,o[h+4]=l,o[h+5]=s}}function V(o,e){const f={fire:[{r:255,g:0,b:0},{r:255,g:128,b:0},{r:255,g:255,b:0},{r:255,g:0,b:0}],ice:[{r:0,g:0,b:255},{r:0,g:255,b:255},{r:255,g:255,b:255},{r:0,g:0,b:255}],cyber:[{r:255,g:0,b:255},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:255,g:0,b:255}]},n=f[o]||f.fire,r=e*(n.length-1),t=Math.floor(r),l=r-t,s=n[t],c=n[t+1]||n[t];return[Math.round(s.r+(c.r-s.r)*l),Math.round(s.g+(c.g-s.g)*l),Math.round(s.b+(c.b-s.b)*l)]}function D(o,e,f){let n,r,t;{const l=(a,i,d)=>(d<0&&(d+=1),d>1&&(d-=1),d<.16666666666666666?a+(i-a)*6*d:d<.5?i:d<.6666666666666666?a+(i-a)*(.6666666666666666-d)*6:a),s=f+e-f*e,c=2*f-s;n=l(c,s,o+1/3),r=l(c,s,o),t=l(c,s,o-1/3)}return[Math.round(n*255),Math.round(r*255),Math.round(t*255)]}function q(o,e,f,n){const{amplitude:r,frequency:t,speed:l,direction:s}=C(f,_.find(a=>a.id==="wave").defaultParams),c=n*.001*l;for(let a=0;a<e;a++){const i=a*8;s==="x"?o[i+1]+=r*Math.sin(o[i]*t+c):s==="y"&&(o[i]+=r*Math.sin(o[i+1]*t+c))}}function G(o,e,f){const{blankingInterval:n}=C(f,_.find(r=>r.id==="blanking").defaultParams);if(!(n<=0))for(let r=0;r<e;r++)r%(n+1)===n&&(o[r*8+6]=1)}function H(o,e,f,n){const{strobeSpeed:r,strobeAmount:t}=C(f,_.find(s=>s.id==="strobe").defaultParams);if(n%r/r<t)for(let s=0;s<e;s++)o[s*8+6]=1}function z(o,e,f){const{mode:n}=C(f,_.find(r=>r.id==="mirror").defaultParams);if(n!=="none")for(let r=0;r<e;r++){const t=r*8,l=o[t],s=o[t+1];n==="x+"?o[t]=Math.abs(l):n==="x-"?o[t]=-Math.abs(l):n==="y+"?o[t+1]=Math.abs(s):n==="y-"&&(o[t+1]=-Math.abs(s))}}function Q(o,e,f,n){const{amount:r,chaos:t,speed:l}=C(f,_.find(c=>c.id==="warp").defaultParams),s=n*.001*l;for(let c=0;c<e;c++){const a=c*8,i=o[a],d=o[a+1],u=Math.abs(d);o[a]+=Math.sin(u*10*(1+t)+s)*r*Math.cos(s*t),o[a+1]+=Math.cos(Math.abs(i)*10*(1+t)+s)*r*Math.sin(s*t)}}function K(o,e,f,n){const{amount:r,scale:t,speed:l}=C(f,_.find(c=>c.id==="distortion").defaultParams),s=n*.001*l;for(let c=0;c<e;c++){const a=c*8,i=Math.sin(o[a]*t+s)*Math.cos(o[a+1]*t-s),d=Math.cos(o[a]*t-s)*Math.sin(o[a+1]*t+s);o[a]+=i*r,o[a+1]+=d*r}}function Z(o,e,f,n){const{speedX:r,speedY:t}=C(f,_.find(i=>i.id==="move").defaultParams),l=n*.001,s=l*r,c=l*t,a=4;for(let i=0;i<e;i++){const d=i*8;let u=o[d]+s,p=o[d+1]+c,h=(u+1)%a;h<0&&(h+=a),h>2&&(h=4-h),u=h-1;let g=(p+1)%a;g<0&&(g+=a),g>2&&(g=4-g),p=g-1,o[d]=u,o[d+1]=p}}function $(o,e,f,n,r){const t=_.find(A=>A.id==="delay").defaultParams,{delayAmount:l,decay:s,delayI:c,delayC:a,delayE:i,delayDirection:d}=C(f,t);n.has(r)||n.set(r,[]);const u=n.get(r),p=new Float32Array(o);u.unshift(p);const h=l*4+1;u.length>h&&(u.length=h);const g=[];for(let A=1;A<=4;A++){const F=A*l;if(F<u.length){const B=u[F];B.length===o.length&&g.push({points:B,factor:Math.pow(s,A),index:A})}}if(g.length===0)return o;const w=e+g.reduce((A,F)=>A+F.points.length/8,0),m=new Float32Array(w*8);let x=0;for(const A of g.reverse()){const F=A.points,B=F.length/8,L=A.factor,R=A.index;let S=0,b=0,y=1,E=1;d==="left_to_right"?S=-.1*R:d==="right_to_left"?S=.1*R:d==="center_to_out"?y=E=1+.1*R:d==="out_to_center"&&(y=E=1-.1*R);for(let v=0;v<B;v++){const P=v*8,I=x+v*8,te=F[P],ae=F[P+1],re=F[P+2],oe=F[P+3],ne=F[P+4],se=F[P+5],ie=F[P+6],le=o[P],ce=o[P+1],fe=o[P+3],de=o[P+4],he=o[P+5],pe=o[P+6];let T=i?te:le,Y=i?ae:ce;T=T*y+S,Y=Y*E+b,m[I]=T,m[I+1]=Y,m[I+2]=re;const me=a?oe:fe,ue=a?ne:de,be=a?se:he;m[I+3]=me*L,m[I+4]=ue*L,m[I+5]=be*L;const ge=c?ie:pe;m[I+6]=ge,m[I+7]=F[P+7]}x+=F.length}return m.set(o,x),m}function j(o,e,f,n){const{steps:r,decay:t,speed:l}=C(f,_.find(i=>i.id==="chase").defaultParams),s=n*.001*l,c=Math.floor(s%r),a=e/r;for(let i=0;i<e;i++){const d=Math.floor(i/a),u=i*8;let p=Math.abs(d-c);p>r/2&&(p=r-p);let h=1;p>0&&(h=Math.pow(t,p)),o[u+3]*=h,o[u+4]*=h,o[u+5]*=h,h<.1&&(o[u+6]=1)}}function J(o,e){if(!e||!o||!o.points)return o;const{safetyZones:f,outputArea:n,transformationEnabled:r,transformationMode:t}=e;let l=o.points;const s=o.isTypedArray||l instanceof Float32Array,c=s?l.length/8:l.length;let a;s?a=new Float32Array(l):a=l.map(i=>({...i}));for(let i=0;i<c;i++){let d,u,p,h,g,w;if(s?(d=a[i*8],u=a[i*8+1],p=a[i*8+3],h=a[i*8+4],g=a[i*8+5],w=a[i*8+6]):(d=a[i].x,u=a[i].y,p=a[i].r,h=a[i].g,g=a[i].b,w=a[i].blanking?1:0),r&&n){let m=(d+1)/2,x=(1-u)/2;t==="crop"?(m<n.x||m>n.x+n.w||x<n.y||x>n.y+n.h)&&(p=0,h=0,g=0,w=1):t==="scale"&&(m=n.x+m*n.w,x=n.y+x*n.h,d=m*2-1,u=1-x*2)}if(f&&f.length>0){let m=(d+1)/2,x=(1-u)/2;for(const A of f)if(m>=A.x&&m<=A.x+A.w&&x>=A.y&&x<=A.y+A.h){p=0,h=0,g=0,w=1;break}}s?(a[i*8]=d,a[i*8+1]=u,a[i*8+3]=p,a[i*8+4]=h,a[i*8+5]=g,a[i*8+6]=w):(a[i].x=d,a[i].y=u,a[i].r=p,a[i].g=h,a[i].b=g,a[i].blanking=w>.5)}return{...o,points:a,isTypedArray:s}}class ee{constructor(e,f){if(this.canvas=e,this.type=f,this.gl=e.getContext("webgl")||e.getContext("experimental-webgl"),this.animationFrameId=null,this.frameIndexes=Array(10).fill(0),this.pointIndexes=Array(10).fill(0),this.showBeamEffect=!1,this.beamAlpha=.5,this.fadeAlpha=.13,this.beamRenderMode="lines",this.positionBuffer=null,this.colorBuffer=null,this.alphaBuffer=null,this.lastPointDrawTime=0,!this.gl){console.error("WebGL not supported");return}this.setup()}setup(){const e=this.gl,f=`
      attribute vec2 aPosition;
      attribute vec3 aColor;
      attribute float aAlpha;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        gl_PointSize = 2.0;
        vColor = aColor;
        vAlpha = aAlpha;
      }
    `,n=`
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(vColor, vAlpha);
      }
    `,r=this.createShader(e.VERTEX_SHADER,f),t=this.createShader(e.FRAGMENT_SHADER,n),l=this.createProgram(r,t);this.program=l,this.positionAttributeLocation=e.getAttribLocation(l,"aPosition"),this.colorAttributeLocation=e.getAttribLocation(l,"aColor"),this.alphaAttributeLocation=e.getAttribLocation(l,"aAlpha"),this.quadPositionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer);const s=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(s),e.STATIC_DRAW),this.quadColorUniformLocation=e.getUniformLocation(l,"uColor"),this.quadAlphaUniformLocation=e.getUniformLocation(l,"uAlpha");const c=`
      attribute vec2 aPosition;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `,a=`
      precision mediump float;
      uniform vec4 uColor;
      void main() {
        gl_FragColor = uColor;
      }
    `,i=this.createShader(e.VERTEX_SHADER,c),d=this.createShader(e.FRAGMENT_SHADER,a);this.fadeProgram=this.createProgram(i,d),this.fadePositionAttributeLocation=e.getAttribLocation(this.fadeProgram,"aPosition"),this.fadeColorUniformLocation=e.getUniformLocation(this.fadeProgram,"uColor"),e.useProgram(l);const u=131072;this.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.bufferData(e.ARRAY_BUFFER,u*2*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.colorBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.colorBuffer),e.bufferData(e.ARRAY_BUFFER,u*3*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.alphaBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.alphaBuffer),e.bufferData(e.ARRAY_BUFFER,u*1*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA)}reset(){this.frameIndexes.fill(0),this.pointIndexes.fill(0),this.clearCanvas()}createShader(e,f){const n=this.gl,r=n.createShader(e);if(n.shaderSource(r,f),n.compileShader(r),n.getShaderParameter(r,n.COMPILE_STATUS))return r;console.error(n.getShaderInfoLog(r)),n.deleteShader(r)}createProgram(e,f){const n=this.gl,r=n.createProgram();if(n.attachShader(r,e),n.attachShader(r,f),n.linkProgram(r),n.getProgramParameter(r,n.LINK_STATUS))return r;console.error(n.getProgramInfoLog(r)),n.deleteProgram(r)}render(e){e.showBeamEffect!==void 0&&this.setBeamEffect(e.showBeamEffect),e.beamAlpha!==void 0&&this.setBeamAlpha(e.beamAlpha),e.fadeAlpha!==void 0&&this.setFadeAlpha(e.fadeAlpha),e.beamRenderMode!==void 0&&(this.beamRenderMode=e.beamRenderMode),this.type==="world"?this.renderWorld(e.worldData,e.previewScanRate,e.layerIntensities,e.masterIntensity,e.dacSettings):this.renderSingle(e.ildaFrames,e.previewScanRate,e.intensity,e.effects,e.syncSettings)}renderSingle(e,f,n,r,t={}){const l=this.gl;if(l.viewport(0,0,l.canvas.width,l.canvas.height),this.drawFadeQuad(),!e||e.length===0)return;const s=this.frameIndexes[0]%e.length,c=e[s],a=s/e.length,i=performance.now();this.draw(c,r,this.showBeamEffect,this.beamAlpha,f,this.beamRenderMode,n,0,a,i,t),this.frameIndexes[0]++,this.frameIndexes[0]>=e.length&&(this.frameIndexes[0]=0)}renderWorld(e,f,n,r,t){const l=this.gl;l.viewport(0,0,l.canvas.width,l.canvas.height),this.drawFadeQuad();const s=performance.now();e.forEach(c=>{if(c&&c.frames&&c.frames.length>0){const a=c.frames[0];if(a){const i=c.layerIndex||0,d=c.syncSettings||{};if(i>=this.frameIndexes.length){const h=i+5;for(;this.frameIndexes.length<h;)this.frameIndexes.push(0),this.pointIndexes.push(0)}const p=(n[i]!==void 0?n[i]:1)*r;if(p>.001){const h=this.frameIndexes[i]%c.frames.length/c.frames.length;let g=a;if(t){let w=a;if(t.dimmer!==void 0&&t.dimmer<1){const m=a.points,x=a.isTypedArray||m instanceof Float32Array,A=x?m.length/8:m.length,F=x?new Float32Array(m):m.map(B=>({...B}));for(let B=0;B<A;B++)x?(F[B*8+3]*=t.dimmer,F[B*8+4]*=t.dimmer,F[B*8+5]*=t.dimmer):(F[B].r*=t.dimmer,F[B].g*=t.dimmer,F[B].b*=t.dimmer);w={...a,points:F,isTypedArray:x}}g=J(w,t)}this.draw(g,c.effects,this.showBeamEffect,this.beamAlpha,f,this.beamRenderMode,p,i,h,s,d)}}}}),e.forEach(c=>{if(c&&c.frames){const a=c.layerIndex||0;this.frameIndexes[a]++,this.frameIndexes[a]>=c.frames.length&&(this.frameIndexes[a]=0)}})}drawFadeQuad(){const e=this.gl;this.fadeProgram&&(e.useProgram(this.fadeProgram),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer),e.enableVertexAttribArray(this.fadePositionAttributeLocation),e.vertexAttribPointer(this.fadePositionAttributeLocation,2,e.FLOAT,!1,0,0),e.uniform4f(this.fadeColorUniformLocation,0,0,0,this.fadeAlpha),e.drawArrays(e.TRIANGLES,0,6))}setBeamEffect(e){this.showBeamEffect=e}setBeamAlpha(e){this.beamAlpha=e}setFadeAlpha(e){this.fadeAlpha=e}draw(e,f,n,r,t,l,s=1,c=0,a=0,i=performance.now(),d={}){if(this.gl,!e||!e.points)return;const u=(f||[]).map(R=>{const S={...R.params},b=_.find(y=>y.id===R.id);return b&&b.paramControls.forEach(y=>{const E=`${R.id}.${y.id}`,v=d[E];if(v&&(y.type==="range"||y.type==="number")){let P=0;v==="fps"?P=i*.001%1:(v==="timeline"||v==="bpm")&&(P=a),S[y.id]=y.min+(y.max-y.min)*P}}),{...R,params:S}}),p=U(e,u,{progress:a,time:i}),h=p.points,g=p.isTypedArray,w=g?h.length/8:h.length;if(w===0)return;const m=Math.max(1,Math.floor(w/t));let x=this.pointIndexes[c]||0;x>=w&&(x=0);const A=R=>{const S=(x+R)%w;if(g){const b=S*8;return{x:h[b],y:h[b+1],r:h[b+3],g:h[b+4],b:h[b+5],blanking:h[b+6]===1}}else{const b=h[S];return{x:b.x,y:b.y,r:b.r,g:b.g,b:b.b,blanking:b.blanking}}},F=()=>{let R=[],S=[];for(let b=0;b<m;b++){const y=A(b);if(y.blanking){R.length>0&&(this._drawSegment(new Float32Array(R),new Float32Array(S),1,R.length/2),R=[],S=[]);continue}R.push(y.x,y.y),S.push(y.r/255*s,y.g/255*s,y.b/255*s)}R.length>0&&this._drawSegment(new Float32Array(R),new Float32Array(S),1,R.length/2)},B=()=>{const R=[],S=[];for(let b=0;b<m;b++){const y=A(b);if(!y.blanking){R.push(0,0,y.x,y.y);const E=[y.r/255*s,y.g/255*s,y.b/255*s];S.push(...E,...E)}}R.length>0&&this._drawLines(new Float32Array(R),new Float32Array(S),r,R.length/2)},L=()=>{const R=[],S=[];let b=A(0);for(let y=1;y<m;y++){const E=A(y);if(!b.blanking&&!E.blanking){R.push(0,0,b.x,b.y,E.x,E.y);const v=[b.r/255*s,b.g/255*s,b.b/255*s],P=[E.r/255*s,E.g/255*s,E.b/255*s],I=[(v[0]+P[0])/2,(v[1]+P[1])/2,(v[2]+P[2])/2];S.push(...I,...v,...P)}b=E}R.length>0&&this._drawTriangles(new Float32Array(R),new Float32Array(S),r,R.length/2)};F(),n&&(l==="points"?B():l==="lines"?L():l==="both"&&(L(),B())),this.pointIndexes[c]=(x+m)%w}_drawSegment(e,f,n,r){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,f),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const l=new Float32Array(Array(r).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,l),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINE_STRIP,0,r)}_drawLines(e,f,n,r){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,f),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const l=new Float32Array(Array(r).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,l),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINES,0,r)}_drawTriangles(e,f,n,r){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,f),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const l=new Float32Array(Array(r).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,l),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLES,0,r)}clearCanvas(){const e=this.gl;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT)}destroy(){cancelAnimationFrame(this.animationFrameId)}}const M=new Map;function k(o,e=0){const f=M.get(o);if(!f)return;const n=performance.now();f.renderer.render(f.data),e=n,f.animationFrameId=requestAnimationFrame(()=>k(o,e))}self.onmessage=o=>{const{action:e,payload:f}=o.data;if(e==="register"){const{id:n,canvas:r,type:t,data:l}=f,s=new ee(r,t),c=requestAnimationFrame(()=>k(n));M.set(n,{renderer:s,type:t,data:l,animationFrameId:c})}else if(e==="deregister"){const{id:n}=f,r=M.get(n);r&&(cancelAnimationFrame(r.animationFrameId),M.delete(n))}else if(e==="update"){const{id:n,data:r}=f,t=M.get(n);t&&(t.data=r)}else if(e==="clear"){const{id:n}=f,r=M.get(n);r&&r.renderer.clearCanvas()}}})();
