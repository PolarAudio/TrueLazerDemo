(function(){"use strict";const D=[{r:255,g:0,b:0},{r:0,g:255,b:0},{r:0,g:0,b:255},{r:255,g:255,b:0},{r:0,g:255,b:255},{r:255,g:0,b:255},{r:255,g:128,b:0},{r:128,g:255,b:0},{r:0,g:255,b:128},{r:0,g:128,b:255},{r:128,g:0,b:255},{r:255,g:0,b:128},{r:255,g:255,b:255},{r:128,g:128,b:128},{r:255,g:128,b:128},{r:128,g:255,b:128},{r:128,g:128,b:255},{r:255,g:255,b:128},{r:128,g:255,b:255},{r:255,g:128,b:255}],F=new Map;function S(i,s,u,w,c=D){const g=[],t=new DataView(i);let n=0;try{for(let m=0;m<w;m++){if(s===2){n+=u;continue}let M,h,e=0,a,d,p,o;s===0||s===4?(M=t.getInt16(n,!1)/32768,h=t.getInt16(n+2,!1)/32768,e=t.getInt16(n+4,!1)/32768,o=t.getUint8(n+6)):(M=t.getInt16(n,!1)/32768,h=t.getInt16(n+2,!1)/32768,o=t.getUint8(n+4));const l=(o&64)!==0,r=(o&128)!==0;if(l)a=0,d=0,p=0;else if(s===0||s===1){const b=t.getUint8(n+(s===0?7:5)),f=c||D,I=f[b%f.length]||D[0];a=I.r,d=I.g,p=I.b}else(s===4||s===5)&&(p=t.getUint8(n+(s===4?7:5)),d=t.getUint8(n+(s===4?8:6)),a=t.getUint8(n+(s===4?9:7)));if(g.push({x:M,y:h,z:e,r:a===void 0?255:a,g:d===void 0?255:d,b:p===void 0?255:p,blanking:l,lastPoint:r}),n+=u,r)break}}catch(m){console.warn("Parser: Error reading points:",m)}return g}function $(i){console.log("[ilda-parser.worker.js] parseIldaFile - Starting parsing.");const s=new DataView(i),u=[];let w=null,c=0,g=null;for(;c+32<=i.byteLength;){const t=c,n=String.fromCharCode(s.getUint8(t),s.getUint8(t+1),s.getUint8(t+2),s.getUint8(t+3));if(n!=="ILDA"){console.warn(`[ilda-parser.worker.js] Parser: Invalid ILDA signature at offset ${t}, got: ${n}. Skipping 32 bytes.`),c+=32;continue}const m=s.getUint8(t+7);if(w===null&&(w=m),m>5){console.warn(`[ilda-parser.worker.js] Parser: Unknown format code: ${m} at offset ${t}. Skipping 32 bytes.`),c+=32;continue}const M=String.fromCharCode(...new Uint8Array(i,t+8,8)).trim(),h=String.fromCharCode(...new Uint8Array(i,t+16,8)).trim();let e=s.getUint16(t+24,!1);const a=s.getUint16(t+26,!1),d=s.getUint16(t+28,!1),p=s.getUint8(t+30);let o;switch(m){case 0:o=8;break;case 1:o=6;break;case 2:o=4;break;case 4:o=10;break;case 5:o=8;break;default:console.warn(`Parser: Unsupported format ${m}, skipping 32 bytes.`),c+=32;continue}if(m===2){g=[];const f=c+32;for(let I=0;I<e;I++){const U=s.getUint8(f+I*4),x=s.getUint8(f+I*4+1),y=s.getUint8(f+I*4+2);g.push({r:U,g:x,b:y})}}let l=e*o,r=32+l;const b=i.byteLength-c;if(r<b){const f=b-r;f>0&&f<=32&&(console.warn(`Parser: Malformed frame, ${f} leftover bytes. Adjusting size.`),r+=f,l+=f,e=Math.floor(l/o))}if(t+r>i.byteLength){console.warn(`Parser: Incomplete frame data for ${e} points at offset ${t}. Expected ${r} bytes, but only ${i.byteLength-t} bytes remaining. Breaking.`);break}if(e===0){console.log("[ilda-parser.worker.js] Parser: Empty frame, skipping"),c+=r;continue}u.push({frameName:M,companyName:h,frameNumber:a,totalFrames:d,scannerHead:p,formatCode:m,recordSize:o,pointCount:e,pointDataOffset:t+32,pointDataSize:l,frameEndOffset:t+r,bounds:{minX:0,maxX:0,minY:0,maxY:0}}),c+=r}return console.log(`[ilda-parser.worker.js] parseIldaFile - Finished parsing. Found ${u.length} frames.`),{frames:u,error:u.length===0?"No valid frames found":null,firstFormatCode:w,ildaFileBuffer:i,colorPalette:g}}const P=new Map;self.onmessage=function(i){const{arrayBuffer:s,type:u,fileName:w,filePath:c,layerIndex:g,colIndex:t,workerId:n,frameIndex:m,isStillFrame:M,requestId:h}=i.data;if(u==="parse-ilda"){if(!s){self.postMessage({success:!1,error:"ArrayBuffer missing for parse-ilda command",type:"parse-ilda"});return}try{console.log("[ilda-parser.worker.js] Calling parseIldaFile for:",w);const e=$(s),a=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;F.set(a,{ildaFileBuffer:e.ildaFileBuffer,framesMetadata:e.frames,colorPalette:e.colorPalette}),console.log("[ilda-parser.worker.js] Posting success message for parse-ilda."),self.postMessage({success:!0,workerId:a,totalFrames:e.frames.length,ildaFormat:e.firstFormatCode,fileName:w,filePath:c,layerIndex:g,colIndex:t,type:"parse-ilda"}),self.postMessage({type:"parsing-status",status:!1,layerIndex:g,colIndex:t})}catch(e){console.error("[ilda-parser.worker.js] Error parsing file in onmessage handler:",e),self.postMessage({success:!1,error:e.message,type:"parse-ilda"}),self.postMessage({type:"parsing-status",status:!1,layerIndex:g,colIndex:t})}}else if(u==="load-and-parse-ilda"){const e=Math.random().toString(36).substring(2,15);P.set(e,{fileName:w,filePath:c,layerIndex:g,colIndex:t,browserFile:i.data.browserFile}),g!==void 0&&t!==void 0&&self.postMessage({type:"parsing-status",status:!0,layerIndex:g,colIndex:t}),self.postMessage({type:"request-file-content",filePath:c,requestId:e})}else if(u==="file-content-response"){const e=P.get(h);if(!e){console.error(`Worker: No context found for requestId: ${h}`);return}if(P.delete(h),i.data.error){console.error(`Worker: Error receiving file content: ${i.data.error}`),self.postMessage({success:!1,error:i.data.error,type:"parse-ilda",...e}),e.layerIndex!==void 0&&e.colIndex!==void 0&&self.postMessage({type:"parsing-status",status:!1,layerIndex:e.layerIndex,colIndex:e.colIndex});return}try{console.log(`[ilda-parser.worker.js] Calling parseIldaFile for: ${e.fileName} (from file-content-response)`);const a=$(s),d=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;F.set(d,{ildaFileBuffer:a.ildaFileBuffer,framesMetadata:a.frames,colorPalette:a.colorPalette}),self.postMessage({success:!0,workerId:d,totalFrames:a.frames.length,ildaFormat:a.firstFormatCode,type:"parse-ilda",...e}),e.layerIndex!==void 0&&e.colIndex!==void 0&&self.postMessage({type:"parsing-status",status:!1,layerIndex:e.layerIndex,colIndex:e.colIndex})}catch(a){console.error("[ilda-parser.worker.js] Error parsing file from content response:",a),self.postMessage({success:!1,error:a.message,type:"parse-ilda",...e}),e.layerIndex!==void 0&&e.colIndex!==void 0&&self.postMessage({type:"parsing-status",status:!1,layerIndex:e.layerIndex,colIndex:e.colIndex})}}else if(u==="get-frame"){const{workerId:e,frameIndex:a,isStillFrame:d,layerIndex:p,colIndex:o,browserFile:l,filePath:r}=i.data,b=F.get(e);if(!b){self.postMessage({success:!1,error:"ILDA data not found",type:"get-frame",workerId:e,browserFile:l,filePath:r,layerIndex:p,colIndex:o});return}const{ildaFileBuffer:f,framesMetadata:I,colorPalette:U}=b,x=Math.floor(a);if(!Number.isFinite(x)||x>=I.length||x<0){self.postMessage({success:!1,error:`Frame index ${a} out of bounds or invalid`,type:"get-frame",workerId:e,browserFile:l,filePath:r,layerIndex:p,colIndex:o});return}const y=I[x];if(!y){self.postMessage({success:!1,error:`Frame metadata not found for index ${x}`,type:"get-frame",workerId:e,browserFile:l,filePath:r,layerIndex:p,colIndex:o});return}let k=y.cachedPoints;if(!k){const z=f.slice(y.pointDataOffset,y.pointDataOffset+y.pointDataSize);k=S(z,y.formatCode,y.recordSize,y.pointCount,U),y.cachedPoints=k}const j={points:k};self.postMessage({success:!0,frame:j,type:"get-frame",workerId:e,frameIndex:a,isStillFrame:d,layerIndex:p,colIndex:o,browserFile:l,filePath:r})}else if(u==="get-all-frames"){const e=F.get(n);if(!e){self.postMessage({success:!1,error:"ILDA data not found",type:"get-all-frames",workerId:n});return}const{ildaFileBuffer:a,framesMetadata:d,colorPalette:p}=e,o=[];try{for(let l=0;l<d.length;l++){const r=d[l];let b=r.cachedPoints;if(!b){const f=a.slice(r.pointDataOffset,r.pointDataOffset+r.pointDataSize);b=S(f,r.formatCode,r.recordSize,r.pointCount,p),r.cachedPoints=b}o.push({...r,points:b})}self.postMessage({success:!0,frames:o,type:"get-all-frames",workerId:n,layerIndex:g,colIndex:t})}catch(l){self.postMessage({success:!1,error:l.message,type:"get-all-frames",workerId:n})}}}})();
