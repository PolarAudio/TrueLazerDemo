(function(){"use strict";const C=[{id:"rotate",name:"Rotate",type:"transform",description:"Rotates the shape around its center.",defaultParams:{angle:0,speed:0,direction:"CW"},paramControls:[{id:"angle",label:"Angle",type:"range",min:0,max:360,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["CW","CCW"]}]},{id:"scale",name:"Scale",type:"transform",description:"Scales the shape.",defaultParams:{scaleX:1,scaleY:1},paramControls:[{id:"scaleX",label:"Scale X",type:"range",min:.01,max:5,step:.01},{id:"scaleY",label:"Scale Y",type:"range",min:.01,max:5,step:.01}]},{id:"translate",name:"Translate",type:"transform",description:"Moves the shape.",defaultParams:{translateX:0,translateY:0},paramControls:[{id:"translateX",label:"Translate X",type:"range",min:-1,max:1,step:.01},{id:"translateY",label:"Translate Y",type:"range",min:-1,max:1,step:.01}]},{id:"color",name:"Color",type:"color",description:"Changes the color of the shape with solid or rainbow modes.",defaultParams:{mode:"solid",r:255,g:255,b:255,cycleSpeed:0,rainbowSpread:1,rainbowOffset:0,rainbowPalette:"rainbow"},paramControls:[{id:"mode",label:"Mode",type:"select",options:["solid","rainbow"]},{id:"r",label:"Red",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"g",label:"Green",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"b",label:"Blue",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"cycleSpeed",label:"Cycle Speed",type:"range",min:0,max:10,step:.1},{id:"rainbowSpread",label:"Rainbow Spread",type:"range",min:.1,max:10,step:.1,showIf:{mode:"rainbow"}},{id:"rainbowOffset",label:"Rainbow Offset",type:"range",min:0,max:360,step:1,showIf:{mode:"rainbow"}},{id:"rainbowPalette",label:"Palette",type:"select",options:["rainbow","fire","ice","cyber"],showIf:{mode:"rainbow"}}]},{id:"wave",name:"Wave",type:"animation",description:"Applies a wave distortion to the shape.",defaultParams:{amplitude:.1,frequency:10,speed:1,direction:"x"},paramControls:[{id:"amplitude",label:"Amplitude",type:"range",min:.01,max:1,step:.01},{id:"frequency",label:"Frequency",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["x","y"]}]},{id:"warp",name:"Warp",type:"animation",description:"Symmetrical chaotic wave distortion.",defaultParams:{amount:.1,chaos:.5,speed:1},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"chaos",label:"Chaos",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1}]},{id:"distortion",name:"Distortion",type:"transform",description:"Distorts the point data.",defaultParams:{amount:.1,scale:10,speed:.5},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"scale",label:"Scale",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:5,step:.1}]},{id:"move",name:"Move (Bounce)",type:"transform",description:"Moves points and bounces them off the borders.",defaultParams:{speedX:.1,speedY:.1},paramControls:[{id:"speedX",label:"Speed X",type:"range",min:0,max:2,step:.01},{id:"speedY",label:"Speed Y",type:"range",min:0,max:2,step:.01}]},{id:"delay",name:"Delay",type:"effect",description:"Channel-based delay effect.",defaultParams:{useCustomOrder:!1,delayDirection:"left_to_right",delayAmount:5,decay:.8,customOrder:[]},paramControls:[{id:"useCustomOrder",label:"Custom Order",type:"checkbox"},{id:"delayDirection",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}},{id:"delayAmount",label:"Delay Time",type:"range",min:1,max:60,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01}]},{id:"chase",name:"Chase",type:"effect",description:"Step-based chase effect.",defaultParams:{steps:4,decay:.8,speed:1,overlap:1,direction:"left_to_right",useCustomOrder:!1,customOrder:[]},paramControls:[{id:"steps",label:"Steps",type:"range",min:2,max:16,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:5,step:.1},{id:"overlap",label:"Overlap",type:"range",min:1,max:4,step:1},{id:"useCustomOrder",label:"Custom Order",type:"checkbox"},{id:"direction",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}}]},{id:"blanking",name:"Blanking",type:"animation",description:"Controls the blanking of the laser output.",defaultParams:{blankingInterval:0},paramControls:[{id:"blankingInterval",label:"Blanking Interval",type:"range",min:0,max:10,step:1}]},{id:"strobe",name:"Strobe",type:"animation",description:"Applies a strobe effect to the laser output.",defaultParams:{strobeSpeed:100,strobeAmount:.5},paramControls:[{id:"strobeSpeed",label:"Strobe Speed (ms)",type:"range",min:10,max:1e3,step:10},{id:"strobeAmount",label:"Strobe Amount (0-1)",type:"range",min:0,max:1,step:.01}]},{id:"mirror",name:"Mirror",type:"transform",description:"Mirrors the shape from the center.",defaultParams:{mode:"none"},paramControls:[{id:"mode",label:"Mirror Mode",type:"select",options:["none","x+","x-","y+","y-"]}]}],M=(a,e)=>({...e,...a});function H(a,e,d={}){const{progress:o=0,time:n=performance.now(),effectStates:t,syncSettings:c={}}=d;if(!e||e.length===0)return a;let s;if(Array.isArray(a.points)){s=new Float32Array(a.points.length*8);for(let h=0;h<a.points.length;h++){const f=a.points[h],l=h*8;s[l]=f.x,s[l+1]=f.y,s[l+2]=f.z||0,s[l+3]=f.r,s[l+4]=f.g,s[l+5]=f.b,s[l+6]=f.blanking?1:0,s[l+7]=f.lastPoint?1:0}}else s=new Float32Array(a.points);let r=s;const i=()=>r.length/8;for(const h of e){if(!C.find(m=>m.id===h.id))continue;const l={...h.params};switch(h.id){case"rotate":Q(r,i(),l,o,n);break;case"scale":K(r,i(),l);break;case"translate":Z(r,i(),l);break;case"color":$(r,i(),l,n);break;case"wave":J(r,i(),l,n);break;case"blanking":ee(r,i(),l);break;case"strobe":te(r,i(),l,n);break;case"mirror":r=re(r,i(),l);break;case"warp":ae(r,i(),l,n);break;case"distortion":oe(r,i(),l,n);break;case"move":ne(r,i(),l,n);break;case"delay":t&&h.instanceId&&(r=se(r,i(),l,t,h.instanceId,d));break;case"chase":r=ie(r,i(),l,n,d);break}}return{...a,points:r,isTypedArray:!0}}function Q(a,e,d,o,n){const{angle:t,speed:c,direction:s}=M(d,C.find(m=>m.id==="rotate").defaultParams),r=s==="CCW"?-1:1,i=n*.001*c*r,h=t*Math.PI/180+i,f=Math.sin(h),l=Math.cos(h);for(let m=0;m<e;m++){const u=m*8,w=a[u],S=a[u+1];a[u]=w*l-S*f,a[u+1]=w*f+S*l}}function K(a,e,d){const{scaleX:o,scaleY:n}=M(d,C.find(t=>t.id==="scale").defaultParams);for(let t=0;t<e;t++){const c=t*8;a[c]*=o,a[c+1]*=n}}function Z(a,e,d){const{translateX:o,translateY:n}=M(d,C.find(t=>t.id==="translate").defaultParams);for(let t=0;t<e;t++){const c=t*8;a[c]+=o,a[c+1]+=n}}function $(a,e,d,o){const{mode:n,r:t,g:c,b:s,cycleSpeed:r,rainbowSpread:i,rainbowOffset:h,rainbowPalette:f}=M(d,C.find(m=>m.id==="color").defaultParams),l=o*.001*r;if(n==="rainbow"){const m=f||"rainbow";for(let u=0;u<e;u++){const w=u*8,S=(u/e*i+l*.5+h/360)%1;let F,x,v;m==="rainbow"?[F,x,v]=O(S,1,.5):[F,x,v]=j(m,S),a[w+3]=F,a[w+4]=x,a[w+5]=v}}else if(r>0){const m=l*50%360,[u,w,S]=O(m/360,1,.5);for(let F=0;F<e;F++){const x=F*8;a[x+3]=u,a[x+4]=w,a[x+5]=S}}else for(let m=0;m<e;m++){const u=m*8;a[u+3]=t,a[u+4]=c,a[u+5]=s}}function j(a,e){const d={fire:[{r:255,g:0,b:0},{r:255,g:128,b:0},{r:255,g:255,b:0},{r:255,g:0,b:0}],ice:[{r:0,g:0,b:255},{r:0,g:255,b:255},{r:255,g:255,b:255},{r:0,g:0,b:255}],cyber:[{r:255,g:0,b:255},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:255,g:0,b:255}]},o=d[a]||d.fire,n=e*(o.length-1),t=Math.floor(n),c=n-t,s=o[t],r=o[t+1]||o[t];return[Math.round(s.r+(r.r-s.r)*c),Math.round(s.g+(r.g-s.g)*c),Math.round(s.b+(r.b-s.b)*c)]}function O(a,e,d){let o,n,t;{const c=(i,h,f)=>(f<0&&(f+=1),f>1&&(f-=1),f<.16666666666666666?i+(h-i)*6*f:f<.5?h:f<.6666666666666666?i+(h-i)*(.6666666666666666-f)*6:i),s=d+e-d*e,r=2*d-s;o=c(r,s,a+1/3),n=c(r,s,a),t=c(r,s,a-1/3)}return[Math.round(o*255),Math.round(n*255),Math.round(t*255)]}function J(a,e,d,o){const{amplitude:n,frequency:t,speed:c,direction:s}=M(d,C.find(i=>i.id==="wave").defaultParams),r=o*.001*c;for(let i=0;i<e;i++){const h=i*8;s==="x"?a[h+1]+=n*Math.sin(a[h]*t+r):s==="y"&&(a[h]+=n*Math.sin(a[h+1]*t+r))}}function ee(a,e,d){const{blankingInterval:o}=M(d,C.find(n=>n.id==="blanking").defaultParams);if(!(o<=0))for(let n=0;n<e;n++)n%(o+1)===o&&(a[n*8+6]=1)}function te(a,e,d,o){const{strobeSpeed:n,strobeAmount:t}=M(d,C.find(s=>s.id==="strobe").defaultParams);if(o%n/n<t)for(let s=0;s<e;s++)a[s*8+6]=1}function re(a,e,d){const{mode:o}=M(d,C.find(r=>r.id==="mirror").defaultParams);if(o==="none")return a;let n=[];for(let r=0;r<e;r++){const i=r*8,h=a[i],f=a[i+1];let l=!1;o==="x-"?h<=0&&(l=!0):o==="x+"?h>=0&&(l=!0):o==="y-"?f<=0&&(l=!0):o==="y+"&&f>=0&&(l=!0),l&&n.push({x:a[i],y:a[i+1],z:a[i+2],r:a[i+3],g:a[i+4],b:a[i+5],blk:a[i+6],last:a[i+7]})}const t=n.length*2,c=new Float32Array(t*8);let s=0;for(const r of n)c[s++]=r.x,c[s++]=r.y,c[s++]=r.z,c[s++]=r.r,c[s++]=r.g,c[s++]=r.b,c[s++]=r.blk,c[s++]=r.last;for(const r of n)o==="x-"||o==="x+"?c[s++]=-r.x:c[s++]=r.x,o==="y-"||o==="y+"?c[s++]=-r.y:c[s++]=r.y,c[s++]=r.z,c[s++]=r.r,c[s++]=r.g,c[s++]=r.b,c[s++]=r.blk,c[s++]=r.last;return c}function ae(a,e,d,o){const{amount:n,chaos:t,speed:c}=M(d,C.find(r=>r.id==="warp").defaultParams),s=o*.001*c;for(let r=0;r<e;r++){const i=r*8,h=a[i],f=a[i+1],l=Math.abs(f);a[i]+=Math.sin(l*10*(1+t)+s)*n*Math.cos(s*t),a[i+1]+=Math.cos(Math.abs(h)*10*(1+t)+s)*n*Math.sin(s*t)}}function oe(a,e,d,o){const{amount:n,scale:t,speed:c}=M(d,C.find(r=>r.id==="distortion").defaultParams),s=o*.001*c;for(let r=0;r<e;r++){const i=r*8,h=Math.sin(a[i]*t+s)*Math.cos(a[i+1]*t-s),f=Math.cos(a[i]*t-s)*Math.sin(a[i+1]*t+s);a[i]+=h*n,a[i+1]+=f*n}}function ne(a,e,d,o){const{speedX:n,speedY:t}=M(d,C.find(h=>h.id==="move").defaultParams),c=o*.001,s=c*n,r=c*t,i=4;for(let h=0;h<e;h++){const f=h*8;let l=a[f]+s,m=a[f+1]+r,u=(l+1)%i;u<0&&(u+=i),u>2&&(u=4-u),l=u-1;let w=(m+1)%i;w<0&&(w+=i),w>2&&(w=4-w),m=w-1,a[f]=l,a[f+1]=m}}function se(a,e,d,o,n,t){const c=C.find(p=>p.id==="delay").defaultParams,{delayAmount:s,decay:r,useCustomOrder:i,delayDirection:h,customOrder:f}=M(d,c),l=i||d.delayMode==="channel"||d.delayMode===!0;o.has(n)||o.set(n,[]);const m=o.get(n),u=new Float32Array(a);m.unshift(u);const{assignedDacs:w}=t||{};let S=new Map,F=0;if(l){let p=[];f&&Array.isArray(f)&&f.length>0?p=f.map(y=>y.originalIndex!==void 0?y.originalIndex:0):w?p=w.map((y,b)=>b):p=[0],p.forEach((y,b)=>{S.set(y,b),F=Math.max(F,b)})}else{const y=(w||[]).length||1;for(let b=0;b<y;b++){let _=0;h==="right_to_left"?_=y-1-b:h==="center_to_out"?_=Math.floor(Math.abs(b-(y-1)/2)):h==="out_to_center"?_=Math.min(b,y-1-b):_=b,S.set(b,_),F=Math.max(F,_)}y===0&&S.set(0,0)}const x=F+1,v=s*x+1;m.length>v&&(m.length=v);const P=[];for(let p=0;p<x;p++){const y=p*s;let b=null;y===0?b=a:y<m.length&&(b=m[y]);const _=Math.pow(r,p);P.push({points:b,factor:_,index:p})}if(P.length===0)return a;const B=e+P.reduce((p,y)=>p+(y.points?y.points.length/8:a.length/8),0),E=new Float32Array(B*8);let g=0;const R=new Array(P.length);for(let p=0;p<P.length;p++){const y=P[p],b=y.points,_=b?b.length/8:a.length/8,D=y.factor;R[p]=g;for(let Y=0;Y<_;Y++){const I=Y*8,L=g+Y*8;let N=0,X=0,W=0,V=0,q=0,G=0,k=1,z=0;b?(N=b[I],X=b[I+1],W=b[I+2],V=b[I+3],q=b[I+4],G=b[I+5],k=b[I+6],z=b[I+7]):k=1,E[L]=N,E[L+1]=X,E[L+2]=W,E[L+3]=V*D,E[L+4]=q*D,E[L+5]=G*D,E[L+6]=k,E[L+7]=z}g+=_*8}const A=new Map;return S.forEach((p,y)=>{if(p<P.length){const b=R[p],_=P[p].points?P[p].points.length:a.length;A.set(y,{start:b,length:_})}}),E._channelDistributions=A,E}function ie(a,e,d,o,n={}){e=Math.floor(e);const{decay:t,speed:c,overlap:s,direction:r,useCustomOrder:i,customOrder:h}=M(d,C.find(E=>E.id==="chase").defaultParams),{assignedDacs:f}=n||{};let l=new Map,m=0;if(i){let E=[];h&&Array.isArray(h)&&h.length>0?E=h.map(g=>g.originalIndex!==void 0?g.originalIndex:0):f?E=f.map((g,R)=>R):E=[0],E.forEach((g,R)=>{l.set(g,R),m++})}else{m=(f||[]).length||1;for(let g=0;g<m;g++){let R=g;r==="right_to_left"?R=m-1-g:r==="center_to_out"?R=Math.floor(Math.abs(g-(m-1)/2)):r==="out_to_center"&&(R=Math.min(g,m-1-g)),l.set(g,R)}}m===0&&(m=1);const u=m,w=o*.001*c%u,F=e*m,x=new Float32Array(F*8),v=new Map;let P=0;const B=Array.from(l.keys());B.length===0&&B.push(0);for(const E of B){const g=l.get(E)||0;let R=Math.abs(w-g);R>u/2&&(R=u-R);let A=0;R<s&&(A=1-R/s,A=Math.max(0,A),t>0&&(A=Math.pow(A,1-t)));const p=P;for(let y=0;y<e;y++){const b=y*8,_=P+y*8;x[_]=a[b],x[_+1]=a[b+1],x[_+2]=a[b+2]||0,x[_+3]=a[b+3]*A,x[_+4]=a[b+4]*A,x[_+5]=a[b+5]*A,x[_+6]=A<.05?1:a[b+6],x[_+7]=a[b+7]}v.set(E,{start:p,length:e}),P+=e*8}return x._channelDistributions=v,x}function le(a,e){if(!e||!a||!a.points)return a;const{safetyZones:d,outputArea:o,transformationEnabled:n,transformationMode:t,flipX:c,flipY:s}=e;let r=a.points;const i=a.isTypedArray||r instanceof Float32Array,h=i?r.length/8:r.length;let f;i?f=new Float32Array(r):f=r.map(l=>({...l}));for(let l=0;l<h;l++){let m,u,w,S,F,x;if(i?(m=f[l*8],u=f[l*8+1],w=f[l*8+3],S=f[l*8+4],F=f[l*8+5],x=f[l*8+6]):(m=f[l].x,u=f[l].y,w=f[l].r,S=f[l].g,F=f[l].b,x=f[l].blanking?1:0),c&&(m=-m),s&&(u=-u),n&&o){let v=(m+1)/2,P=(1-u)/2;t==="crop"?(v<o.x||v>o.x+o.w||P<o.y||P>o.y+o.h)&&(w=0,S=0,F=0,x=1):t==="scale"&&(v=o.x+v*o.w,P=o.y+P*o.h,m=v*2-1,u=1-P*2)}if(d&&d.length>0){let v=(m+1)/2,P=(1-u)/2;for(const B of d)if(v>=B.x&&v<=B.x+B.w&&P>=B.y&&P<=B.y+B.h){w=0,S=0,F=0,x=1;break}}i?(f[l*8]=m,f[l*8+1]=u,f[l*8+3]=w,f[l*8+4]=S,f[l*8+5]=F,f[l*8+6]=x):(f[l].x=m,f[l].y=u,f[l].r=w,f[l].g=S,f[l].b=F,f[l].blanking=x>.5)}return{...a,points:f,isTypedArray:i}}class ce{constructor(e,d){if(this.canvas=e,this.type=d,this.gl=e.getContext("webgl")||e.getContext("experimental-webgl"),this.animationFrameId=null,this.frameIndexes=Array(10).fill(0),this.pointIndexes=Array(10).fill(0),this.showBeamEffect=!1,this.beamAlpha=.5,this.fadeAlpha=.13,this.beamRenderMode="lines",this.positionBuffer=null,this.colorBuffer=null,this.alphaBuffer=null,this.lastPointDrawTime=0,!this.gl){console.error("WebGL not supported");return}this.setup()}setup(){const e=this.gl,d=`
      attribute vec2 aPosition;
      attribute vec3 aColor;
      attribute float aAlpha;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        gl_PointSize = 2.0;
        vColor = aColor;
        vAlpha = aAlpha;
      }
    `,o=`
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(vColor, vAlpha);
      }
    `,n=this.createShader(e.VERTEX_SHADER,d),t=this.createShader(e.FRAGMENT_SHADER,o),c=this.createProgram(n,t);this.program=c,this.positionAttributeLocation=e.getAttribLocation(c,"aPosition"),this.colorAttributeLocation=e.getAttribLocation(c,"aColor"),this.alphaAttributeLocation=e.getAttribLocation(c,"aAlpha"),this.quadPositionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer);const s=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(s),e.STATIC_DRAW),this.quadColorUniformLocation=e.getUniformLocation(c,"uColor"),this.quadAlphaUniformLocation=e.getUniformLocation(c,"uAlpha");const r=`
      attribute vec2 aPosition;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `,i=`
      precision mediump float;
      uniform vec4 uColor;
      void main() {
        gl_FragColor = uColor;
      }
    `,h=this.createShader(e.VERTEX_SHADER,r),f=this.createShader(e.FRAGMENT_SHADER,i);this.fadeProgram=this.createProgram(h,f),this.fadePositionAttributeLocation=e.getAttribLocation(this.fadeProgram,"aPosition"),this.fadeColorUniformLocation=e.getUniformLocation(this.fadeProgram,"uColor"),e.useProgram(c);const l=131072;this.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.bufferData(e.ARRAY_BUFFER,l*2*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.colorBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.colorBuffer),e.bufferData(e.ARRAY_BUFFER,l*3*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.alphaBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.alphaBuffer),e.bufferData(e.ARRAY_BUFFER,l*1*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.clearColor(0,0,0,1)}reset(){this.frameIndexes.fill(0),this.pointIndexes.fill(0),this.clearCanvas()}createShader(e,d){const o=this.gl,n=o.createShader(e);if(o.shaderSource(n,d),o.compileShader(n),o.getShaderParameter(n,o.COMPILE_STATUS))return n;console.error(o.getShaderInfoLog(n)),o.deleteShader(n)}createProgram(e,d){const o=this.gl,n=o.createProgram();if(o.attachShader(n,e),o.attachShader(n,d),o.linkProgram(n),o.getProgramParameter(n,o.LINK_STATUS))return n;console.error(o.getProgramInfoLog(n)),o.deleteProgram(n)}render(e){e.showBeamEffect!==void 0&&this.setBeamEffect(e.showBeamEffect),e.beamAlpha!==void 0&&this.setBeamAlpha(e.beamAlpha),e.fadeAlpha!==void 0&&this.setFadeAlpha(e.fadeAlpha),e.beamRenderMode!==void 0&&(this.beamRenderMode=e.beamRenderMode),this.type==="world"?this.renderWorld(e.worldData,e.previewScanRate,e.layerIntensities,e.masterIntensity,e.dacSettings):this.renderSingle(e.ildaFrames,e.previewScanRate,e.intensity,e.effects,e.syncSettings)}renderSingle(e,d,o,n,t={}){const c=this.gl;if(c.viewport(0,0,c.canvas.width,c.canvas.height),this.drawFadeQuad(),!e||e.length===0)return;const s=this.frameIndexes[0]%e.length,r=e[s],i=s/e.length,h=performance.now();this.draw(r,n,this.showBeamEffect,this.beamAlpha,d,this.beamRenderMode,o,0,i,h,t),this.frameIndexes[0]++,this.frameIndexes[0]>=e.length&&(this.frameIndexes[0]=0)}renderWorld(e,d,o,n,t){const c=this.gl;c.viewport(0,0,c.canvas.width,c.canvas.height),this.drawFadeQuad();const s=performance.now();e.forEach(r=>{if(r&&r.frames&&r.frames.length>0){const i=r.frames[0];if(i){const h=r.layerIndex||0,f=r.syncSettings||{};if(h>=this.frameIndexes.length){const u=h+5;for(;this.frameIndexes.length<u;)this.frameIndexes.push(0),this.pointIndexes.push(0)}const m=(o[h]!==void 0?o[h]:1)*n;if(m>.001){const u=this.frameIndexes[h]%r.frames.length/r.frames.length;let w=i;if(t){let S=i;if(t.dimmer!==void 0&&t.dimmer<1){const F=i.points,x=i.isTypedArray||F instanceof Float32Array,v=x?F.length/8:F.length,P=x?new Float32Array(F):F.map(B=>({...B}));for(let B=0;B<v;B++)x?(P[B*8+3]*=t.dimmer,P[B*8+4]*=t.dimmer,P[B*8+5]*=t.dimmer):(P[B].r*=t.dimmer,P[B].g*=t.dimmer,P[B].b*=t.dimmer);S={...i,points:P,isTypedArray:x}}w=le(S,t)}this.draw(w,r.effects,this.showBeamEffect,this.beamAlpha,d,this.beamRenderMode,m,h,u,s,f)}}}}),e.forEach(r=>{if(r&&r.frames){const i=r.layerIndex||0;this.frameIndexes[i]++,this.frameIndexes[i]>=r.frames.length&&(this.frameIndexes[i]=0)}})}drawFadeQuad(){const e=this.gl;this.fadeProgram&&(e.useProgram(this.fadeProgram),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer),e.enableVertexAttribArray(this.fadePositionAttributeLocation),e.vertexAttribPointer(this.fadePositionAttributeLocation,2,e.FLOAT,!1,0,0),e.uniform4f(this.fadeColorUniformLocation,0,0,0,this.fadeAlpha),e.drawArrays(e.TRIANGLES,0,6))}setBeamEffect(e){this.showBeamEffect=e}setBeamAlpha(e){this.beamAlpha=e}setFadeAlpha(e){this.fadeAlpha=e}draw(e,d,o,n,t,c,s=1,r=0,i=0,h=performance.now(),f={}){if(this.gl,!e||!e.points)return;const l=(d||[]).map(g=>{const R={...g.params},A=C.find(p=>p.id===g.id);return A&&A.paramControls.forEach(p=>{const y=`${g.id}.${p.id}`,b=f[y];if(b&&(p.type==="range"||p.type==="number")){let _=0;b==="fps"?_=h*.001%1:(b==="timeline"||b==="bpm")&&(_=i),R[p.id]=p.min+(p.max-p.min)*_}}),{...g,params:R}}),m=H(e,l,{progress:i,time:h}),u=m.points,w=m.isTypedArray,S=w?u.length/8:u.length;if(S===0)return;const F=Math.max(1,Math.floor(S/t));let x=this.pointIndexes[r]||0;x>=S&&(x=0);const v=g=>{const R=(x+g)%S;if(w){const A=R*8;return{x:u[A],y:u[A+1],r:u[A+3],g:u[A+4],b:u[A+5],blanking:u[A+6]===1}}else{const A=u[R];return{x:A.x,y:A.y,r:A.r,g:A.g,b:A.b,blanking:A.blanking}}},P=()=>{let g=[],R=[];for(let A=0;A<F;A++){const p=v(A);if(p.blanking){g.length>0&&(this._drawSegment(new Float32Array(g),new Float32Array(R),1,g.length/2),g=[],R=[]);continue}g.push(p.x,p.y),R.push(p.r/255*s,p.g/255*s,p.b/255*s)}g.length>0&&this._drawSegment(new Float32Array(g),new Float32Array(R),1,g.length/2)},B=()=>{const g=[],R=[];for(let A=0;A<F;A++){const p=v(A);if(!p.blanking){g.push(0,0,p.x,p.y);const y=[p.r/255*s,p.g/255*s,p.b/255*s];R.push(...y,...y)}}g.length>0&&this._drawLines(new Float32Array(g),new Float32Array(R),n,g.length/2)},E=()=>{const g=[],R=[];let A=v(0);for(let p=1;p<F;p++){const y=v(p);if(!A.blanking&&!y.blanking){g.push(0,0,A.x,A.y,y.x,y.y);const b=[A.r/255*s,A.g/255*s,A.b/255*s],_=[y.r/255*s,y.g/255*s,y.b/255*s],D=[(b[0]+_[0])/2,(b[1]+_[1])/2,(b[2]+_[2])/2];R.push(...D,...b,..._)}A=y}g.length>0&&this._drawTriangles(new Float32Array(g),new Float32Array(R),n,g.length/2)};P(),o&&(c==="points"?B():c==="lines"?E():c==="both"&&(E(),B())),this.pointIndexes[r]=(x+F)%S}_drawSegment(e,d,o,n){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,d),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(n).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINE_STRIP,0,n)}_drawLines(e,d,o,n){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,d),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(n).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINES,0,n)}_drawTriangles(e,d,o,n){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,d),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(n).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLES,0,n)}clearCanvas(){const e=this.gl;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT)}destroy(){cancelAnimationFrame(this.animationFrameId)}}const T=new Map;function U(a,e=0){const d=T.get(a);if(!d)return;const o=performance.now();d.renderer.render(d.data),e=o,d.animationFrameId=requestAnimationFrame(()=>U(a,e))}self.onmessage=a=>{const{action:e,payload:d}=a.data;if(e==="register"){const{id:o,canvas:n,type:t,data:c}=d,s=new ce(n,t),r=requestAnimationFrame(()=>U(o));T.set(o,{renderer:s,type:t,data:c,animationFrameId:r})}else if(e==="deregister"){const{id:o}=d,n=T.get(o);n&&(cancelAnimationFrame(n.animationFrameId),T.delete(o))}else if(e==="update"){const{id:o,data:n}=d,t=T.get(o);t&&(t.data=n)}else if(e==="clear"){const{id:o}=d,n=T.get(o);n&&n.renderer.clearCanvas()}}})();
