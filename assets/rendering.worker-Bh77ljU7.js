(function(){"use strict";const J=[{id:"rotate",name:"Rotate",type:"transform",description:"Rotates the shape around its center.",defaultParams:{angle:0,speed:0,direction:"CW"},paramControls:[{id:"angle",label:"Angle",type:"range",min:0,max:360,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["CW","CCW"]}]},{id:"scale",name:"Scale",type:"transform",description:"Scales the shape.",defaultParams:{scaleX:1,scaleY:1},paramControls:[{id:"scaleX",label:"Scale X",type:"range",min:.01,max:5,step:.01},{id:"scaleY",label:"Scale Y",type:"range",min:.01,max:5,step:.01}]},{id:"translate",name:"Translate",type:"transform",description:"Moves the shape.",defaultParams:{translateX:0,translateY:0},paramControls:[{id:"translateX",label:"Translate X",type:"range",min:-1,max:1,step:.01},{id:"translateY",label:"Translate Y",type:"range",min:-1,max:1,step:.01}]},{id:"color",name:"Color",type:"color",description:"Changes the color of the shape with solid, rainbow or custom palette modes.",defaultParams:{mode:"solid",color:"#ffffff",r:255,g:255,b:255,cycleSpeed:0,rainbowSpread:1,rainbowOffset:0,rainbowPalette:"rainbow",paletteColors:["#ff0000","#00ff00","#0000ff","#ffff00"],paletteSize:4,paletteSpread:1,hue:0,saturation:0,brightness:1,enabled:!0},paramControls:[{id:"mode",label:"Mode",type:"select",options:["solid","rainbow","palette"]},{id:"color",label:"Color",type:"color",showIf:{mode:"solid"}},{id:"hue",label:"Hue",type:"range",min:0,max:1,step:.001,showIf:{mode:"hsv_advanced"}},{id:"saturation",label:"Saturation",type:"range",min:0,max:1,step:.001,showIf:{mode:"hsv_advanced"}},{id:"brightness",label:"Brightness",type:"range",min:0,max:1,step:.001,showIf:{mode:"hsv_advanced"}},{id:"paletteSize",label:"Palette Size",type:"range",min:2,max:16,step:1,showIf:{mode:"palette"}},{id:"paletteSpread",label:"Spread",type:"range",min:.1,max:10,step:.1,showIf:{mode:"palette"}},{id:"cycleSpeed",label:"Cycle Speed",type:"range",min:0,max:10,step:.1,showIf:{mode:["rainbow","palette"]}},{id:"rainbowSpread",label:"Rainbow Spread",type:"range",min:.1,max:10,step:.1,showIf:{mode:"rainbow"}},{id:"rainbowOffset",label:"Offset",type:"range",min:0,max:360,step:1,showIf:{mode:["rainbow","palette"]}},{id:"rainbowPalette",label:"Preset",type:"select",options:["rainbow","fire","ice","cyber"],showIf:{mode:"rainbow"}}]},{id:"wave",name:"Wave",type:"animation",description:"Applies a wave distortion to the shape.",defaultParams:{amplitude:.1,frequency:10,speed:1,direction:"x"},paramControls:[{id:"amplitude",label:"Amplitude",type:"range",min:.01,max:1,step:.01},{id:"frequency",label:"Frequency",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["x","y"]}]},{id:"warp",name:"Warp",type:"animation",description:"Symmetrical chaotic wave distortion.",defaultParams:{amount:.1,chaos:.5,speed:1},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"chaos",label:"Chaos",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1}]},{id:"distortion",name:"Distortion",type:"transform",description:"Distorts the point data.",defaultParams:{amount:.1,scale:10,speed:.5},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"scale",label:"Scale",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:5,step:.1}]},{id:"move",name:"Move (Bounce)",type:"transform",description:"Moves points and bounces them off the borders.",defaultParams:{speedX:.1,speedY:.1},paramControls:[{id:"speedX",label:"Speed X",type:"range",min:0,max:2,step:.01},{id:"speedY",label:"Speed Y",type:"range",min:0,max:2,step:.01}]},{id:"delay",name:"Delay",type:"effect",description:"Frame or Channel based delay effect.",defaultParams:{mode:"frame",playstyle:"repeat",useCustomOrder:!1,delayDirection:"left_to_right",delayAmount:5,decay:.8,steps:10,customOrder:[],enabled:!0},paramControls:[{id:"mode",label:"Mode",type:"select",options:["frame","channel"]},{id:"playstyle",label:"Playstyle",type:"select",options:["once","repeat"]},{id:"useCustomOrder",label:"Custom Order",type:"checkbox",showIf:{mode:"channel"}},{id:"delayDirection",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}},{id:"steps",label:"Steps",type:"range",min:2,max:20,step:1,showIf:{mode:"frame"}},{id:"delayAmount",label:"Delay Time",type:"range",min:1,max:60,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01}]},{id:"chase",name:"Chase",type:"effect",description:"Frame or Channel based chase effect.",defaultParams:{mode:"frame",playstyle:"repeat",steps:4,decay:.8,speed:1,overlap:1,direction:"left_to_right",useCustomOrder:!1,customOrder:[],enabled:!0},paramControls:[{id:"mode",label:"Mode",type:"select",options:["frame","channel"]},{id:"playstyle",label:"Playstyle",type:"select",options:["once","repeat","bounce"]},{id:"steps",label:"Steps",type:"range",min:2,max:16,step:1,showIf:{mode:"frame"}},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:5,step:.1},{id:"overlap",label:"Overlap",type:"range",min:1,max:4,step:1},{id:"useCustomOrder",label:"Custom Order",type:"checkbox",showIf:{mode:"channel"}},{id:"direction",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}}]},{id:"blanking",name:"Blanking",type:"animation",description:"Controls the blanking of the laser output.",defaultParams:{blankingInterval:0,spacing:0},paramControls:[{id:"blankingInterval",label:"Blanking Interval",type:"range",min:0,max:10,step:1},{id:"spacing",label:"Spacing",type:"range",min:0,max:20,step:1}]},{id:"strobe",name:"Strobe",type:"animation",description:"Applies a strobe effect to the laser output.",defaultParams:{strobeSpeed:100,strobeAmount:.5},paramControls:[{id:"strobeSpeed",label:"Strobe Speed (ms)",type:"range",min:10,max:1e3,step:10},{id:"strobeAmount",label:"Strobe Amount (0-1)",type:"range",min:0,max:1,step:.01}]},{id:"mirror",name:"Mirror",type:"transform",description:"Mirrors the shape from the center.",defaultParams:{mode:"none"},paramControls:[{id:"mode",label:"Mirror Mode",type:"select",options:["none","x+","x-","y+","y-"]}]}].reduce((n,e)=>(n[e.id]=e,n),{});function X(n,e,c,i){const r=e.style||"loop",o=e.direction||"forward";if(o==="pause")return c;let a=n;r==="bounce"&&(a*=2);let l=0;if(r==="once")l=Math.min(a,1),o==="backward"&&(l=1-l);else if(r==="bounce"){let m=a%1;Math.floor(a)%2===1?l=1-m:l=m,o==="backward"&&(l=1-l)}else l=a%1,o==="backward"&&(l=1-l);return i&&Array.isArray(i)&&i.length===2?i[0]+(i[1]-i[0])*l:c}function $(n,e,c,i,r,o){if(!c)return e;const a=typeof c=="string"?{syncMode:c}:c;if(!a.syncMode)return e;const{time:l,progress:m=0,bpm:h=120,clipDuration:g=0,fftLevels:y={low:0,mid:0,high:0},activationTime:d=0}=i;let f=a.range;!f||!Array.isArray(f)||f.length;let s=0;const p=a.speedMultiplier||1;if((a.style||"loop")==="once"&&d>0){const M=(l-d)*.001;let F=1;if(a.syncMode==="timeline")F=Math.max(.01,a.duration||1);else if(a.syncMode==="bpm"){const D=Math.max(.1,a.beats||4),x=h/60;F=D/(x||2)}else if(a.syncMode==="fps")return s=M*p,X(s,a,e,f);s=M/F*p}else if(a.syncMode==="fps")s=l*.001*p;else if(a.syncMode==="timeline"){const M=Math.max(.01,a.duration||1);g>0?s=m*g/M*p:s=0}else if(a.syncMode==="bpm"){const M=Math.max(.1,a.beats||4),F=h/60,D=M/(F||2);g>0?s=m*g/D*p:s=0}else if(a.syncMode==="fft"){const M=y[a.fftRange||"low"]||0;return f?f[0]+(f[1]-f[0])*M:e}return X(s,a,e,f)}let N=new Float32Array(1024*8);function Q(n){N.length<n*8&&(N=new Float32Array(n*8*2))}function K(n,e,c={}){const{progress:i=0,time:r=performance.now(),effectStates:o,syncSettings:a={},fftLevels:l}=c;if(!e||e.length===0)return n;const m=n.points,h=n.isTypedArray||m instanceof Float32Array,g=h?m.length/8:m.length;Q(g);const y=N.subarray(0,g*8);if(h)y.set(m);else for(let s=0;s<g;s++){const p=m[s],w=s*8;y[w]=p.x,y[w+1]=p.y,y[w+2]=p.z||0,y[w+3]=p.r,y[w+4]=p.g,y[w+5]=p.b,y[w+6]=p.blanking?1:0,y[w+7]=p.lastPoint?1:0}let d=y;for(const s of e){const p=s.params;if(p.enabled===!1||!J[s.id])continue;const M=d.length/8;let F=p;const D=s.instanceId?`${s.instanceId}.`:`${s.id}.`;let x=!1;for(const u in p)if(a[D+u]){x=!0;break}if(x){F={...p};for(const u in F){const S=D+u;a[S]&&(F[u]=$(u,F[u],a[S],c))}}switch(s.id){case"rotate":Z(d,M,F,i,r);break;case"scale":j(d,M,F);break;case"translate":ee(d,M,F);break;case"color":ae(d,M,F,r);break;case"wave":oe(d,M,F,r);break;case"blanking":ne(d,M,F);break;case"strobe":se(d,M,F,r);break;case"mirror":d=ie(d,M,F);break;case"warp":le(d,M,F,r);break;case"distortion":fe(d,M,F,r);break;case"move":ce(d,M,F,r);break;case"delay":o&&s.instanceId&&(d=he(d,M,F,o,s.instanceId,c));break;case"chase":d=de(d,M,F,r,c);break}}const f=new Float32Array(d);return d._channelDistributions&&(f._channelDistributions=d._channelDistributions),{...n,points:f,isTypedArray:!0}}function Z(n,e,c,i,r){const{angle:o,speed:a,direction:l}=c,m=l==="CCW"?-1:1,h=r*.001*a*m,g=o*Math.PI/180+h,y=Math.sin(g),d=Math.cos(g);for(let f=0;f<e;f++){const s=f*8,p=n[s],w=n[s+1];n[s]=p*d-w*y,n[s+1]=p*y+w*d}}function j(n,e,c){const{scaleX:i,scaleY:r}=c;for(let o=0;o<e;o++){const a=o*8;n[a]*=i,n[a+1]*=r}}function ee(n,e,c){const{translateX:i,translateY:r}=c;for(let o=0;o<e;o++){const a=o*8;n[a]+=i,n[a+1]+=r}}function W(n){if(!n)return{r:255,g:255,b:255};const e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(n);return e?{r:parseInt(e[1],16),g:parseInt(e[2],16),b:parseInt(e[3],16)}:{r:255,g:255,b:255}}function te(n,e,c){let i,r,o;const a=Math.floor(n*6),l=n*6-a,m=c*(1-e),h=c*(1-l*e),g=c*(1-(1-l)*e);switch(a%6){case 0:i=c,r=g,o=m;break;case 1:i=h,r=c,o=m;break;case 2:i=m,r=c,o=g;break;case 3:i=m,r=h,o=c;break;case 4:i=g,r=m,o=c;break;case 5:i=c,r=m,o=h;break}return[Math.round(i*255),Math.round(r*255),Math.round(o*255)]}function ae(n,e,c,i){const{mode:r,r:o,g:a,b:l,color:m,hue:h,saturation:g,brightness:y,cycleSpeed:d,rainbowSpread:f,rainbowOffset:s,rainbowPalette:p,paletteColors:w=[],paletteSize:M=4,paletteSpread:F=1}=c,D=i*.001*d;if(r==="palette"){const x=Math.min(w.length,M),u=w.slice(0,x).map(W);u.length===0&&u.push({r:255,g:255,b:255});for(let S=0;S<e;S++){const b=S*8,I=(S/e*F+D*.5+s/360)%1*u.length,v=Math.floor(I)%u.length,P=(v+1)%u.length,_=I-Math.floor(I),B=u[v],A=u[P];n[b+3]=Math.round(B.r+(A.r-B.r)*_),n[b+4]=Math.round(B.g+(A.g-B.g)*_),n[b+5]=Math.round(B.b+(A.b-B.b)*_)}}else if(r==="rainbow"){const x=p||"rainbow";for(let u=0;u<e;u++){const S=u*8,b=(u/e*f+D*.5+s/360)%1;let R,I,v;x==="rainbow"?[R,I,v]=q(b,1,.5):[R,I,v]=re(x,b),n[S+3]=R,n[S+4]=I,n[S+5]=v}}else{let x=o,u=a,S=l;if(h!==void 0&&g!==void 0&&y!==void 0)[x,u,S]=te(h,g,y);else if(m){const b=W(m);x=b.r,u=b.g,S=b.b}if(d>0){const b=D*50%360,[R,I,v]=q(b/360,1,.5);for(let P=0;P<e;P++){const _=P*8;n[_+3]=R,n[_+4]=I,n[_+5]=v}}else for(let b=0;b<e;b++){const R=b*8;n[R+3]=x,n[R+4]=u,n[R+5]=S}}}function re(n,e){const c={fire:[{r:255,g:0,b:0},{r:255,g:128,b:0},{r:255,g:255,b:0},{r:255,g:0,b:0}],ice:[{r:0,g:0,b:255},{r:0,g:255,b:255},{r:255,g:255,b:255},{r:0,g:0,b:255}],cyber:[{r:255,g:0,b:255},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:255,g:0,b:255}]},i=c[n]||c.fire,r=e*(i.length-1),o=Math.floor(r),a=r-o,l=i[o],m=i[o+1]||i[o];return[Math.round(l.r+(m.r-l.r)*a),Math.round(l.g+(m.g-l.g)*a),Math.round(l.b+(m.b-l.b)*a)]}function q(n,e,c){let i,r,o;{const a=(h,g,y)=>(y<0&&(y+=1),y>1&&(y-=1),y<.16666666666666666?h+(g-h)*6*y:y<.5?g:y<.6666666666666666?h+(g-h)*(.6666666666666666-y)*6:h),l=c+e-c*e,m=2*c-l;i=a(m,l,n+1/3),r=a(m,l,n),o=a(m,l,n-1/3)}return[Math.round(i*255),Math.round(r*255),Math.round(o*255)]}function oe(n,e,c,i){const{amplitude:r,frequency:o,speed:a,direction:l}=c,m=i*.001*a;for(let h=0;h<e;h++){const g=h*8;l==="x"?n[g+1]+=r*Math.sin(n[g]*o+m):l==="y"&&(n[g]+=r*Math.sin(n[g+1]*o+m))}}function ne(n,e,c){const{blankingInterval:i,spacing:r=0}=c;if(i<=0)return;const o=i+1+r;for(let a=0;a<e;a++)a%o>=i&&(n[a*8+6]=1)}function se(n,e,c,i){const{strobeSpeed:r,strobeAmount:o}=c;if(i%r/r<o)for(let l=0;l<e;l++)n[l*8+6]=1}function ie(n,e,c){const{mode:i}=c;if(i==="none"||e===0)return n;let r;const o=n._channelDistributions;if(o){r=new Float32Array((e*2+o.size)*8);const a=new Map;let l=0;for(const[m,h]of o){const g=h.length/8,y=h.start,d=l;r.set(n.subarray(y,y+h.length),l),l+=h.length;const f=y+h.length-8;r.set(n.subarray(f,f+8),l),r[l+6]=1,r[l+3]=0,r[l+4]=0,r[l+5]=0,l+=8;for(let s=0;s<g;s++){const p=y+s*8,w=l;r.set(n.subarray(p,p+8),w),i==="x-"||i==="x+"?r[w]=-r[w]:(i==="y-"||i==="y+")&&(r[w+1]=-r[w+1]),l+=8}a.set(m,{start:d,length:(g*2+1)*8})}r._channelDistributions=a}else{r=new Float32Array((e*2+1)*8),r.set(n.subarray(0,e*8),0);const a=e*8,l=(e-1)*8;r.set(n.subarray(l,l+8),a),r[a+6]=1,r[a+3]=0,r[a+4]=0,r[a+5]=0;for(let m=0;m<e;m++){const h=m*8,g=(e+1+m)*8;r.set(n.subarray(h,h+8),g),i==="x-"||i==="x+"?r[g]=-r[g]:(i==="y-"||i==="y+")&&(r[g+1]=-r[g+1])}}return r}function le(n,e,c,i){const{amount:r,chaos:o,speed:a}=c,l=i*.001*a;for(let m=0;m<e;m++){const h=m*8,g=n[h],y=n[h+1],d=Math.abs(y);n[h]+=Math.sin(d*10*(1+o)+l)*r*Math.cos(l*o),n[h+1]+=Math.cos(Math.abs(g)*10*(1+o)+l)*r*Math.sin(l*o)}}function fe(n,e,c,i){const{amount:r,scale:o,speed:a}=c,l=i*.001*a;for(let m=0;m<e;m++){const h=m*8,g=Math.sin(n[h]*o+l)*Math.cos(n[h+1]*o-l),y=Math.cos(n[h]*o-l)*Math.sin(n[h+1]*o+l);n[h]+=g*r,n[h+1]+=y*r}}function ce(n,e,c,i){const{speedX:r,speedY:o}=c,a=i*.001,l=a*r,m=a*o,h=4;for(let g=0;g<e;g++){const y=g*8;let d=n[y]+l,f=n[y+1]+m,s=(d+1)%h;s<0&&(s+=h),s>2&&(s=4-s),d=s-1;let p=(f+1)%h;p<0&&(p+=h),p>2&&(p=4-p),f=p-1,n[y]=d,n[y+1]=f}}function he(n,e,c,i,r,o){const{mode:a="frame",delayAmount:l,decay:m,delayDirection:h,useCustomOrder:g,customOrder:y,playstyle:d="repeat",steps:f=10}=c;i.has(r)||i.set(r,[]);const s=i.get(r);if(s.unshift(new Float32Array(n)),a==="frame"){const p=l*f+1;s.length>p&&(s.length=p);const w=new Float32Array(n.length);for(let M=0;M<e;M++){let F=0;const D=M/e;h==="left_to_right"?F=Math.floor(D*(f-1)):h==="right_to_left"?F=Math.floor((1-D)*(f-1)):h==="center_to_out"?F=Math.floor(Math.abs(D-.5)*2*(f-1)):h==="out_to_center"&&(F=Math.floor((1-Math.abs(D-.5)*2)*(f-1)));const x=F*l,u=x<s.length?s[x]:null,S=Math.pow(m,F),b=M*8;if(u&&u.length>0){let R;if(u.length===n.length)R=b;else{const I=u.length/8;let v=Math.floor(D*I);v>=I&&(v=I-1),R=v*8}if(w[b]=u[R],w[b+1]=u[R+1],w[b+2]=u[R+2],w[b+3]=u[R+3]*S,w[b+4]=u[R+4]*S,w[b+5]=u[R+5]*S,w[b+6]=u[R+6],w[b+7]=u[R+7],M<e-1){const I=(M+1)/e;let v=0;h==="left_to_right"?v=Math.floor(I*(f-1)):h==="right_to_left"?v=Math.floor((1-I)*(f-1)):h==="center_to_out"?v=Math.floor(Math.abs(I-.5)*2*(f-1)):h==="out_to_center"&&(v=Math.floor((1-Math.abs(I-.5)*2)*(f-1))),v!==F&&(w[b+6]=1)}}else w.set(n.subarray(b,b+8),b),w[b+3]=0,w[b+4]=0,w[b+5]=0,w[b+6]=1}return n._channelDistributions&&(w._channelDistributions=n._channelDistributions),w}else{const{assignedDacs:p}=o||{};let w=new Map,M=0;if(g||c.delayMode==="channel")(y&&y.length>0?y.map(_=>_.originalIndex):p?p.map((_,B)=>B):[0]).forEach((_,B)=>{w.set(_,B),M=Math.max(M,B)});else{const _=(p||[]).length||1;for(let B=0;B<_;B++){let A=B;h==="right_to_left"?A=_-1-B:h==="center_to_out"?A=Math.floor(Math.abs(B-(_-1)/2)):h==="out_to_center"&&(A=Math.min(B,_-1-B)),w.set(B,A),M=Math.max(M,A)}}const D=M+1,x=l*D+1;s.length>x&&(s.length=x);const u=[];for(let P=0;P<D;P++){const _=P*l;u.push({points:_<s.length?s[_]:null,factor:Math.pow(m,P),index:P})}const S=u.reduce((P,_)=>P+(_.points?_.points.length/8:n.length/8),0),b=new Float32Array(S*8);let R=0;const I=new Array(u.length);for(let P=0;P<u.length;P++){const _=u[P],B=_.points,A=B?B.length/8:n.length/8;I[P]=R;for(let C=0;C<A;C++){const E=C*8,L=R+C*8;B?(b[L]=B[E],b[L+1]=B[E+1],b[L+2]=B[E+2],b[L+3]=B[E+3]*_.factor,b[L+4]=B[E+4]*_.factor,b[L+5]=B[E+5]*_.factor,b[L+6]=B[E+6],b[L+7]=B[E+7]):b[L+6]=1}R+=A*8}const v=new Map;return w.forEach((P,_)=>{P<u.length&&v.set(_,{start:I[P],length:u[P].points?u[P].points.length:n.length})}),b._channelDistributions=v,b}}function de(n,e,c,i,r={}){const{mode:o="frame",steps:a,decay:l,speed:m,overlap:h,direction:g,useCustomOrder:y,customOrder:d,playstyle:f="loop"}=c,{progress:s=0,clipDuration:p=1,syncSettings:w={}}=r,M=c.instanceId?`${c.instanceId}.`:"chase.",F=!!w[M+"speed"],D=s!==void 0&&p>0||F;if(o==="frame"){const x=a;let u=(D?s*x:i*.001)*m;if(f==="bounce"){const b=x,R=u%(b*2);u=R>b?b*2-R:R}else f==="once"?u=Math.min(u,x):u=u%x;const S=new Float32Array(n.length);for(let b=0;b<e;b++){const R=b/e;let I=0;g==="left_to_right"?I=Math.min(x-1,Math.floor(R*x)):g==="right_to_left"?I=Math.min(x-1,Math.floor((1-R)*x)):g==="center_to_out"?I=Math.min(x-1,Math.floor(Math.abs(R-.5)*2*x)):g==="out_to_center"&&(I=Math.min(x-1,Math.floor((1-Math.abs(R-.5)*2)*x)));let v=Math.abs(u-I);v>x/2&&(v=x-v);let P=v<h?1-v/h:0;l>0&&(P=Math.pow(P,1-l));const _=b*8;if(S.set(n.subarray(_,_+8),_),S[_+3]*=P,S[_+4]*=P,S[_+5]*=P,P<.05&&(S[_+6]=1),b<e-1){const B=(b+1)/e;let A=0;g==="left_to_right"?A=Math.min(x-1,Math.floor(B*x)):g==="right_to_left"?A=Math.min(x-1,Math.floor((1-B)*x)):g==="center_to_out"?A=Math.min(x-1,Math.floor(Math.abs(B-.5)*2*x)):g==="out_to_center"&&(A=Math.min(x-1,Math.floor((1-Math.abs(B-.5)*2)*x))),A!==I&&(S[_+6]=1)}}return n._channelDistributions&&(S._channelDistributions=n._channelDistributions),S}else{const{assignedDacs:x}=r||{};let u=new Map,S=0;if(y)(d&&d.length>0?d.map(C=>C.originalIndex):x?x.map((C,E)=>E):[0]).forEach((C,E)=>{u.set(C,E),S++});else{S=(x?x.length:1)||1;for(let A=0;A<S;A++){let C=A;g==="right_to_left"?C=S-1-A:g==="center_to_out"?C=Math.floor(Math.abs(A-(S-1)/2)):g==="out_to_center"&&(C=Math.min(A,S-1-A)),u.set(A,C)}}const b=S;let R=(D?s*b:i*.001)*m;if(f==="bounce"){const A=b,C=R%(A*2);R=C>A?A*2-C:C}else f==="once"?R=Math.min(R,b):R=R%b;const I=e*S,v=new Float32Array(I*8),P=new Map;let _=0;const B=Array.from(u.keys());B.length===0&&B.push(0);for(const A of B){const C=u.get(A)||0;let E=Math.abs(R-C);E>b/2&&(E=b-E);let L=E<h?1-E/h:0;l>0&&(L=Math.pow(L,1-l));const k=_;for(let U=0;U<e;U++){const T=U*8,O=_+U*8;v.set(n.subarray(T,T+8),O),v[O+3]*=L,v[O+4]*=L,v[O+5]*=L,L<.05&&(v[O+6]=1)}P.set(A,{start:k,length:e*8}),_+=e*8}return v._channelDistributions=P,v}}function pe(n,e,c=!1){if(!e||!n||!n.points)return n;const{safetyZones:i,outputArea:r,transformationEnabled:o,transformationMode:a,flipX:l,flipY:m}=e;let h=n.points;const g=n.isTypedArray||h instanceof Float32Array,y=g?h.length/8:h.length;let d=c?h:g?new Float32Array(h):h.map(f=>({...f}));for(let f=0;f<y;f++){let s,p,w,M,F,D;if(g?(s=d[f*8],p=d[f*8+1],w=d[f*8+3],M=d[f*8+4],F=d[f*8+5],D=d[f*8+6]):(s=d[f].x,p=d[f].y,w=d[f].r,M=d[f].g,F=d[f].b,D=d[f].blanking?1:0),o&&r){let x=(s+1)/2,u=(1-p)/2;a==="crop"?(x<r.x||x>r.x+r.w||u<r.y||u>r.y+r.h)&&(w=0,M=0,F=0,D=1):a==="scale"&&(x=r.x+x*r.w,u=r.y+u*r.h,s=x*2-1,p=1-u*2)}if(i&&i.length>0){let x=(s+1)/2,u=(1-p)/2;for(const S of i)if(x>=S.x&&x<=S.x+S.w&&u>=S.y&&u<=S.y+S.h){w=0,M=0,F=0,D=1;break}}l&&(s=-s),m&&(p=-p),s=Math.max(-1,Math.min(1,s)),p=Math.max(-1,Math.min(1,p)),g?(d[f*8]=s,d[f*8+1]=p,d[f*8+3]=w,d[f*8+4]=M,d[f*8+5]=F,d[f*8+6]=D):(d[f].x=s,d[f].y=p,d[f].r=w,d[f].g=M,d[f].b=F,d[f].blanking=D>.5)}return{...n,points:d,isTypedArray:g}}const z=.08,H=4,V=.5;function ue(n){if(!n)return new Float32Array(0);const e=n instanceof Float32Array||n.isTypedArray,c=e?n.length/8:n.length;if(c>4e3){if(n instanceof Float32Array)return n;const f=new Float32Array(c*8);for(let s=0;s<c;s++){const p=n[s];f[s*8]=p.x,f[s*8+1]=p.y,f[s*8+2]=p.z||0,f[s*8+3]=p.r,f[s*8+4]=p.g,f[s*8+5]=p.b,f[s*8+6]=p.blanking?1:0,f[s*8+7]=p.lastPoint?1:0}return f}const i=[],r=(f,s,p,w,M,F,D)=>{i.push(f,s,p,w,M,F,D?1:0,0)},o=f=>{if(e){const s=f*8;return{x:n[s],y:n[s+1],z:n[s+2],r:n[s+3],g:n[s+4],b:n[s+5],blanking:n[s+6]>.5}}else{const s=n[f];return{x:s.x||0,y:s.y||0,z:s.z||0,r:s.r||0,g:s.g||0,b:s.b||0,blanking:!!s.blanking}}};if(c===0)return new Float32Array(0);let a=o(0);for(let f=0;f<c;f++){const s=o(f),p=s.x-a.x,w=s.y-a.y,M=Math.sqrt(p*p+w*w),F=s.blanking||a.blanking||M>V;if(F&&!a.blanking&&(r(a.x,a.y,a.z,0,0,0,!0),r(a.x,a.y,a.z,0,0,0,!0)),M>z){const D=Math.floor(M/z);for(let x=1;x<D;x++){const u=x/D,S=a.x+p*u,b=a.y+w*u,R=a.z+(s.z-a.z)*u,I=F?0:s.r,v=F?0:s.g,P=F?0:s.b,_=F||s.blanking;r(S,b,R,I,v,P,_)}}if(a.blanking!==s.blanking){const D=M<.01?1:H;for(let x=0;x<D;x++)r(s.x,s.y,s.z,0,0,0,!0)}r(s.x,s.y,s.z,s.r,s.g,s.b,s.blanking),a=s}const l=o(0),m=l.x-a.x,h=l.y-a.y,g=Math.sqrt(m*m+h*h);if(l.blanking||a.blanking||g>V){if(r(a.x,a.y,a.z,0,0,0,!0),r(a.x,a.y,a.z,0,0,0,!0),g>z){const f=Math.floor(g/z);for(let s=1;s<f;s++){const p=s/f;r(a.x+m*p,a.y+h*p,a.z+(l.z-a.z)*p,0,0,0,!0)}}for(let f=0;f<H;f++)r(l.x,l.y,l.z,0,0,0,!0)}const d=new Float32Array(i);return n._channelDistributions&&(d._channelDistributions=n._channelDistributions),d}class me{constructor(e,c){if(this.canvas=e,this.type=c,this.gl=e.getContext("webgl")||e.getContext("experimental-webgl"),this.animationFrameId=null,this.frameIndexes=Array(10).fill(0),this.pointIndexes=Array(10).fill(0),this.showBeamEffect=!1,this.beamAlpha=.5,this.fadeAlpha=.13,this.beamRenderMode="both",this.positionBuffer=null,this.colorBuffer=null,this.alphaBuffer=null,this.alphaBufferData=new Float32Array(131072),this.lastPointDrawTime=0,!this.gl){console.error("WebGL not supported");return}this.setup()}setup(){const e=this.gl,c=`
      attribute vec2 aPosition;
      attribute vec3 aColor;
      attribute float aAlpha;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        gl_PointSize = 2.0;
        vColor = aColor;
        vAlpha = aAlpha;
      }
    `,i=`
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(vColor, vAlpha);
      }
    `,r=this.createShader(e.VERTEX_SHADER,c),o=this.createShader(e.FRAGMENT_SHADER,i),a=this.createProgram(r,o);this.program=a,this.positionAttributeLocation=e.getAttribLocation(a,"aPosition"),this.colorAttributeLocation=e.getAttribLocation(a,"aColor"),this.alphaAttributeLocation=e.getAttribLocation(a,"aAlpha"),this.quadPositionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer);const l=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(l),e.STATIC_DRAW),this.quadColorUniformLocation=e.getUniformLocation(a,"uColor"),this.quadAlphaUniformLocation=e.getUniformLocation(a,"uAlpha");const m=`
      attribute vec2 aPosition;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `,h=`
      precision mediump float;
      uniform vec4 uColor;
      void main() {
        gl_FragColor = uColor;
      }
    `,g=this.createShader(e.VERTEX_SHADER,m),y=this.createShader(e.FRAGMENT_SHADER,h);this.fadeProgram=this.createProgram(g,y),this.fadePositionAttributeLocation=e.getAttribLocation(this.fadeProgram,"aPosition"),this.fadeColorUniformLocation=e.getUniformLocation(this.fadeProgram,"uColor"),e.useProgram(a);const d=131072;this.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.bufferData(e.ARRAY_BUFFER,d*2*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.colorBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.colorBuffer),e.bufferData(e.ARRAY_BUFFER,d*3*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.alphaBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.alphaBuffer),e.bufferData(e.ARRAY_BUFFER,d*1*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.clearColor(0,0,0,1)}reset(){this.frameIndexes.fill(0),this.pointIndexes.fill(0),this.clearCanvas()}createShader(e,c){const i=this.gl,r=i.createShader(e);if(i.shaderSource(r,c),i.compileShader(r),i.getShaderParameter(r,i.COMPILE_STATUS))return r;console.error(i.getShaderInfoLog(r)),i.deleteShader(r)}createProgram(e,c){const i=this.gl,r=i.createProgram();if(i.attachShader(r,e),i.attachShader(r,c),i.linkProgram(r),i.getProgramParameter(r,i.LINK_STATUS))return r;console.error(i.getProgramInfoLog(r)),i.deleteProgram(r)}render(e){e.showBeamEffect!==void 0&&this.setBeamEffect(e.showBeamEffect),e.beamAlpha!==void 0&&this.setBeamAlpha(e.beamAlpha),e.fadeAlpha!==void 0&&this.setFadeAlpha(e.fadeAlpha),e.beamRenderMode!==void 0&&(this.beamRenderMode=e.beamRenderMode),this.type==="world"?this.renderWorld(e.worldData,e.previewScanRate,e.layerIntensities,e.masterIntensity,e.dacSettings,e.previewTime,e.fftLevels,e.optimizationEnabled):this.renderSingle(e.ildaFrames,e.previewScanRate,e.intensity,e.effects,e.syncSettings,e.bpm,e.clipDuration,e.progress,e.previewTime,e.fftLevels,e.effectStates,e.optimizationEnabled)}renderSingle(e,c,i,r,o={},a=120,l=1,m=null,h=null,g={low:0,mid:0,high:0},y=null,d=!0){const f=this.gl;if(f.viewport(0,0,f.canvas.width,f.canvas.height),this.drawFadeQuad(),!e||e.length===0)return;const s=this.frameIndexes[0]%e.length,p=e[s],w=m!==null?m:s/e.length,M=h!==null?h:performance.now();this.draw(p,r,this.showBeamEffect,this.beamAlpha,c,this.beamRenderMode,i,0,w,M,o,a,l,g,y,d),this.frameIndexes[0]++,this.frameIndexes[0]>=e.length&&(this.frameIndexes[0]=0)}renderWorld(e,c,i,r,o,a=null,l={low:0,mid:0,high:0},m=!0){const h=this.gl;h.viewport(0,0,h.canvas.width,h.canvas.height),this.drawFadeQuad();const g=a!==null?a:performance.now();e.forEach(y=>{if(y&&y.frames&&y.frames.length>0){const d=y.frames[0];if(d){const f=y.layerIndex||0;if(y.syncSettings,y.bpm,f>=this.frameIndexes.length){const w=f+5;for(;this.frameIndexes.length<w;)this.frameIndexes.push(0),this.pointIndexes.push(0)}const p=(i[f]!==void 0?i[f]:1)*r;if(p>.001){const w=y.progress!==void 0?y.progress:this.frameIndexes[f]%y.frames.length/y.frames.length,{syncSettings:M={},bpm:F=120,clipDuration:D=1,effectStates:x=null}=y;let u=d;if(o){let S=d;if(o.dimmer!==void 0&&o.dimmer<1){const b=d.points,R=d.isTypedArray||b instanceof Float32Array,I=R?b.length/8:b.length,v=R?new Float32Array(b):b.map(P=>({...P}));for(let P=0;P<I;P++)R?(v[P*8+3]*=o.dimmer,v[P*8+4]*=o.dimmer,v[P*8+5]*=o.dimmer):(v[P].r*=o.dimmer,v[P].g*=o.dimmer,v[P].b*=o.dimmer);S={...d,points:v,isTypedArray:t}}u=pe(S,o)}this.draw(u,y.effects,this.showBeamEffect,this.beamAlpha,c,this.beamRenderMode,p,f,w,g,M,F,D,l,x,m)}}}}),e.forEach(y=>{if(y&&y.frames){const d=y.layerIndex||0;this.frameIndexes[d]++,this.frameIndexes[d]>=y.frames.length&&(this.frameIndexes[d]=0)}})}drawFadeQuad(){const e=this.gl;this.fadeProgram&&(e.useProgram(this.fadeProgram),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer),e.enableVertexAttribArray(this.fadePositionAttributeLocation),e.vertexAttribPointer(this.fadePositionAttributeLocation,2,e.FLOAT,!1,0,0),e.uniform4f(this.fadeColorUniformLocation,0,0,0,this.fadeAlpha),e.drawArrays(e.TRIANGLES,0,6))}setBeamEffect(e){this.showBeamEffect=e}setBeamAlpha(e){this.beamAlpha=e}setFadeAlpha(e){this.fadeAlpha=e}draw(e,c,i,r,o,a,l=1,m=0,h=0,g=performance.now(),y={},d=120,f=1,s={low:0,mid:0,high:0},p=null,w=!0){if(this.gl,!e||!e.points)return;let M=e;if(w){const _=ue(e.points);M={...e,points:_,isTypedArray:!0}}const F=K(M,c,{progress:h,time:g,syncSettings:y,bpm:d,clipDuration:f,fftLevels:s,effectStates:p}),D=F.points,x=F.isTypedArray,u=x?D.length/8:D.length;if(u===0)return;const S=Math.max(1,Math.floor(u/o));let b=this.pointIndexes[m]||0;b>=u&&(b=0);const R=_=>{const B=(b+_)%u;if(x){const A=B*8;return{x:D[A],y:D[A+1],r:D[A+3],g:D[A+4],b:D[A+5],blanking:D[A+6]===1}}else{const A=D[B];return{x:A.x,y:A.y,r:A.r,g:A.g,b:A.b,blanking:A.blanking}}},I=()=>{const _=a==="points"||a==="both",B=a==="lines"||a==="both";let A=[],C=[];for(let E=0;E<S;E++){const L=R(E);if(L.blanking){A.length>0&&(B&&this._drawSegment(new Float32Array(A),new Float32Array(C),1,A.length/2,!1),_&&this._drawSegment(new Float32Array(A),new Float32Array(C),1,A.length/2,!0),A=[],C=[]);continue}A.push(L.x,L.y),C.push(L.r/255*l,L.g/255*l,L.b/255*l)}A.length>0&&(B&&this._drawSegment(new Float32Array(A),new Float32Array(C),1,A.length/2,!1),_&&this._drawSegment(new Float32Array(A),new Float32Array(C),1,A.length/2,!0))},v=()=>{const _=[],B=[];for(let A=0;A<S;A++){const C=R(A);if(!C.blanking){_.push(0,0,C.x,C.y);const E=[C.r/255*l,C.g/255*l,C.b/255*l];B.push(...E,...E)}}_.length>0&&this._drawLines(new Float32Array(_),new Float32Array(B),r,_.length/2)},P=()=>{const _=[],B=[];let A=R(0);for(let C=1;C<S;C++){const E=R(C);if(!A.blanking&&!E.blanking){_.push(0,0,A.x,A.y,E.x,E.y);const L=[A.r/255*l,A.g/255*l,A.b/255*l],k=[E.r/255*l,E.g/255*l,E.b/255*l],U=[(L[0]+k[0])/2,(L[1]+k[1])/2,(L[2]+k[2])/2],T=.3,O=[L[0]*T,L[1]*T,L[2]*T],be=[k[0]*T,k[1]*T,k[2]*T];B.push(...U,...O,...be)}A=E}_.length>0&&this._drawTriangles(new Float32Array(_),new Float32Array(B),r,_.length/2)};I(),i&&(a==="points"?v():a==="lines"?P():a==="both"&&(P(),v())),this.pointIndexes[m]=(b+S)%u}_drawSegment(e,c,i,r,o=!1){const a=this.gl;a.useProgram(this.program),a.bindBuffer(a.ARRAY_BUFFER,this.positionBuffer),a.bufferSubData(a.ARRAY_BUFFER,0,e),a.enableVertexAttribArray(this.positionAttributeLocation),a.vertexAttribPointer(this.positionAttributeLocation,2,a.FLOAT,!1,0,0),a.bindBuffer(a.ARRAY_BUFFER,this.colorBuffer),a.bufferSubData(a.ARRAY_BUFFER,0,c),a.enableVertexAttribArray(this.colorAttributeLocation),a.vertexAttribPointer(this.colorAttributeLocation,3,a.FLOAT,!1,0,0),this.alphaBufferData.length<r&&(this.alphaBufferData=new Float32Array(r*2)),this.alphaBufferData.fill(i,0,r);const l=this.alphaBufferData.subarray(0,r);a.bindBuffer(a.ARRAY_BUFFER,this.alphaBuffer),a.bufferSubData(a.ARRAY_BUFFER,0,l),a.enableVertexAttribArray(this.alphaAttributeLocation),a.vertexAttribPointer(this.alphaAttributeLocation,1,a.FLOAT,!1,0,0),a.drawArrays(o?a.POINTS:a.LINE_STRIP,0,r)}_drawLines(e,c,i,r){const o=this.gl;o.useProgram(this.program),o.bindBuffer(o.ARRAY_BUFFER,this.positionBuffer),o.bufferSubData(o.ARRAY_BUFFER,0,e),o.enableVertexAttribArray(this.positionAttributeLocation),o.vertexAttribPointer(this.positionAttributeLocation,2,o.FLOAT,!1,0,0),o.bindBuffer(o.ARRAY_BUFFER,this.colorBuffer),o.bufferSubData(o.ARRAY_BUFFER,0,c),o.enableVertexAttribArray(this.colorAttributeLocation),o.vertexAttribPointer(this.colorAttributeLocation,3,o.FLOAT,!1,0,0),this.alphaBufferData.length<r&&(this.alphaBufferData=new Float32Array(r*2)),this.alphaBufferData.fill(i,0,r);const a=this.alphaBufferData.subarray(0,r);o.bindBuffer(o.ARRAY_BUFFER,this.alphaBuffer),o.bufferSubData(o.ARRAY_BUFFER,0,a),o.enableVertexAttribArray(this.alphaAttributeLocation),o.vertexAttribPointer(this.alphaAttributeLocation,1,o.FLOAT,!1,0,0),o.drawArrays(o.LINES,0,r)}_drawTriangles(e,c,i,r){const o=this.gl;o.useProgram(this.program),o.bindBuffer(o.ARRAY_BUFFER,this.positionBuffer),o.bufferSubData(o.ARRAY_BUFFER,0,e),o.enableVertexAttribArray(this.positionAttributeLocation),o.vertexAttribPointer(this.positionAttributeLocation,2,o.FLOAT,!1,0,0),o.bindBuffer(o.ARRAY_BUFFER,this.colorBuffer),o.bufferSubData(o.ARRAY_BUFFER,0,c),o.enableVertexAttribArray(this.colorAttributeLocation),o.vertexAttribPointer(this.colorAttributeLocation,3,o.FLOAT,!1,0,0),this.alphaBufferData.length<r&&(this.alphaBufferData=new Float32Array(r*2)),this.alphaBufferData.fill(i,0,r);const a=this.alphaBufferData.subarray(0,r);o.bindBuffer(o.ARRAY_BUFFER,this.alphaBuffer),o.bufferSubData(o.ARRAY_BUFFER,0,a),o.enableVertexAttribArray(this.alphaAttributeLocation),o.vertexAttribPointer(this.alphaAttributeLocation,1,o.FLOAT,!1,0,0),o.drawArrays(o.TRIANGLES,0,r)}clearCanvas(){const e=this.gl;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT)}destroy(){if(cancelAnimationFrame(this.animationFrameId),this.gl){const e=this.gl.getExtension("WEBGL_losing_context");e&&e.loseContext()}}}const Y=new Map;function G(n,e=0){const c=Y.get(n);if(!c)return;const i=performance.now();c.renderer.render(c.data),e=i,c.animationFrameId=requestAnimationFrame(()=>G(n,e))}self.onmessage=n=>{const{action:e,payload:c}=n.data;if(e==="register"){const{id:i,canvas:r,type:o,data:a}=c,l=new me(r,o),m=requestAnimationFrame(()=>G(i));Y.set(i,{renderer:l,type:o,data:a,animationFrameId:m})}else if(e==="deregister"){const{id:i}=c,r=Y.get(i);r&&(cancelAnimationFrame(r.animationFrameId),Y.delete(i))}else if(e==="update"){const{id:i,data:r}=c,o=Y.get(i);if(o){if(o.data&&o.data.effectStates&&r.effectStates)r.effectStates=o.data.effectStates;else if(o.data&&o.data.worldData&&o.data.worldData.length>0){const a=o.data.worldData[0];if(a&&a.effectStates&&r.worldData){const l=a.effectStates;for(const m of r.worldData)m.effectStates=l}}o.data=r}}else if(e==="clear"){const{id:i}=c,r=Y.get(i);r&&r.renderer.clearCanvas()}}})();
