(function(){"use strict";const B=[{id:"rotate",name:"Rotate",type:"transform",description:"Rotates the shape around its center.",defaultParams:{angle:0,speed:0,direction:"CW"},paramControls:[{id:"angle",label:"Angle",type:"range",min:0,max:360,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["CW","CCW"]}]},{id:"scale",name:"Scale",type:"transform",description:"Scales the shape.",defaultParams:{scaleX:1,scaleY:1},paramControls:[{id:"scaleX",label:"Scale X",type:"range",min:.01,max:5,step:.01},{id:"scaleY",label:"Scale Y",type:"range",min:.01,max:5,step:.01}]},{id:"translate",name:"Translate",type:"transform",description:"Moves the shape.",defaultParams:{translateX:0,translateY:0},paramControls:[{id:"translateX",label:"Translate X",type:"range",min:-1,max:1,step:.01},{id:"translateY",label:"Translate Y",type:"range",min:-1,max:1,step:.01}]},{id:"color",name:"Color",type:"color",description:"Changes the color of the shape with solid or rainbow modes.",defaultParams:{mode:"solid",r:255,g:255,b:255,cycleSpeed:0,rainbowSpread:1,rainbowOffset:0},paramControls:[{id:"mode",label:"Mode",type:"select",options:["solid","rainbow"]},{id:"r",label:"Red",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"g",label:"Green",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"b",label:"Blue",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"cycleSpeed",label:"Cycle Speed",type:"range",min:0,max:10,step:.1},{id:"rainbowSpread",label:"Rainbow Spread",type:"range",min:.1,max:10,step:.1,showIf:{mode:"rainbow"}},{id:"rainbowOffset",label:"Rainbow Offset",type:"range",min:0,max:360,step:1,showIf:{mode:"rainbow"}},{id:"rainbowPalette",label:"Palette",type:"select",options:["rainbow","fire","ice","cyber"],showIf:{mode:"rainbow"}}]},{id:"wave",name:"Wave",type:"animation",description:"Applies a wave distortion to the shape.",defaultParams:{amplitude:.1,frequency:10,speed:1,direction:"x"},paramControls:[{id:"amplitude",label:"Amplitude",type:"range",min:.01,max:1,step:.01},{id:"frequency",label:"Frequency",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["x","y"]}]},{id:"warp",name:"Warp",type:"animation",description:"Symmetrical chaotic wave distortion.",defaultParams:{amount:.1,chaos:.5,speed:1},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"chaos",label:"Chaos",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1}]},{id:"distortion",name:"Distortion",type:"transform",description:"Distorts the point data.",defaultParams:{amount:.1,scale:10,speed:.5},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"scale",label:"Scale",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:5,step:.1}]},{id:"move",name:"Move (Bounce)",type:"transform",description:"Moves points and bounces them off the borders.",defaultParams:{speedX:.1,speedY:.1},paramControls:[{id:"speedX",label:"Speed X",type:"range",min:0,max:2,step:.01},{id:"speedY",label:"Speed Y",type:"range",min:0,max:2,step:.01}]},{id:"delay",name:"Delay",type:"effect",description:"Channel-based delay effect.",defaultParams:{useAssigned:!0,delayI:!0,delayC:!1,delayE:!1,delayMode:"linear",delayDirection:"left_to_right",delayAmount:5,decay:.8},paramControls:[{id:"useAssigned",label:"Use Assigned Channels",type:"checkbox"},{id:"delayI",label:"I (Intensity)",type:"checkbox"},{id:"delayC",label:"C (Color)",type:"checkbox"},{id:"delayE",label:"E (Effect)",type:"checkbox"},{id:"delayMode",label:"Mode",type:"select",options:["linear","symmetric"]},{id:"delayDirection",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"]},{id:"delayAmount",label:"Delay Time",type:"range",min:1,max:60,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01}]},{id:"chase",name:"Chase",type:"effect",description:"Step-based chase effect.",defaultParams:{steps:4,decay:.8,speed:1},paramControls:[{id:"steps",label:"Steps",type:"range",min:2,max:16,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:5,step:.1}]},{id:"blanking",name:"Blanking",type:"animation",description:"Controls the blanking of the laser output.",defaultParams:{blankingInterval:0},paramControls:[{id:"blankingInterval",label:"Blanking Interval",type:"range",min:0,max:10,step:1}]},{id:"strobe",name:"Strobe",type:"animation",description:"Applies a strobe effect to the laser output.",defaultParams:{strobeSpeed:100,strobeAmount:.5},paramControls:[{id:"strobeSpeed",label:"Strobe Speed (ms)",type:"range",min:10,max:1e3,step:10},{id:"strobeAmount",label:"Strobe Amount (0-1)",type:"range",min:0,max:1,step:.01}]},{id:"mirror",name:"Mirror",type:"transform",description:"Mirrors the shape from the center.",defaultParams:{mode:"none"},paramControls:[{id:"mode",label:"Mirror Mode",type:"select",options:["none","x+","x-","y+","y-"]}]}],v=(o,e)=>({...e,...o});function U(o,e,l={}){const{progress:n=0,time:a=performance.now(),effectStates:t}=l;if(!e||e.length===0)return o;let i;if(Array.isArray(o.points)){i=new Float32Array(o.points.length*8);for(let s=0;s<o.points.length;s++){const f=o.points[s],d=s*8;i[d]=f.x,i[d+1]=f.y,i[d+2]=f.z||0,i[d+3]=f.r,i[d+4]=f.g,i[d+5]=f.b,i[d+6]=f.blanking?1:0,i[d+7]=f.lastPoint?1:0}}else i=new Float32Array(o.points);let r=i;const c=()=>r.length/8;for(const s of e)if(B.find(d=>d.id===s.id))switch(s.id){case"rotate":X(r,c(),s.params,n,a);break;case"scale":O(r,c(),s.params);break;case"translate":N(r,c(),s.params);break;case"color":W(r,c(),s.params,a);break;case"wave":q(r,c(),s.params,a);break;case"blanking":G(r,c(),s.params);break;case"strobe":H(r,c(),s.params,a);break;case"mirror":z(r,c(),s.params);break;case"warp":Q(r,c(),s.params,a);break;case"distortion":K(r,c(),s.params,a);break;case"move":$(r,c(),s.params,a);break;case"delay":t&&s.instanceId&&(r=Z(r,c(),s.params,t,s.instanceId));break;case"chase":j(r,c(),s.params,a);break}return{...o,points:r,isTypedArray:!0}}function X(o,e,l,n,a){const{angle:t,speed:i,direction:r}=v(l,B.find(m=>m.id==="rotate").defaultParams),c=r==="CCW"?-1:1,s=a*.001*i*c,f=t*Math.PI/180+s,d=Math.sin(f),u=Math.cos(f);for(let m=0;m<e;m++){const h=m*8,A=o[h],E=o[h+1];o[h]=A*u-E*d,o[h+1]=A*d+E*u}}function O(o,e,l){const{scaleX:n,scaleY:a}=v(l,B.find(t=>t.id==="scale").defaultParams);for(let t=0;t<e;t++){const i=t*8;o[i]*=n,o[i+1]*=a}}function N(o,e,l){const{translateX:n,translateY:a}=v(l,B.find(t=>t.id==="translate").defaultParams);for(let t=0;t<e;t++){const i=t*8;o[i]+=n,o[i+1]+=a}}function W(o,e,l,n){const{mode:a,r:t,g:i,b:r,cycleSpeed:c,rainbowSpread:s,rainbowOffset:f,rainbowPalette:d}=v(l,B.find(m=>m.id==="color").defaultParams),u=n*.001*c;if(a==="rainbow"){const m=d||"rainbow";for(let h=0;h<e;h++){const A=h*8,E=(h/e*s+u*.5+f/360)%1;let y,S,x;m==="rainbow"?[y,S,x]=D(E,1,.5):[y,S,x]=V(m,E),o[A+3]=y,o[A+4]=S,o[A+5]=x}}else if(c>0){const m=u*50%360,[h,A,E]=D(m/360,1,.5);for(let y=0;y<e;y++){const S=y*8;o[S+3]=h,o[S+4]=A,o[S+5]=E}}else for(let m=0;m<e;m++){const h=m*8;o[h+3]=t,o[h+4]=i,o[h+5]=r}}function V(o,e){const l={fire:[{r:255,g:0,b:0},{r:255,g:128,b:0},{r:255,g:255,b:0},{r:255,g:0,b:0}],ice:[{r:0,g:0,b:255},{r:0,g:255,b:255},{r:255,g:255,b:255},{r:0,g:0,b:255}],cyber:[{r:255,g:0,b:255},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:255,g:0,b:255}]},n=l[o]||l.fire,a=e*(n.length-1),t=Math.floor(a),i=a-t,r=n[t],c=n[t+1]||n[t];return[Math.round(r.r+(c.r-r.r)*i),Math.round(r.g+(c.g-r.g)*i),Math.round(r.b+(c.b-r.b)*i)]}function D(o,e,l){let n,a,t;{const i=(s,f,d)=>(d<0&&(d+=1),d>1&&(d-=1),d<.16666666666666666?s+(f-s)*6*d:d<.5?f:d<.6666666666666666?s+(f-s)*(.6666666666666666-d)*6:s),r=l+e-l*e,c=2*l-r;n=i(c,r,o+1/3),a=i(c,r,o),t=i(c,r,o-1/3)}return[Math.round(n*255),Math.round(a*255),Math.round(t*255)]}function q(o,e,l,n){const{amplitude:a,frequency:t,speed:i,direction:r}=v(l,B.find(s=>s.id==="wave").defaultParams),c=n*.001*i;for(let s=0;s<e;s++){const f=s*8;r==="x"?o[f+1]+=a*Math.sin(o[f]*t+c):r==="y"&&(o[f]+=a*Math.sin(o[f+1]*t+c))}}function G(o,e,l){const{blankingInterval:n}=v(l,B.find(a=>a.id==="blanking").defaultParams);if(!(n<=0))for(let a=0;a<e;a++)a%(n+1)===n&&(o[a*8+6]=1)}function H(o,e,l,n){const{strobeSpeed:a,strobeAmount:t}=v(l,B.find(r=>r.id==="strobe").defaultParams);if(n%a/a<t)for(let r=0;r<e;r++)o[r*8+6]=1}function z(o,e,l){const{mode:n}=v(l,B.find(a=>a.id==="mirror").defaultParams);if(n!=="none")for(let a=0;a<e;a++){const t=a*8,i=o[t],r=o[t+1];n==="x+"?o[t]=Math.abs(i):n==="x-"?o[t]=-Math.abs(i):n==="y+"?o[t+1]=Math.abs(r):n==="y-"&&(o[t+1]=-Math.abs(r))}}function Q(o,e,l,n){const{amount:a,chaos:t,speed:i}=v(l,B.find(c=>c.id==="warp").defaultParams),r=n*.001*i;for(let c=0;c<e;c++){const s=c*8,f=o[s],d=o[s+1],u=Math.abs(d);o[s]+=Math.sin(u*10*(1+t)+r)*a*Math.cos(r*t),o[s+1]+=Math.cos(Math.abs(f)*10*(1+t)+r)*a*Math.sin(r*t)}}function K(o,e,l,n){const{amount:a,scale:t,speed:i}=v(l,B.find(c=>c.id==="distortion").defaultParams),r=n*.001*i;for(let c=0;c<e;c++){const s=c*8,f=Math.sin(o[s]*t+r)*Math.cos(o[s+1]*t-r),d=Math.cos(o[s]*t-r)*Math.sin(o[s+1]*t+r);o[s]+=f*a,o[s+1]+=d*a}}function $(o,e,l,n){const{speedX:a,speedY:t}=v(l,B.find(f=>f.id==="move").defaultParams),i=n*.001,r=i*a,c=i*t,s=4;for(let f=0;f<e;f++){const d=f*8;let u=o[d]+r,m=o[d+1]+c,h=(u+1)%s;h<0&&(h+=s),h>2&&(h=4-h),u=h-1;let A=(m+1)%s;A<0&&(A+=s),A>2&&(A=4-A),m=A-1,o[d]=u,o[d+1]=m}}function Z(o,e,l,n,a){const t=B.find(x=>x.id==="delay").defaultParams,{delayAmount:i,decay:r,delayI:c,delayC:s,delayE:f,delayDirection:d}=v(l,t);n.has(a)||n.set(a,[]);const u=n.get(a),m=new Float32Array(o);u.unshift(m);const h=i*4+1;u.length>h&&(u.length=h);const A=[];for(let x=1;x<=4;x++){const F=x*i;if(F<u.length){const I=u[F];I.length===o.length&&A.push({points:I,factor:Math.pow(r,x),index:x})}}if(A.length===0)return o;const E=e+A.reduce((x,F)=>x+F.points.length/8,0),y=new Float32Array(E*8);let S=0;for(const x of A.reverse()){const F=x.points,I=F.length/8,M=x.factor,g=x.index;let w=0,p=0,b=1,P=1;d==="left_to_right"?w=-.1*g:d==="right_to_left"?w=.1*g:d==="center_to_out"?b=P=1+.1*g:d==="out_to_center"&&(b=P=1-.1*g);for(let _=0;_<I;_++){const R=_*8,C=S+_*8,ee=F[R],te=F[R+1],ae=F[R+2],re=F[R+3],oe=F[R+4],ne=F[R+5],se=F[R+6],ie=o[R],le=o[R+1],ce=o[R+3],fe=o[R+4],de=o[R+5],he=o[R+6];let Y=f?ee:ie,T=f?te:le;Y=Y*b+w,T=T*P+p,y[C]=Y,y[C+1]=T,y[C+2]=ae;const me=s?re:ce,pe=s?oe:fe,ue=s?ne:de;y[C+3]=me*M,y[C+4]=pe*M,y[C+5]=ue*M;const be=c?se:he;y[C+6]=be,y[C+7]=F[R+7]}S+=F.length}return y.set(o,S),y}function j(o,e,l,n){const{steps:a,decay:t,speed:i}=v(l,B.find(f=>f.id==="chase").defaultParams),r=n*.001*i,c=Math.floor(r%a),s=e/a;for(let f=0;f<e;f++){const d=Math.floor(f/s),u=f*8;let m=Math.abs(d-c);m>a/2&&(m=a-m);let h=1;m>0&&(h=Math.pow(t,m)),o[u+3]*=h,o[u+4]*=h,o[u+5]*=h,h<.1&&(o[u+6]=1)}}class J{constructor(e,l){if(this.canvas=e,this.type=l,this.gl=e.getContext("webgl")||e.getContext("experimental-webgl"),this.animationFrameId=null,this.frameIndexes=Array(10).fill(0),this.pointIndexes=Array(10).fill(0),this.showBeamEffect=!1,this.beamAlpha=.5,this.fadeAlpha=.13,this.beamRenderMode="lines",this.positionBuffer=null,this.colorBuffer=null,this.alphaBuffer=null,this.lastPointDrawTime=0,!this.gl){console.error("WebGL not supported");return}this.setup()}setup(){const e=this.gl,l=`
      attribute vec2 aPosition;
      attribute vec3 aColor;
      attribute float aAlpha;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        gl_PointSize = 2.0;
        vColor = aColor;
        vAlpha = aAlpha;
      }
    `,n=`
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(vColor, vAlpha);
      }
    `,a=this.createShader(e.VERTEX_SHADER,l),t=this.createShader(e.FRAGMENT_SHADER,n),i=this.createProgram(a,t);this.program=i,this.positionAttributeLocation=e.getAttribLocation(i,"aPosition"),this.colorAttributeLocation=e.getAttribLocation(i,"aColor"),this.alphaAttributeLocation=e.getAttribLocation(i,"aAlpha"),this.quadPositionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer);const r=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(r),e.STATIC_DRAW),this.quadColorUniformLocation=e.getUniformLocation(i,"uColor"),this.quadAlphaUniformLocation=e.getUniformLocation(i,"uAlpha");const c=`
      attribute vec2 aPosition;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `,s=`
      precision mediump float;
      uniform vec4 uColor;
      void main() {
        gl_FragColor = uColor;
      }
    `,f=this.createShader(e.VERTEX_SHADER,c),d=this.createShader(e.FRAGMENT_SHADER,s);this.fadeProgram=this.createProgram(f,d),this.fadePositionAttributeLocation=e.getAttribLocation(this.fadeProgram,"aPosition"),this.fadeColorUniformLocation=e.getUniformLocation(this.fadeProgram,"uColor"),e.useProgram(i);const u=131072;this.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.bufferData(e.ARRAY_BUFFER,u*2*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.colorBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.colorBuffer),e.bufferData(e.ARRAY_BUFFER,u*3*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.alphaBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.alphaBuffer),e.bufferData(e.ARRAY_BUFFER,u*1*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA)}reset(){this.frameIndexes.fill(0),this.pointIndexes.fill(0),this.clearCanvas()}createShader(e,l){const n=this.gl,a=n.createShader(e);if(n.shaderSource(a,l),n.compileShader(a),n.getShaderParameter(a,n.COMPILE_STATUS))return a;console.error(n.getShaderInfoLog(a)),n.deleteShader(a)}createProgram(e,l){const n=this.gl,a=n.createProgram();if(n.attachShader(a,e),n.attachShader(a,l),n.linkProgram(a),n.getProgramParameter(a,n.LINK_STATUS))return a;console.error(n.getProgramInfoLog(a)),n.deleteProgram(a)}render(e){e.showBeamEffect!==void 0&&this.setBeamEffect(e.showBeamEffect),e.beamAlpha!==void 0&&this.setBeamAlpha(e.beamAlpha),e.fadeAlpha!==void 0&&this.setFadeAlpha(e.fadeAlpha),e.beamRenderMode!==void 0&&(this.beamRenderMode=e.beamRenderMode),this.type==="world"?this.renderWorld(e.worldData,e.previewScanRate,e.layerIntensities,e.masterIntensity):this.renderSingle(e.ildaFrames,e.previewScanRate,e.intensity,e.effects,e.syncSettings)}renderSingle(e,l,n,a,t={}){const i=this.gl;if(i.viewport(0,0,i.canvas.width,i.canvas.height),this.drawFadeQuad(),!e||e.length===0)return;const r=this.frameIndexes[0]%e.length,c=e[r],s=r/e.length,f=performance.now();this.draw(c,a,this.showBeamEffect,this.beamAlpha,l,this.beamRenderMode,n,0,s,f,t),this.frameIndexes[0]++,this.frameIndexes[0]>=e.length&&(this.frameIndexes[0]=0)}renderWorld(e,l,n,a){const t=this.gl;t.viewport(0,0,t.canvas.width,t.canvas.height),this.drawFadeQuad();const i=performance.now();e.forEach(r=>{if(r&&r.frames&&r.frames.length>0){const c=r.frames[0];if(c){const s=r.layerIndex||0,f=r.syncSettings||{};if(s>=this.frameIndexes.length){const m=s+5;for(;this.frameIndexes.length<m;)this.frameIndexes.push(0),this.pointIndexes.push(0)}const u=(n[s]!==void 0?n[s]:1)*a;if(u>.001){const m=this.frameIndexes[s]%r.frames.length/r.frames.length;this.draw(c,r.effects,this.showBeamEffect,this.beamAlpha,l,this.beamRenderMode,u,s,m,i,f)}}}}),e.forEach(r=>{if(r&&r.frames){const c=r.layerIndex||0;this.frameIndexes[c]++,this.frameIndexes[c]>=r.frames.length&&(this.frameIndexes[c]=0)}})}drawFadeQuad(){const e=this.gl;this.fadeProgram&&(e.useProgram(this.fadeProgram),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer),e.enableVertexAttribArray(this.fadePositionAttributeLocation),e.vertexAttribPointer(this.fadePositionAttributeLocation,2,e.FLOAT,!1,0,0),e.uniform4f(this.fadeColorUniformLocation,0,0,0,this.fadeAlpha),e.drawArrays(e.TRIANGLES,0,6))}setBeamEffect(e){this.showBeamEffect=e}setBeamAlpha(e){this.beamAlpha=e}setFadeAlpha(e){this.fadeAlpha=e}draw(e,l,n,a,t,i,r=1,c=0,s=0,f=performance.now(),d={}){if(this.gl,!e||!e.points)return;const u=(l||[]).map(g=>{const w={...g.params},p=B.find(b=>b.id===g.id);return p&&p.paramControls.forEach(b=>{const P=`${g.id}.${b.id}`,_=d[P];if(_&&(b.type==="range"||b.type==="number")){let R=0;_==="fps"?R=f*.001%1:(_==="timeline"||_==="bpm")&&(R=s),w[b.id]=b.min+(b.max-b.min)*R}}),{...g,params:w}}),m=U(e,u,{progress:s,time:f}),h=m.points,A=m.isTypedArray,E=A?h.length/8:h.length;if(E===0)return;const y=Math.max(1,Math.floor(E/t));let S=this.pointIndexes[c]||0;S>=E&&(S=0);const x=g=>{const w=(S+g)%E;if(A){const p=w*8;return{x:h[p],y:h[p+1],r:h[p+3],g:h[p+4],b:h[p+5],blanking:h[p+6]===1}}else{const p=h[w];return{x:p.x,y:p.y,r:p.r,g:p.g,b:p.b,blanking:p.blanking}}},F=()=>{let g=[],w=[];for(let p=0;p<y;p++){const b=x(p);if(b.blanking){g.length>0&&(this._drawSegment(new Float32Array(g),new Float32Array(w),1,g.length/2),g=[],w=[]);continue}g.push(b.x,b.y),w.push(b.r/255*r,b.g/255*r,b.b/255*r)}g.length>0&&this._drawSegment(new Float32Array(g),new Float32Array(w),1,g.length/2)},I=()=>{const g=[],w=[];for(let p=0;p<y;p++){const b=x(p);if(!b.blanking){g.push(0,0,b.x,b.y);const P=[b.r/255*r,b.g/255*r,b.b/255*r];w.push(...P,...P)}}g.length>0&&this._drawLines(new Float32Array(g),new Float32Array(w),a,g.length/2)},M=()=>{const g=[],w=[];let p=x(0);for(let b=1;b<y;b++){const P=x(b);if(!p.blanking&&!P.blanking){g.push(0,0,p.x,p.y,P.x,P.y);const _=[p.r/255*r,p.g/255*r,p.b/255*r],R=[P.r/255*r,P.g/255*r,P.b/255*r],C=[(_[0]+R[0])/2,(_[1]+R[1])/2,(_[2]+R[2])/2];w.push(...C,..._,...R)}p=P}g.length>0&&this._drawTriangles(new Float32Array(g),new Float32Array(w),a,g.length/2)};F(),n&&(i==="points"?I():i==="lines"?M():i==="both"&&(M(),I())),this.pointIndexes[c]=(S+y)%E}_drawSegment(e,l,n,a){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,l),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const i=new Float32Array(Array(a).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,i),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINE_STRIP,0,a)}_drawLines(e,l,n,a){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,l),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const i=new Float32Array(Array(a).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,i),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINES,0,a)}_drawTriangles(e,l,n,a){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,l),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const i=new Float32Array(Array(a).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,i),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLES,0,a)}clearCanvas(){const e=this.gl;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT)}destroy(){cancelAnimationFrame(this.animationFrameId)}}const L=new Map;function k(o,e=0){const l=L.get(o);if(!l)return;const n=performance.now();l.renderer.render(l.data),e=n,l.animationFrameId=requestAnimationFrame(()=>k(o,e))}self.onmessage=o=>{const{action:e,payload:l}=o.data;if(e==="register"){const{id:n,canvas:a,type:t,data:i}=l,r=new J(a,t),c=requestAnimationFrame(()=>k(n));L.set(n,{renderer:r,type:t,data:i,animationFrameId:c})}else if(e==="deregister"){const{id:n}=l,a=L.get(n);a&&(cancelAnimationFrame(a.animationFrameId),L.delete(n))}else if(e==="update"){const{id:n,data:a}=l,t=L.get(n);t&&(t.data=a)}else if(e==="clear"){const{id:n}=l,a=L.get(n);a&&a.renderer.clearCanvas()}}})();
