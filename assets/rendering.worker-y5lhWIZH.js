(function(){"use strict";const v=[{id:"rotate",name:"Rotate",type:"transform",description:"Rotates the shape around its center.",defaultParams:{angle:0,speed:0,direction:"CW"},paramControls:[{id:"angle",label:"Angle",type:"range",min:0,max:360,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["CW","CCW"]}]},{id:"scale",name:"Scale",type:"transform",description:"Scales the shape.",defaultParams:{scaleX:1,scaleY:1},paramControls:[{id:"scaleX",label:"Scale X",type:"range",min:.01,max:5,step:.01},{id:"scaleY",label:"Scale Y",type:"range",min:.01,max:5,step:.01}]},{id:"translate",name:"Translate",type:"transform",description:"Moves the shape.",defaultParams:{translateX:0,translateY:0},paramControls:[{id:"translateX",label:"Translate X",type:"range",min:-1,max:1,step:.01},{id:"translateY",label:"Translate Y",type:"range",min:-1,max:1,step:.01}]},{id:"color",name:"Color",type:"color",description:"Changes the color of the shape with solid or rainbow modes.",defaultParams:{mode:"solid",r:255,g:255,b:255,cycleSpeed:0,rainbowSpread:1,rainbowOffset:0,rainbowPalette:"rainbow"},paramControls:[{id:"mode",label:"Mode",type:"select",options:["solid","rainbow"]},{id:"r",label:"Red",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"g",label:"Green",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"b",label:"Blue",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"cycleSpeed",label:"Cycle Speed",type:"range",min:0,max:10,step:.1},{id:"rainbowSpread",label:"Rainbow Spread",type:"range",min:.1,max:10,step:.1,showIf:{mode:"rainbow"}},{id:"rainbowOffset",label:"Rainbow Offset",type:"range",min:0,max:360,step:1,showIf:{mode:"rainbow"}},{id:"rainbowPalette",label:"Palette",type:"select",options:["rainbow","fire","ice","cyber"],showIf:{mode:"rainbow"}}]},{id:"wave",name:"Wave",type:"animation",description:"Applies a wave distortion to the shape.",defaultParams:{amplitude:.1,frequency:10,speed:1,direction:"x"},paramControls:[{id:"amplitude",label:"Amplitude",type:"range",min:.01,max:1,step:.01},{id:"frequency",label:"Frequency",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["x","y"]}]},{id:"warp",name:"Warp",type:"animation",description:"Symmetrical chaotic wave distortion.",defaultParams:{amount:.1,chaos:.5,speed:1},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"chaos",label:"Chaos",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1}]},{id:"distortion",name:"Distortion",type:"transform",description:"Distorts the point data.",defaultParams:{amount:.1,scale:10,speed:.5},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"scale",label:"Scale",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:5,step:.1}]},{id:"move",name:"Move (Bounce)",type:"transform",description:"Moves points and bounces them off the borders.",defaultParams:{speedX:.1,speedY:.1},paramControls:[{id:"speedX",label:"Speed X",type:"range",min:0,max:2,step:.01},{id:"speedY",label:"Speed Y",type:"range",min:0,max:2,step:.01}]},{id:"delay",name:"Delay",type:"effect",description:"Channel-based delay effect.",defaultParams:{useCustomOrder:!1,delayDirection:"left_to_right",delayAmount:5,decay:.8,customOrder:[]},paramControls:[{id:"useCustomOrder",label:"Custom Order",type:"checkbox"},{id:"delayDirection",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}},{id:"delayAmount",label:"Delay Time",type:"range",min:1,max:60,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01}]},{id:"chase",name:"Chase",type:"effect",description:"Step-based chase effect.",defaultParams:{steps:4,decay:.8,speed:1},paramControls:[{id:"steps",label:"Steps",type:"range",min:2,max:16,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:5,step:.1}]},{id:"blanking",name:"Blanking",type:"animation",description:"Controls the blanking of the laser output.",defaultParams:{blankingInterval:0},paramControls:[{id:"blankingInterval",label:"Blanking Interval",type:"range",min:0,max:10,step:1}]},{id:"strobe",name:"Strobe",type:"animation",description:"Applies a strobe effect to the laser output.",defaultParams:{strobeSpeed:100,strobeAmount:.5},paramControls:[{id:"strobeSpeed",label:"Strobe Speed (ms)",type:"range",min:10,max:1e3,step:10},{id:"strobeAmount",label:"Strobe Amount (0-1)",type:"range",min:0,max:1,step:.01}]},{id:"mirror",name:"Mirror",type:"transform",description:"Mirrors the shape from the center.",defaultParams:{mode:"none"},paramControls:[{id:"mode",label:"Mirror Mode",type:"select",options:["none","x+","x-","y+","y-"]}]}],C=(i,e)=>({...e,...i});function H(i,e,f={}){const{progress:o=0,time:n=performance.now(),effectStates:t,syncSettings:c={}}=f;if(!e||e.length===0)return i;let s;if(Array.isArray(i.points)){s=new Float32Array(i.points.length*8);for(let l=0;l<i.points.length;l++){const h=i.points[l],d=l*8;s[d]=h.x,s[d+1]=h.y,s[d+2]=h.z||0,s[d+3]=h.r,s[d+4]=h.g,s[d+5]=h.b,s[d+6]=h.blanking?1:0,s[d+7]=h.lastPoint?1:0}}else s=new Float32Array(i.points);let r=s;const a=()=>r.length/8;for(const l of e){if(!v.find(u=>u.id===l.id))continue;const d={...l.params};switch(l.id){case"rotate":Q(r,a(),d,o,n);break;case"scale":K(r,a(),d);break;case"translate":Z(r,a(),d);break;case"color":$(r,a(),d,n);break;case"wave":J(r,a(),d,n);break;case"blanking":ee(r,a(),d);break;case"strobe":te(r,a(),d,n);break;case"mirror":r=ae(r,a(),d);break;case"warp":re(r,a(),d,n);break;case"distortion":oe(r,a(),d,n);break;case"move":ne(r,a(),d,n);break;case"delay":t&&l.instanceId&&(r=se(r,a(),d,t,l.instanceId,f));break;case"chase":ie(r,a(),d,n);break}}return{...i,points:r,isTypedArray:!0}}function Q(i,e,f,o,n){const{angle:t,speed:c,direction:s}=C(f,v.find(u=>u.id==="rotate").defaultParams),r=s==="CCW"?-1:1,a=n*.001*c*r,l=t*Math.PI/180+a,h=Math.sin(l),d=Math.cos(l);for(let u=0;u<e;u++){const p=u*8,x=i[p],F=i[p+1];i[p]=x*d-F*h,i[p+1]=x*h+F*d}}function K(i,e,f){const{scaleX:o,scaleY:n}=C(f,v.find(t=>t.id==="scale").defaultParams);for(let t=0;t<e;t++){const c=t*8;i[c]*=o,i[c+1]*=n}}function Z(i,e,f){const{translateX:o,translateY:n}=C(f,v.find(t=>t.id==="translate").defaultParams);for(let t=0;t<e;t++){const c=t*8;i[c]+=o,i[c+1]+=n}}function $(i,e,f,o){const{mode:n,r:t,g:c,b:s,cycleSpeed:r,rainbowSpread:a,rainbowOffset:l,rainbowPalette:h}=C(f,v.find(u=>u.id==="color").defaultParams),d=o*.001*r;if(n==="rainbow"){const u=h||"rainbow";for(let p=0;p<e;p++){const x=p*8,F=(p/e*a+d*.5+l/360)%1;let y,w,S;u==="rainbow"?[y,w,S]=U(F,1,.5):[y,w,S]=j(u,F),i[x+3]=y,i[x+4]=w,i[x+5]=S}}else if(r>0){const u=d*50%360,[p,x,F]=U(u/360,1,.5);for(let y=0;y<e;y++){const w=y*8;i[w+3]=p,i[w+4]=x,i[w+5]=F}}else for(let u=0;u<e;u++){const p=u*8;i[p+3]=t,i[p+4]=c,i[p+5]=s}}function j(i,e){const f={fire:[{r:255,g:0,b:0},{r:255,g:128,b:0},{r:255,g:255,b:0},{r:255,g:0,b:0}],ice:[{r:0,g:0,b:255},{r:0,g:255,b:255},{r:255,g:255,b:255},{r:0,g:0,b:255}],cyber:[{r:255,g:0,b:255},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:255,g:0,b:255}]},o=f[i]||f.fire,n=e*(o.length-1),t=Math.floor(n),c=n-t,s=o[t],r=o[t+1]||o[t];return[Math.round(s.r+(r.r-s.r)*c),Math.round(s.g+(r.g-s.g)*c),Math.round(s.b+(r.b-s.b)*c)]}function U(i,e,f){let o,n,t;{const c=(a,l,h)=>(h<0&&(h+=1),h>1&&(h-=1),h<.16666666666666666?a+(l-a)*6*h:h<.5?l:h<.6666666666666666?a+(l-a)*(.6666666666666666-h)*6:a),s=f+e-f*e,r=2*f-s;o=c(r,s,i+1/3),n=c(r,s,i),t=c(r,s,i-1/3)}return[Math.round(o*255),Math.round(n*255),Math.round(t*255)]}function J(i,e,f,o){const{amplitude:n,frequency:t,speed:c,direction:s}=C(f,v.find(a=>a.id==="wave").defaultParams),r=o*.001*c;for(let a=0;a<e;a++){const l=a*8;s==="x"?i[l+1]+=n*Math.sin(i[l]*t+r):s==="y"&&(i[l]+=n*Math.sin(i[l+1]*t+r))}}function ee(i,e,f){const{blankingInterval:o}=C(f,v.find(n=>n.id==="blanking").defaultParams);if(!(o<=0))for(let n=0;n<e;n++)n%(o+1)===o&&(i[n*8+6]=1)}function te(i,e,f,o){const{strobeSpeed:n,strobeAmount:t}=C(f,v.find(s=>s.id==="strobe").defaultParams);if(o%n/n<t)for(let s=0;s<e;s++)i[s*8+6]=1}function ae(i,e,f){const{mode:o}=C(f,v.find(r=>r.id==="mirror").defaultParams);if(o==="none")return i;let n=[];for(let r=0;r<e;r++){const a=r*8,l=i[a],h=i[a+1];let d=!1;o==="x-"?l<=0&&(d=!0):o==="x+"?l>=0&&(d=!0):o==="y-"?h<=0&&(d=!0):o==="y+"&&h>=0&&(d=!0),d&&n.push({x:i[a],y:i[a+1],z:i[a+2],r:i[a+3],g:i[a+4],b:i[a+5],blk:i[a+6],last:i[a+7]})}const t=n.length*2,c=new Float32Array(t*8);let s=0;for(const r of n)c[s++]=r.x,c[s++]=r.y,c[s++]=r.z,c[s++]=r.r,c[s++]=r.g,c[s++]=r.b,c[s++]=r.blk,c[s++]=r.last;for(const r of n)o==="x-"||o==="x+"?c[s++]=-r.x:c[s++]=r.x,o==="y-"||o==="y+"?c[s++]=-r.y:c[s++]=r.y,c[s++]=r.z,c[s++]=r.r,c[s++]=r.g,c[s++]=r.b,c[s++]=r.blk,c[s++]=r.last;return c}function re(i,e,f,o){const{amount:n,chaos:t,speed:c}=C(f,v.find(r=>r.id==="warp").defaultParams),s=o*.001*c;for(let r=0;r<e;r++){const a=r*8,l=i[a],h=i[a+1],d=Math.abs(h);i[a]+=Math.sin(d*10*(1+t)+s)*n*Math.cos(s*t),i[a+1]+=Math.cos(Math.abs(l)*10*(1+t)+s)*n*Math.sin(s*t)}}function oe(i,e,f,o){const{amount:n,scale:t,speed:c}=C(f,v.find(r=>r.id==="distortion").defaultParams),s=o*.001*c;for(let r=0;r<e;r++){const a=r*8,l=Math.sin(i[a]*t+s)*Math.cos(i[a+1]*t-s),h=Math.cos(i[a]*t-s)*Math.sin(i[a+1]*t+s);i[a]+=l*n,i[a+1]+=h*n}}function ne(i,e,f,o){const{speedX:n,speedY:t}=C(f,v.find(l=>l.id==="move").defaultParams),c=o*.001,s=c*n,r=c*t,a=4;for(let l=0;l<e;l++){const h=l*8;let d=i[h]+s,u=i[h+1]+r,p=(d+1)%a;p<0&&(p+=a),p>2&&(p=4-p),d=p-1;let x=(u+1)%a;x<0&&(x+=a),x>2&&(x=4-x),u=x-1,i[h]=d,i[h+1]=u}}function se(i,e,f,o,n,t){const c=v.find(m=>m.id==="delay").defaultParams,{delayAmount:s,decay:r,useCustomOrder:a,delayDirection:l,customOrder:h}=C(f,c),d=a||f.delayMode==="channel"||f.delayMode===!0;o.has(n)||o.set(n,[]);const u=o.get(n),p=new Float32Array(i);u.unshift(p);const{assignedDacs:x}=t||{};let F=new Map,y=0;if(d){let m=[];h&&Array.isArray(h)&&h.length>0?m=h.map(g=>g.originalIndex!==void 0?g.originalIndex:0):x?m=x.map((g,b)=>b):m=[0],m.forEach((g,b)=>{F.set(g,b),y=Math.max(y,b)})}else{const g=(x||[]).length||1;for(let b=0;b<g;b++){let P=0;l==="right_to_left"?P=g-1-b:l==="center_to_out"?P=Math.floor(Math.abs(b-(g-1)/2)):l==="out_to_center"?P=Math.min(b,g-1-b):P=b,F.set(b,P),y=Math.max(y,P)}g===0&&F.set(0,0)}const w=y+1,S=s*w+1;u.length>S&&(u.length=S);const B=[];for(let m=0;m<w;m++){const g=m*s;let b=null;g===0?b=i:g<u.length&&(b=u[g]);const P=Math.pow(r,m);B.push({points:b,factor:P,index:m})}if(B.length===0)return i;const E=e+B.reduce((m,g)=>m+(g.points?g.points.length/8:i.length/8),0),M=new Float32Array(E*8);let R=0;const _=new Array(B.length);for(let m=0;m<B.length;m++){const g=B[m],b=g.points,P=b?b.length/8:i.length/8,Y=g.factor;_[m]=R;for(let D=0;D<P;D++){const L=D*8,I=R+D*8;let N=0,X=0,W=0,V=0,q=0,G=0,k=1,z=0;b?(N=b[L],X=b[L+1],W=b[L+2],V=b[L+3],q=b[L+4],G=b[L+5],k=b[L+6],z=b[L+7]):k=1,M[I]=N,M[I+1]=X,M[I+2]=W,M[I+3]=V*Y,M[I+4]=q*Y,M[I+5]=G*Y,M[I+6]=k,M[I+7]=z}R+=P*8}const A=new Map;return F.forEach((m,g)=>{if(m<B.length){const b=_[m],P=B[m].points?B[m].points.length:i.length;A.set(g,{start:b,length:P})}}),M._channelDistributions=A,M}function ie(i,e,f,o){const{steps:n,decay:t,speed:c}=C(f,v.find(l=>l.id==="chase").defaultParams),s=o*.001*c,r=Math.floor(s%n),a=e/n;for(let l=0;l<e;l++){const h=Math.floor(l/a),d=l*8;let u=Math.abs(h-r);u>n/2&&(u=n-u);let p=1;u>0&&(p=Math.pow(t,u)),i[d+3]*=p,i[d+4]*=p,i[d+5]*=p,p<.1&&(i[d+6]=1)}}function le(i,e){if(!e||!i||!i.points)return i;const{safetyZones:f,outputArea:o,transformationEnabled:n,transformationMode:t}=e;let c=i.points;const s=i.isTypedArray||c instanceof Float32Array,r=s?c.length/8:c.length;let a;s?a=new Float32Array(c):a=c.map(l=>({...l}));for(let l=0;l<r;l++){let h,d,u,p,x,F;if(s?(h=a[l*8],d=a[l*8+1],u=a[l*8+3],p=a[l*8+4],x=a[l*8+5],F=a[l*8+6]):(h=a[l].x,d=a[l].y,u=a[l].r,p=a[l].g,x=a[l].b,F=a[l].blanking?1:0),n&&o){let y=(h+1)/2,w=(1-d)/2;t==="crop"?(y<o.x||y>o.x+o.w||w<o.y||w>o.y+o.h)&&(u=0,p=0,x=0,F=1):t==="scale"&&(y=o.x+y*o.w,w=o.y+w*o.h,h=y*2-1,d=1-w*2)}if(f&&f.length>0){let y=(h+1)/2,w=(1-d)/2;for(const S of f)if(y>=S.x&&y<=S.x+S.w&&w>=S.y&&w<=S.y+S.h){u=0,p=0,x=0,F=1;break}}s?(a[l*8]=h,a[l*8+1]=d,a[l*8+3]=u,a[l*8+4]=p,a[l*8+5]=x,a[l*8+6]=F):(a[l].x=h,a[l].y=d,a[l].r=u,a[l].g=p,a[l].b=x,a[l].blanking=F>.5)}return{...i,points:a,isTypedArray:s}}class ce{constructor(e,f){if(this.canvas=e,this.type=f,this.gl=e.getContext("webgl")||e.getContext("experimental-webgl"),this.animationFrameId=null,this.frameIndexes=Array(10).fill(0),this.pointIndexes=Array(10).fill(0),this.showBeamEffect=!1,this.beamAlpha=.5,this.fadeAlpha=.13,this.beamRenderMode="lines",this.positionBuffer=null,this.colorBuffer=null,this.alphaBuffer=null,this.lastPointDrawTime=0,!this.gl){console.error("WebGL not supported");return}this.setup()}setup(){const e=this.gl,f=`
      attribute vec2 aPosition;
      attribute vec3 aColor;
      attribute float aAlpha;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        gl_PointSize = 2.0;
        vColor = aColor;
        vAlpha = aAlpha;
      }
    `,o=`
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(vColor, vAlpha);
      }
    `,n=this.createShader(e.VERTEX_SHADER,f),t=this.createShader(e.FRAGMENT_SHADER,o),c=this.createProgram(n,t);this.program=c,this.positionAttributeLocation=e.getAttribLocation(c,"aPosition"),this.colorAttributeLocation=e.getAttribLocation(c,"aColor"),this.alphaAttributeLocation=e.getAttribLocation(c,"aAlpha"),this.quadPositionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer);const s=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(s),e.STATIC_DRAW),this.quadColorUniformLocation=e.getUniformLocation(c,"uColor"),this.quadAlphaUniformLocation=e.getUniformLocation(c,"uAlpha");const r=`
      attribute vec2 aPosition;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `,a=`
      precision mediump float;
      uniform vec4 uColor;
      void main() {
        gl_FragColor = uColor;
      }
    `,l=this.createShader(e.VERTEX_SHADER,r),h=this.createShader(e.FRAGMENT_SHADER,a);this.fadeProgram=this.createProgram(l,h),this.fadePositionAttributeLocation=e.getAttribLocation(this.fadeProgram,"aPosition"),this.fadeColorUniformLocation=e.getUniformLocation(this.fadeProgram,"uColor"),e.useProgram(c);const d=131072;this.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.bufferData(e.ARRAY_BUFFER,d*2*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.colorBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.colorBuffer),e.bufferData(e.ARRAY_BUFFER,d*3*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.alphaBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.alphaBuffer),e.bufferData(e.ARRAY_BUFFER,d*1*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.clearColor(0,0,0,1)}reset(){this.frameIndexes.fill(0),this.pointIndexes.fill(0),this.clearCanvas()}createShader(e,f){const o=this.gl,n=o.createShader(e);if(o.shaderSource(n,f),o.compileShader(n),o.getShaderParameter(n,o.COMPILE_STATUS))return n;console.error(o.getShaderInfoLog(n)),o.deleteShader(n)}createProgram(e,f){const o=this.gl,n=o.createProgram();if(o.attachShader(n,e),o.attachShader(n,f),o.linkProgram(n),o.getProgramParameter(n,o.LINK_STATUS))return n;console.error(o.getProgramInfoLog(n)),o.deleteProgram(n)}render(e){e.showBeamEffect!==void 0&&this.setBeamEffect(e.showBeamEffect),e.beamAlpha!==void 0&&this.setBeamAlpha(e.beamAlpha),e.fadeAlpha!==void 0&&this.setFadeAlpha(e.fadeAlpha),e.beamRenderMode!==void 0&&(this.beamRenderMode=e.beamRenderMode),this.type==="world"?this.renderWorld(e.worldData,e.previewScanRate,e.layerIntensities,e.masterIntensity,e.dacSettings):this.renderSingle(e.ildaFrames,e.previewScanRate,e.intensity,e.effects,e.syncSettings)}renderSingle(e,f,o,n,t={}){const c=this.gl;if(c.viewport(0,0,c.canvas.width,c.canvas.height),this.drawFadeQuad(),!e||e.length===0)return;const s=this.frameIndexes[0]%e.length,r=e[s],a=s/e.length,l=performance.now();this.draw(r,n,this.showBeamEffect,this.beamAlpha,f,this.beamRenderMode,o,0,a,l,t),this.frameIndexes[0]++,this.frameIndexes[0]>=e.length&&(this.frameIndexes[0]=0)}renderWorld(e,f,o,n,t){const c=this.gl;c.viewport(0,0,c.canvas.width,c.canvas.height),this.drawFadeQuad();const s=performance.now();e.forEach(r=>{if(r&&r.frames&&r.frames.length>0){const a=r.frames[0];if(a){const l=r.layerIndex||0,h=r.syncSettings||{};if(l>=this.frameIndexes.length){const p=l+5;for(;this.frameIndexes.length<p;)this.frameIndexes.push(0),this.pointIndexes.push(0)}const u=(o[l]!==void 0?o[l]:1)*n;if(u>.001){const p=this.frameIndexes[l]%r.frames.length/r.frames.length;let x=a;if(t){let F=a;if(t.dimmer!==void 0&&t.dimmer<1){const y=a.points,w=a.isTypedArray||y instanceof Float32Array,S=w?y.length/8:y.length,B=w?new Float32Array(y):y.map(E=>({...E}));for(let E=0;E<S;E++)w?(B[E*8+3]*=t.dimmer,B[E*8+4]*=t.dimmer,B[E*8+5]*=t.dimmer):(B[E].r*=t.dimmer,B[E].g*=t.dimmer,B[E].b*=t.dimmer);F={...a,points:B,isTypedArray:w}}x=le(F,t)}this.draw(x,r.effects,this.showBeamEffect,this.beamAlpha,f,this.beamRenderMode,u,l,p,s,h)}}}}),e.forEach(r=>{if(r&&r.frames){const a=r.layerIndex||0;this.frameIndexes[a]++,this.frameIndexes[a]>=r.frames.length&&(this.frameIndexes[a]=0)}})}drawFadeQuad(){const e=this.gl;this.fadeProgram&&(e.useProgram(this.fadeProgram),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer),e.enableVertexAttribArray(this.fadePositionAttributeLocation),e.vertexAttribPointer(this.fadePositionAttributeLocation,2,e.FLOAT,!1,0,0),e.uniform4f(this.fadeColorUniformLocation,0,0,0,this.fadeAlpha),e.drawArrays(e.TRIANGLES,0,6))}setBeamEffect(e){this.showBeamEffect=e}setBeamAlpha(e){this.beamAlpha=e}setFadeAlpha(e){this.fadeAlpha=e}draw(e,f,o,n,t,c,s=1,r=0,a=0,l=performance.now(),h={}){if(this.gl,!e||!e.points)return;const d=(f||[]).map(R=>{const _={...R.params},A=v.find(m=>m.id===R.id);return A&&A.paramControls.forEach(m=>{const g=`${R.id}.${m.id}`,b=h[g];if(b&&(m.type==="range"||m.type==="number")){let P=0;b==="fps"?P=l*.001%1:(b==="timeline"||b==="bpm")&&(P=a),_[m.id]=m.min+(m.max-m.min)*P}}),{...R,params:_}}),u=H(e,d,{progress:a,time:l}),p=u.points,x=u.isTypedArray,F=x?p.length/8:p.length;if(F===0)return;const y=Math.max(1,Math.floor(F/t));let w=this.pointIndexes[r]||0;w>=F&&(w=0);const S=R=>{const _=(w+R)%F;if(x){const A=_*8;return{x:p[A],y:p[A+1],r:p[A+3],g:p[A+4],b:p[A+5],blanking:p[A+6]===1}}else{const A=p[_];return{x:A.x,y:A.y,r:A.r,g:A.g,b:A.b,blanking:A.blanking}}},B=()=>{let R=[],_=[];for(let A=0;A<y;A++){const m=S(A);if(m.blanking){R.length>0&&(this._drawSegment(new Float32Array(R),new Float32Array(_),1,R.length/2),R=[],_=[]);continue}R.push(m.x,m.y),_.push(m.r/255*s,m.g/255*s,m.b/255*s)}R.length>0&&this._drawSegment(new Float32Array(R),new Float32Array(_),1,R.length/2)},E=()=>{const R=[],_=[];for(let A=0;A<y;A++){const m=S(A);if(!m.blanking){R.push(0,0,m.x,m.y);const g=[m.r/255*s,m.g/255*s,m.b/255*s];_.push(...g,...g)}}R.length>0&&this._drawLines(new Float32Array(R),new Float32Array(_),n,R.length/2)},M=()=>{const R=[],_=[];let A=S(0);for(let m=1;m<y;m++){const g=S(m);if(!A.blanking&&!g.blanking){R.push(0,0,A.x,A.y,g.x,g.y);const b=[A.r/255*s,A.g/255*s,A.b/255*s],P=[g.r/255*s,g.g/255*s,g.b/255*s],Y=[(b[0]+P[0])/2,(b[1]+P[1])/2,(b[2]+P[2])/2];_.push(...Y,...b,...P)}A=g}R.length>0&&this._drawTriangles(new Float32Array(R),new Float32Array(_),n,R.length/2)};B(),o&&(c==="points"?E():c==="lines"?M():c==="both"&&(M(),E())),this.pointIndexes[r]=(w+y)%F}_drawSegment(e,f,o,n){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,f),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(n).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINE_STRIP,0,n)}_drawLines(e,f,o,n){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,f),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(n).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINES,0,n)}_drawTriangles(e,f,o,n){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,f),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(n).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLES,0,n)}clearCanvas(){const e=this.gl;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT)}destroy(){cancelAnimationFrame(this.animationFrameId)}}const T=new Map;function O(i,e=0){const f=T.get(i);if(!f)return;const o=performance.now();f.renderer.render(f.data),e=o,f.animationFrameId=requestAnimationFrame(()=>O(i,e))}self.onmessage=i=>{const{action:e,payload:f}=i.data;if(e==="register"){const{id:o,canvas:n,type:t,data:c}=f,s=new ce(n,t),r=requestAnimationFrame(()=>O(o));T.set(o,{renderer:s,type:t,data:c,animationFrameId:r})}else if(e==="deregister"){const{id:o}=f,n=T.get(o);n&&(cancelAnimationFrame(n.animationFrameId),T.delete(o))}else if(e==="update"){const{id:o,data:n}=f,t=T.get(o);t&&(t.data=n)}else if(e==="clear"){const{id:o}=f,n=T.get(o);n&&n.renderer.clearCanvas()}}})();
