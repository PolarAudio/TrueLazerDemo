(function(){"use strict";const E=[{id:"rotate",name:"Rotate",type:"transform",description:"Rotates the shape around its center.",defaultParams:{angle:0,speed:0,direction:"CW"},paramControls:[{id:"angle",label:"Angle",type:"range",min:0,max:360,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["CW","CCW"]}]},{id:"scale",name:"Scale",type:"transform",description:"Scales the shape.",defaultParams:{scaleX:1,scaleY:1},paramControls:[{id:"scaleX",label:"Scale X",type:"range",min:.01,max:5,step:.01},{id:"scaleY",label:"Scale Y",type:"range",min:.01,max:5,step:.01}]},{id:"translate",name:"Translate",type:"transform",description:"Moves the shape.",defaultParams:{translateX:0,translateY:0},paramControls:[{id:"translateX",label:"Translate X",type:"range",min:-1,max:1,step:.01},{id:"translateY",label:"Translate Y",type:"range",min:-1,max:1,step:.01}]},{id:"color",name:"Color",type:"color",description:"Changes the color of the shape with solid or rainbow modes.",defaultParams:{mode:"solid",r:255,g:255,b:255,cycleSpeed:0,rainbowSpread:1,rainbowOffset:0,rainbowPalette:"rainbow"},paramControls:[{id:"mode",label:"Mode",type:"select",options:["solid","rainbow"]},{id:"r",label:"Red",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"g",label:"Green",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"b",label:"Blue",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"cycleSpeed",label:"Cycle Speed",type:"range",min:0,max:10,step:.1},{id:"rainbowSpread",label:"Rainbow Spread",type:"range",min:.1,max:10,step:.1,showIf:{mode:"rainbow"}},{id:"rainbowOffset",label:"Rainbow Offset",type:"range",min:0,max:360,step:1,showIf:{mode:"rainbow"}},{id:"rainbowPalette",label:"Palette",type:"select",options:["rainbow","fire","ice","cyber"],showIf:{mode:"rainbow"}}]},{id:"wave",name:"Wave",type:"animation",description:"Applies a wave distortion to the shape.",defaultParams:{amplitude:.1,frequency:10,speed:1,direction:"x"},paramControls:[{id:"amplitude",label:"Amplitude",type:"range",min:.01,max:1,step:.01},{id:"frequency",label:"Frequency",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["x","y"]}]},{id:"warp",name:"Warp",type:"animation",description:"Symmetrical chaotic wave distortion.",defaultParams:{amount:.1,chaos:.5,speed:1},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"chaos",label:"Chaos",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1}]},{id:"distortion",name:"Distortion",type:"transform",description:"Distorts the point data.",defaultParams:{amount:.1,scale:10,speed:.5},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"scale",label:"Scale",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:5,step:.1}]},{id:"move",name:"Move (Bounce)",type:"transform",description:"Moves points and bounces them off the borders.",defaultParams:{speedX:.1,speedY:.1},paramControls:[{id:"speedX",label:"Speed X",type:"range",min:0,max:2,step:.01},{id:"speedY",label:"Speed Y",type:"range",min:0,max:2,step:.01}]},{id:"delay",name:"Delay",type:"effect",description:"Channel-based delay effect.",defaultParams:{useCustomOrder:!1,delayDirection:"left_to_right",delayAmount:5,decay:.8,customOrder:[]},paramControls:[{id:"useCustomOrder",label:"Custom Order",type:"checkbox"},{id:"delayDirection",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}},{id:"delayAmount",label:"Delay Time",type:"range",min:1,max:60,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01}]},{id:"chase",name:"Chase",type:"effect",description:"Step-based chase effect.",defaultParams:{steps:4,decay:.8,speed:1,overlap:1,direction:"left_to_right",useCustomOrder:!1,customOrder:[]},paramControls:[{id:"steps",label:"Steps",type:"range",min:2,max:16,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:5,step:.1},{id:"overlap",label:"Overlap",type:"range",min:1,max:4,step:1},{id:"useCustomOrder",label:"Custom Order",type:"checkbox"},{id:"direction",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}}]},{id:"blanking",name:"Blanking",type:"animation",description:"Controls the blanking of the laser output.",defaultParams:{blankingInterval:0},paramControls:[{id:"blankingInterval",label:"Blanking Interval",type:"range",min:0,max:10,step:1}]},{id:"strobe",name:"Strobe",type:"animation",description:"Applies a strobe effect to the laser output.",defaultParams:{strobeSpeed:100,strobeAmount:.5},paramControls:[{id:"strobeSpeed",label:"Strobe Speed (ms)",type:"range",min:10,max:1e3,step:10},{id:"strobeAmount",label:"Strobe Amount (0-1)",type:"range",min:0,max:1,step:.01}]},{id:"mirror",name:"Mirror",type:"transform",description:"Mirrors the shape from the center.",defaultParams:{mode:"none"},paramControls:[{id:"mode",label:"Mirror Mode",type:"select",options:["none","x+","x-","y+","y-"]}]}],C=(o,e)=>({...e,...o});function H(o,e,d,n){if(!d)return e;const a=typeof d=="string"?{syncMode:d}:d;if(!a.syncMode)return e;const{time:t,progress:c=0,bpm:s=120,clipDuration:r=0}=n;let i=0;const p=a.speedMultiplier||1;if(a.syncMode==="fps")i=t*.001*p;else if(a.syncMode==="timeline"){const x=Math.max(.01,a.duration||1);r>0?i=c*r/x*p:i=0}else if(a.syncMode==="bpm"){const x=Math.max(.1,a.beats||4),A=s/60,_=x/(A||2);r>0?i=c*r/_*p:i=0}const f=a.direction||"forward";if(f==="pause")return e;const l=a.style||"loop";let h=0;if(l==="once")h=Math.min(i,1),f==="backward"&&(h=1-h);else if(l==="bounce"){let x=i%1;Math.floor(i)%2===1?h=1-x:h=x,f==="backward"&&(h=1-h)}else h=i%1,f==="backward"&&(h=1-h);const u=a.range;let y=0,S=1;if(u&&Array.isArray(u)&&u.length===2)y=u[0],S=u[1];else return e;return y+(S-y)*h}function Q(o,e,d={}){const{progress:n=0,time:a=performance.now(),effectStates:t,syncSettings:c={}}=d;if(!e||e.length===0)return o;let s;if(Array.isArray(o.points)){s=new Float32Array(o.points.length*8);for(let p=0;p<o.points.length;p++){const f=o.points[p],l=p*8;s[l]=f.x,s[l+1]=f.y,s[l+2]=f.z||0,s[l+3]=f.r,s[l+4]=f.g,s[l+5]=f.b,s[l+6]=f.blanking?1:0,s[l+7]=f.lastPoint?1:0}}else s=new Float32Array(o.points);let r=s;const i=()=>r.length/8;for(const p of e){if(!E.find(h=>h.id===p.id))continue;const l={...p.params};for(const h of Object.keys(l)){const u=`${p.id}.${h}`;c[u]&&(l[h]=H(h,l[h],c[u],d))}switch(p.id){case"rotate":K(r,i(),l,n,a);break;case"scale":Z(r,i(),l);break;case"translate":$(r,i(),l);break;case"color":j(r,i(),l,a);break;case"wave":ee(r,i(),l,a);break;case"blanking":te(r,i(),l);break;case"strobe":re(r,i(),l,a);break;case"mirror":r=ae(r,i(),l);break;case"warp":oe(r,i(),l,a);break;case"distortion":ne(r,i(),l,a);break;case"move":se(r,i(),l,a);break;case"delay":t&&p.instanceId&&(r=ie(r,i(),l,t,p.instanceId,d));break;case"chase":r=le(r,i(),l,a,d);break}}return{...o,points:r,isTypedArray:!0}}function K(o,e,d,n,a){const{angle:t,speed:c,direction:s}=C(d,E.find(h=>h.id==="rotate").defaultParams),r=s==="CCW"?-1:1,i=a*.001*c*r,p=t*Math.PI/180+i,f=Math.sin(p),l=Math.cos(p);for(let h=0;h<e;h++){const u=h*8,y=o[u],S=o[u+1];o[u]=y*l-S*f,o[u+1]=y*f+S*l}}function Z(o,e,d){const{scaleX:n,scaleY:a}=C(d,E.find(t=>t.id==="scale").defaultParams);for(let t=0;t<e;t++){const c=t*8;o[c]*=n,o[c+1]*=a}}function $(o,e,d){const{translateX:n,translateY:a}=C(d,E.find(t=>t.id==="translate").defaultParams);for(let t=0;t<e;t++){const c=t*8;o[c]+=n,o[c+1]+=a}}function j(o,e,d,n){const{mode:a,r:t,g:c,b:s,cycleSpeed:r,rainbowSpread:i,rainbowOffset:p,rainbowPalette:f}=C(d,E.find(h=>h.id==="color").defaultParams),l=n*.001*r;if(a==="rainbow"){const h=f||"rainbow";for(let u=0;u<e;u++){const y=u*8,S=(u/e*i+l*.5+p/360)%1;let x,A,_;h==="rainbow"?[x,A,_]=O(S,1,.5):[x,A,_]=J(h,S),o[y+3]=x,o[y+4]=A,o[y+5]=_}}else if(r>0){const h=l*50%360,[u,y,S]=O(h/360,1,.5);for(let x=0;x<e;x++){const A=x*8;o[A+3]=u,o[A+4]=y,o[A+5]=S}}else for(let h=0;h<e;h++){const u=h*8;o[u+3]=t,o[u+4]=c,o[u+5]=s}}function J(o,e){const d={fire:[{r:255,g:0,b:0},{r:255,g:128,b:0},{r:255,g:255,b:0},{r:255,g:0,b:0}],ice:[{r:0,g:0,b:255},{r:0,g:255,b:255},{r:255,g:255,b:255},{r:0,g:0,b:255}],cyber:[{r:255,g:0,b:255},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:255,g:0,b:255}]},n=d[o]||d.fire,a=e*(n.length-1),t=Math.floor(a),c=a-t,s=n[t],r=n[t+1]||n[t];return[Math.round(s.r+(r.r-s.r)*c),Math.round(s.g+(r.g-s.g)*c),Math.round(s.b+(r.b-s.b)*c)]}function O(o,e,d){let n,a,t;{const c=(i,p,f)=>(f<0&&(f+=1),f>1&&(f-=1),f<.16666666666666666?i+(p-i)*6*f:f<.5?p:f<.6666666666666666?i+(p-i)*(.6666666666666666-f)*6:i),s=d+e-d*e,r=2*d-s;n=c(r,s,o+1/3),a=c(r,s,o),t=c(r,s,o-1/3)}return[Math.round(n*255),Math.round(a*255),Math.round(t*255)]}function ee(o,e,d,n){const{amplitude:a,frequency:t,speed:c,direction:s}=C(d,E.find(i=>i.id==="wave").defaultParams),r=n*.001*c;for(let i=0;i<e;i++){const p=i*8;s==="x"?o[p+1]+=a*Math.sin(o[p]*t+r):s==="y"&&(o[p]+=a*Math.sin(o[p+1]*t+r))}}function te(o,e,d){const{blankingInterval:n}=C(d,E.find(a=>a.id==="blanking").defaultParams);if(!(n<=0))for(let a=0;a<e;a++)a%(n+1)===n&&(o[a*8+6]=1)}function re(o,e,d,n){const{strobeSpeed:a,strobeAmount:t}=C(d,E.find(s=>s.id==="strobe").defaultParams);if(n%a/a<t)for(let s=0;s<e;s++)o[s*8+6]=1}function ae(o,e,d){const{mode:n}=C(d,E.find(r=>r.id==="mirror").defaultParams);if(n==="none")return o;let a=[];for(let r=0;r<e;r++){const i=r*8,p=o[i],f=o[i+1];let l=!1;n==="x-"?p<=0&&(l=!0):n==="x+"?p>=0&&(l=!0):n==="y-"?f<=0&&(l=!0):n==="y+"&&f>=0&&(l=!0),l&&a.push({x:o[i],y:o[i+1],z:o[i+2],r:o[i+3],g:o[i+4],b:o[i+5],blk:o[i+6],last:o[i+7]})}const t=a.length*2,c=new Float32Array(t*8);let s=0;for(const r of a)c[s++]=r.x,c[s++]=r.y,c[s++]=r.z,c[s++]=r.r,c[s++]=r.g,c[s++]=r.b,c[s++]=r.blk,c[s++]=r.last;for(const r of a)n==="x-"||n==="x+"?c[s++]=-r.x:c[s++]=r.x,n==="y-"||n==="y+"?c[s++]=-r.y:c[s++]=r.y,c[s++]=r.z,c[s++]=r.r,c[s++]=r.g,c[s++]=r.b,c[s++]=r.blk,c[s++]=r.last;return c}function oe(o,e,d,n){const{amount:a,chaos:t,speed:c}=C(d,E.find(r=>r.id==="warp").defaultParams),s=n*.001*c;for(let r=0;r<e;r++){const i=r*8,p=o[i],f=o[i+1],l=Math.abs(f);o[i]+=Math.sin(l*10*(1+t)+s)*a*Math.cos(s*t),o[i+1]+=Math.cos(Math.abs(p)*10*(1+t)+s)*a*Math.sin(s*t)}}function ne(o,e,d,n){const{amount:a,scale:t,speed:c}=C(d,E.find(r=>r.id==="distortion").defaultParams),s=n*.001*c;for(let r=0;r<e;r++){const i=r*8,p=Math.sin(o[i]*t+s)*Math.cos(o[i+1]*t-s),f=Math.cos(o[i]*t-s)*Math.sin(o[i+1]*t+s);o[i]+=p*a,o[i+1]+=f*a}}function se(o,e,d,n){const{speedX:a,speedY:t}=C(d,E.find(p=>p.id==="move").defaultParams),c=n*.001,s=c*a,r=c*t,i=4;for(let p=0;p<e;p++){const f=p*8;let l=o[f]+s,h=o[f+1]+r,u=(l+1)%i;u<0&&(u+=i),u>2&&(u=4-u),l=u-1;let y=(h+1)%i;y<0&&(y+=i),y>2&&(y=4-y),h=y-1,o[f]=l,o[f+1]=h}}function ie(o,e,d,n,a,t){const c=E.find(m=>m.id==="delay").defaultParams,{delayAmount:s,decay:r,useCustomOrder:i,delayDirection:p,customOrder:f}=C(d,c),l=i||d.delayMode==="channel"||d.delayMode===!0;n.has(a)||n.set(a,[]);const h=n.get(a),u=new Float32Array(o);h.unshift(u);const{assignedDacs:y}=t||{};let S=new Map,x=0;if(l){let m=[];f&&Array.isArray(f)&&f.length>0?m=f.map(g=>g.originalIndex!==void 0?g.originalIndex:0):y?m=y.map((g,b)=>b):m=[0],m.forEach((g,b)=>{S.set(g,b),x=Math.max(x,b)})}else{const g=(y||[]).length||1;for(let b=0;b<g;b++){let B=0;p==="right_to_left"?B=g-1-b:p==="center_to_out"?B=Math.floor(Math.abs(b-(g-1)/2)):p==="out_to_center"?B=Math.min(b,g-1-b):B=b,S.set(b,B),x=Math.max(x,B)}g===0&&S.set(0,0)}const A=x+1,_=s*A+1;h.length>_&&(h.length=_);const F=[];for(let m=0;m<A;m++){const g=m*s;let b=null;g===0?b=o:g<h.length&&(b=h[g]);const B=Math.pow(r,m);F.push({points:b,factor:B,index:m})}if(F.length===0)return o;const M=e+F.reduce((m,g)=>m+(g.points?g.points.length/8:o.length/8),0),P=new Float32Array(M*8);let R=0;const w=new Array(F.length);for(let m=0;m<F.length;m++){const g=F[m],b=g.points,B=b?b.length/8:o.length/8,I=g.factor;w[m]=R;for(let k=0;k<B;k++){const L=k*8,D=R+k*8;let N=0,X=0,W=0,V=0,q=0,G=0,Y=1,z=0;b?(N=b[L],X=b[L+1],W=b[L+2],V=b[L+3],q=b[L+4],G=b[L+5],Y=b[L+6],z=b[L+7]):Y=1,P[D]=N,P[D+1]=X,P[D+2]=W,P[D+3]=V*I,P[D+4]=q*I,P[D+5]=G*I,P[D+6]=Y,P[D+7]=z}R+=B*8}const v=new Map;return S.forEach((m,g)=>{if(m<F.length){const b=w[m],B=F[m].points?F[m].points.length:o.length;v.set(g,{start:b,length:B})}}),P._channelDistributions=v,P}function le(o,e,d,n,a={}){e=Math.floor(e);const{decay:t,speed:c,overlap:s,direction:r,useCustomOrder:i,customOrder:p}=C(d,E.find(P=>P.id==="chase").defaultParams),{assignedDacs:f}=a||{};let l=new Map,h=0;if(i){let P=[];p&&Array.isArray(p)&&p.length>0?P=p.map(R=>R.originalIndex!==void 0?R.originalIndex:0):f?P=f.map((R,w)=>w):P=[0],P.forEach((R,w)=>{l.set(R,w),h++})}else{h=(f||[]).length||1;for(let R=0;R<h;R++){let w=R;r==="right_to_left"?w=h-1-R:r==="center_to_out"?w=Math.floor(Math.abs(R-(h-1)/2)):r==="out_to_center"&&(w=Math.min(R,h-1-R)),l.set(R,w)}}h===0&&(h=1);const u=h,y=n*.001*c%u,x=e*h,A=new Float32Array(x*8),_=new Map;let F=0;const M=Array.from(l.keys());M.length===0&&M.push(0);for(const P of M){const R=l.get(P)||0;let w=Math.abs(y-R);w>u/2&&(w=u-w);let v=0;w<s&&(v=1-w/s,v=Math.max(0,v),t>0&&(v=Math.pow(v,1-t)));const m=F;for(let g=0;g<e;g++){const b=g*8,B=F+g*8;A[B]=o[b],A[B+1]=o[b+1],A[B+2]=o[b+2]||0,A[B+3]=o[b+3]*v,A[B+4]=o[b+4]*v,A[B+5]=o[b+5]*v,A[B+6]=v<.05?1:o[b+6],A[B+7]=o[b+7]}_.set(P,{start:m,length:e}),F+=e*8}return A._channelDistributions=_,A}function ce(o,e){if(!e||!o||!o.points)return o;const{safetyZones:d,outputArea:n,transformationEnabled:a,transformationMode:t,flipX:c,flipY:s}=e;let r=o.points;const i=o.isTypedArray||r instanceof Float32Array,p=i?r.length/8:r.length;let f;i?f=new Float32Array(r):f=r.map(l=>({...l}));for(let l=0;l<p;l++){let h,u,y,S,x,A;if(i?(h=f[l*8],u=f[l*8+1],y=f[l*8+3],S=f[l*8+4],x=f[l*8+5],A=f[l*8+6]):(h=f[l].x,u=f[l].y,y=f[l].r,S=f[l].g,x=f[l].b,A=f[l].blanking?1:0),c&&(h=-h),s&&(u=-u),a&&n){let _=(h+1)/2,F=(1-u)/2;t==="crop"?(_<n.x||_>n.x+n.w||F<n.y||F>n.y+n.h)&&(y=0,S=0,x=0,A=1):t==="scale"&&(_=n.x+_*n.w,F=n.y+F*n.h,h=_*2-1,u=1-F*2)}if(d&&d.length>0){let _=(h+1)/2,F=(1-u)/2;for(const M of d)if(_>=M.x&&_<=M.x+M.w&&F>=M.y&&F<=M.y+M.h){y=0,S=0,x=0,A=1;break}}i?(f[l*8]=h,f[l*8+1]=u,f[l*8+3]=y,f[l*8+4]=S,f[l*8+5]=x,f[l*8+6]=A):(f[l].x=h,f[l].y=u,f[l].r=y,f[l].g=S,f[l].b=x,f[l].blanking=A>.5)}return{...o,points:f,isTypedArray:i}}class fe{constructor(e,d){if(this.canvas=e,this.type=d,this.gl=e.getContext("webgl")||e.getContext("experimental-webgl"),this.animationFrameId=null,this.frameIndexes=Array(10).fill(0),this.pointIndexes=Array(10).fill(0),this.showBeamEffect=!1,this.beamAlpha=.5,this.fadeAlpha=.13,this.beamRenderMode="lines",this.positionBuffer=null,this.colorBuffer=null,this.alphaBuffer=null,this.lastPointDrawTime=0,!this.gl){console.error("WebGL not supported");return}this.setup()}setup(){const e=this.gl,d=`
      attribute vec2 aPosition;
      attribute vec3 aColor;
      attribute float aAlpha;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        gl_PointSize = 2.0;
        vColor = aColor;
        vAlpha = aAlpha;
      }
    `,n=`
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(vColor, vAlpha);
      }
    `,a=this.createShader(e.VERTEX_SHADER,d),t=this.createShader(e.FRAGMENT_SHADER,n),c=this.createProgram(a,t);this.program=c,this.positionAttributeLocation=e.getAttribLocation(c,"aPosition"),this.colorAttributeLocation=e.getAttribLocation(c,"aColor"),this.alphaAttributeLocation=e.getAttribLocation(c,"aAlpha"),this.quadPositionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer);const s=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(s),e.STATIC_DRAW),this.quadColorUniformLocation=e.getUniformLocation(c,"uColor"),this.quadAlphaUniformLocation=e.getUniformLocation(c,"uAlpha");const r=`
      attribute vec2 aPosition;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `,i=`
      precision mediump float;
      uniform vec4 uColor;
      void main() {
        gl_FragColor = uColor;
      }
    `,p=this.createShader(e.VERTEX_SHADER,r),f=this.createShader(e.FRAGMENT_SHADER,i);this.fadeProgram=this.createProgram(p,f),this.fadePositionAttributeLocation=e.getAttribLocation(this.fadeProgram,"aPosition"),this.fadeColorUniformLocation=e.getUniformLocation(this.fadeProgram,"uColor"),e.useProgram(c);const l=131072;this.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.bufferData(e.ARRAY_BUFFER,l*2*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.colorBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.colorBuffer),e.bufferData(e.ARRAY_BUFFER,l*3*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.alphaBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.alphaBuffer),e.bufferData(e.ARRAY_BUFFER,l*1*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.clearColor(0,0,0,1)}reset(){this.frameIndexes.fill(0),this.pointIndexes.fill(0),this.clearCanvas()}createShader(e,d){const n=this.gl,a=n.createShader(e);if(n.shaderSource(a,d),n.compileShader(a),n.getShaderParameter(a,n.COMPILE_STATUS))return a;console.error(n.getShaderInfoLog(a)),n.deleteShader(a)}createProgram(e,d){const n=this.gl,a=n.createProgram();if(n.attachShader(a,e),n.attachShader(a,d),n.linkProgram(a),n.getProgramParameter(a,n.LINK_STATUS))return a;console.error(n.getProgramInfoLog(a)),n.deleteProgram(a)}render(e){e.showBeamEffect!==void 0&&this.setBeamEffect(e.showBeamEffect),e.beamAlpha!==void 0&&this.setBeamAlpha(e.beamAlpha),e.fadeAlpha!==void 0&&this.setFadeAlpha(e.fadeAlpha),e.beamRenderMode!==void 0&&(this.beamRenderMode=e.beamRenderMode),this.type==="world"?this.renderWorld(e.worldData,e.previewScanRate,e.layerIntensities,e.masterIntensity,e.dacSettings):this.renderSingle(e.ildaFrames,e.previewScanRate,e.intensity,e.effects,e.syncSettings,e.bpm,e.clipDuration)}renderSingle(e,d,n,a,t={},c=120,s=1){const r=this.gl;if(r.viewport(0,0,r.canvas.width,r.canvas.height),this.drawFadeQuad(),!e||e.length===0)return;const i=this.frameIndexes[0]%e.length,p=e[i],f=i/e.length,l=performance.now();this.draw(p,a,this.showBeamEffect,this.beamAlpha,d,this.beamRenderMode,n,0,f,l,t,c,s),this.frameIndexes[0]++,this.frameIndexes[0]>=e.length&&(this.frameIndexes[0]=0)}renderWorld(e,d,n,a,t){const c=this.gl;c.viewport(0,0,c.canvas.width,c.canvas.height),this.drawFadeQuad();const s=performance.now();e.forEach(r=>{if(r&&r.frames&&r.frames.length>0){const i=r.frames[0];if(i){const p=r.layerIndex||0;if(r.syncSettings,r.bpm,p>=this.frameIndexes.length){const h=p+5;for(;this.frameIndexes.length<h;)this.frameIndexes.push(0),this.pointIndexes.push(0)}const l=(n[p]!==void 0?n[p]:1)*a;if(l>.001){const h=this.frameIndexes[p]%r.frames.length/r.frames.length,{syncSettings:u={},bpm:y=120,clipDuration:S=1}=r;let x=i;if(t){let A=i;if(t.dimmer!==void 0&&t.dimmer<1){const _=i.points,F=i.isTypedArray||_ instanceof Float32Array,M=F?_.length/8:_.length,P=F?new Float32Array(_):_.map(R=>({...R}));for(let R=0;R<M;R++)F?(P[R*8+3]*=t.dimmer,P[R*8+4]*=t.dimmer,P[R*8+5]*=t.dimmer):(P[R].r*=t.dimmer,P[R].g*=t.dimmer,P[R].b*=t.dimmer);A={...i,points:P,isTypedArray:F}}x=ce(A,t)}this.draw(x,r.effects,this.showBeamEffect,this.beamAlpha,d,this.beamRenderMode,l,p,h,s,u,y,S)}}}}),e.forEach(r=>{if(r&&r.frames){const i=r.layerIndex||0;this.frameIndexes[i]++,this.frameIndexes[i]>=r.frames.length&&(this.frameIndexes[i]=0)}})}drawFadeQuad(){const e=this.gl;this.fadeProgram&&(e.useProgram(this.fadeProgram),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer),e.enableVertexAttribArray(this.fadePositionAttributeLocation),e.vertexAttribPointer(this.fadePositionAttributeLocation,2,e.FLOAT,!1,0,0),e.uniform4f(this.fadeColorUniformLocation,0,0,0,this.fadeAlpha),e.drawArrays(e.TRIANGLES,0,6))}setBeamEffect(e){this.showBeamEffect=e}setBeamAlpha(e){this.beamAlpha=e}setFadeAlpha(e){this.fadeAlpha=e}draw(e,d,n,a,t,c,s=1,r=0,i=0,p=performance.now(),f={},l=120,h=1){if(this.gl,!e||!e.points)return;const u=Q(e,d,{progress:i,time:p,syncSettings:f,bpm:l,clipDuration:h}),y=u.points,S=u.isTypedArray,x=S?y.length/8:y.length;if(x===0)return;const A=Math.max(1,Math.floor(x/t));let _=this.pointIndexes[r]||0;_>=x&&(_=0);const F=w=>{const v=(_+w)%x;if(S){const m=v*8;return{x:y[m],y:y[m+1],r:y[m+3],g:y[m+4],b:y[m+5],blanking:y[m+6]===1}}else{const m=y[v];return{x:m.x,y:m.y,r:m.r,g:m.g,b:m.b,blanking:m.blanking}}},M=()=>{let w=[],v=[];for(let m=0;m<A;m++){const g=F(m);if(g.blanking){w.length>0&&(this._drawSegment(new Float32Array(w),new Float32Array(v),1,w.length/2),w=[],v=[]);continue}w.push(g.x,g.y),v.push(g.r/255*s,g.g/255*s,g.b/255*s)}w.length>0&&this._drawSegment(new Float32Array(w),new Float32Array(v),1,w.length/2)},P=()=>{const w=[],v=[];for(let m=0;m<A;m++){const g=F(m);if(!g.blanking){w.push(0,0,g.x,g.y);const b=[g.r/255*s,g.g/255*s,g.b/255*s];v.push(...b,...b)}}w.length>0&&this._drawLines(new Float32Array(w),new Float32Array(v),a,w.length/2)},R=()=>{const w=[],v=[];let m=F(0);for(let g=1;g<A;g++){const b=F(g);if(!m.blanking&&!b.blanking){w.push(0,0,m.x,m.y,b.x,b.y);const B=[m.r/255*s,m.g/255*s,m.b/255*s],I=[b.r/255*s,b.g/255*s,b.b/255*s],k=[(B[0]+I[0])/2,(B[1]+I[1])/2,(B[2]+I[2])/2];v.push(...k,...B,...I)}m=b}w.length>0&&this._drawTriangles(new Float32Array(w),new Float32Array(v),a,w.length/2)};M(),n&&(c==="points"?P():c==="lines"?R():c==="both"&&(R(),P())),this.pointIndexes[r]=(_+A)%x}_drawSegment(e,d,n,a){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,d),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(a).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINE_STRIP,0,a)}_drawLines(e,d,n,a){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,d),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(a).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINES,0,a)}_drawTriangles(e,d,n,a){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,d),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(a).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLES,0,a)}clearCanvas(){const e=this.gl;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT)}destroy(){cancelAnimationFrame(this.animationFrameId)}}const T=new Map;function U(o,e=0){const d=T.get(o);if(!d)return;const n=performance.now();d.renderer.render(d.data),e=n,d.animationFrameId=requestAnimationFrame(()=>U(o,e))}self.onmessage=o=>{const{action:e,payload:d}=o.data;if(e==="register"){const{id:n,canvas:a,type:t,data:c}=d,s=new fe(a,t),r=requestAnimationFrame(()=>U(n));T.set(n,{renderer:s,type:t,data:c,animationFrameId:r})}else if(e==="deregister"){const{id:n}=d,a=T.get(n);a&&(cancelAnimationFrame(a.animationFrameId),T.delete(n))}else if(e==="update"){const{id:n,data:a}=d,t=T.get(n);t&&(t.data=a)}else if(e==="clear"){const{id:n}=d,a=T.get(n);a&&a.renderer.clearCanvas()}}})();
