(function(){"use strict";const I=[{id:"rotate",name:"Rotate",type:"transform",description:"Rotates the shape around its center.",defaultParams:{angle:0,speed:0,direction:"CW"},paramControls:[{id:"angle",label:"Angle",type:"range",min:0,max:360,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["CW","CCW"]}]},{id:"scale",name:"Scale",type:"transform",description:"Scales the shape.",defaultParams:{scaleX:1,scaleY:1},paramControls:[{id:"scaleX",label:"Scale X",type:"range",min:.01,max:5,step:.01},{id:"scaleY",label:"Scale Y",type:"range",min:.01,max:5,step:.01}]},{id:"translate",name:"Translate",type:"transform",description:"Moves the shape.",defaultParams:{translateX:0,translateY:0},paramControls:[{id:"translateX",label:"Translate X",type:"range",min:-1,max:1,step:.01},{id:"translateY",label:"Translate Y",type:"range",min:-1,max:1,step:.01}]},{id:"color",name:"Color",type:"color",description:"Changes the color of the shape with solid or rainbow modes.",defaultParams:{mode:"solid",r:255,g:255,b:255,cycleSpeed:0,rainbowSpread:1,rainbowOffset:0,rainbowPalette:"rainbow"},paramControls:[{id:"mode",label:"Mode",type:"select",options:["solid","rainbow"]},{id:"r",label:"Red",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"g",label:"Green",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"b",label:"Blue",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"cycleSpeed",label:"Cycle Speed",type:"range",min:0,max:10,step:.1},{id:"rainbowSpread",label:"Rainbow Spread",type:"range",min:.1,max:10,step:.1,showIf:{mode:"rainbow"}},{id:"rainbowOffset",label:"Rainbow Offset",type:"range",min:0,max:360,step:1,showIf:{mode:"rainbow"}},{id:"rainbowPalette",label:"Palette",type:"select",options:["rainbow","fire","ice","cyber"],showIf:{mode:"rainbow"}}]},{id:"wave",name:"Wave",type:"animation",description:"Applies a wave distortion to the shape.",defaultParams:{amplitude:.1,frequency:10,speed:1,direction:"x"},paramControls:[{id:"amplitude",label:"Amplitude",type:"range",min:.01,max:1,step:.01},{id:"frequency",label:"Frequency",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["x","y"]}]},{id:"warp",name:"Warp",type:"animation",description:"Symmetrical chaotic wave distortion.",defaultParams:{amount:.1,chaos:.5,speed:1},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"chaos",label:"Chaos",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1}]},{id:"distortion",name:"Distortion",type:"transform",description:"Distorts the point data.",defaultParams:{amount:.1,scale:10,speed:.5},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"scale",label:"Scale",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:5,step:.1}]},{id:"move",name:"Move (Bounce)",type:"transform",description:"Moves points and bounces them off the borders.",defaultParams:{speedX:.1,speedY:.1},paramControls:[{id:"speedX",label:"Speed X",type:"range",min:0,max:2,step:.01},{id:"speedY",label:"Speed Y",type:"range",min:0,max:2,step:.01}]},{id:"delay",name:"Delay",type:"effect",description:"Frame or Channel based delay effect.",defaultParams:{mode:"frame",playstyle:"repeat",useCustomOrder:!1,delayDirection:"left_to_right",delayAmount:5,decay:.8,customOrder:[],enabled:!0},paramControls:[{id:"mode",label:"Mode",type:"select",options:["frame","channel"]},{id:"playstyle",label:"Playstyle",type:"select",options:["once","repeat"]},{id:"useCustomOrder",label:"Custom Order",type:"checkbox",showIf:{mode:"channel"}},{id:"delayDirection",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}},{id:"delayAmount",label:"Delay Time",type:"range",min:1,max:60,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01}]},{id:"chase",name:"Chase",type:"effect",description:"Frame or Channel based chase effect.",defaultParams:{mode:"frame",playstyle:"repeat",steps:4,decay:.8,speed:1,overlap:1,direction:"left_to_right",useCustomOrder:!1,customOrder:[],enabled:!0},paramControls:[{id:"mode",label:"Mode",type:"select",options:["frame","channel"]},{id:"playstyle",label:"Playstyle",type:"select",options:["once","repeat","bounce"]},{id:"steps",label:"Steps",type:"range",min:2,max:16,step:1,showIf:{mode:"frame"}},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:5,step:.1},{id:"overlap",label:"Overlap",type:"range",min:1,max:4,step:1},{id:"useCustomOrder",label:"Custom Order",type:"checkbox",showIf:{mode:"channel"}},{id:"direction",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}}]},{id:"blanking",name:"Blanking",type:"animation",description:"Controls the blanking of the laser output.",defaultParams:{blankingInterval:0,spacing:0},paramControls:[{id:"blankingInterval",label:"Blanking Interval",type:"range",min:0,max:10,step:1},{id:"spacing",label:"Spacing",type:"range",min:0,max:20,step:1}]},{id:"strobe",name:"Strobe",type:"animation",description:"Applies a strobe effect to the laser output.",defaultParams:{strobeSpeed:100,strobeAmount:.5},paramControls:[{id:"strobeSpeed",label:"Strobe Speed (ms)",type:"range",min:10,max:1e3,step:10},{id:"strobeAmount",label:"Strobe Amount (0-1)",type:"range",min:0,max:1,step:.01}]},{id:"mirror",name:"Mirror",type:"transform",description:"Mirrors the shape from the center.",defaultParams:{mode:"none"},paramControls:[{id:"mode",label:"Mirror Mode",type:"select",options:["none","x+","x-","y+","y-"]}]}],L=(s,e)=>({...e,...s});function X(s,e,p,o){if(!p)return e;const r=typeof p=="string"?{syncMode:p}:p;if(!r.syncMode)return e;const{time:t,progress:a=0,bpm:l=120,clipDuration:i=0,fftLevels:c={low:0,mid:0,high:0},activationTime:h=0}=o;let n=0;const f=r.speedMultiplier||1,d=r.style||"loop";if(d==="once"&&h>0){const A=(t-h)*.001;let w=1;if(r.syncMode==="timeline")w=Math.max(.01,r.duration||1);else if(r.syncMode==="bpm"){const x=Math.max(.1,r.beats||4),y=l/60;w=x/(y||2)}else if(r.syncMode==="fps")return n=A*f,calculateAnimPhase(n,r,e);n=A/w*f}else if(r.syncMode==="fps")n=t*.001*f;else if(r.syncMode==="timeline"){const A=Math.max(.01,r.duration||1);i>0?n=a*i/A*f:n=0}else if(r.syncMode==="bpm"){const A=Math.max(.1,r.beats||4),w=l/60,x=A/(w||2);i>0?n=a*i/x*f:n=0}else if(r.syncMode==="fft"){const A=r.fftRange||"low",w=c[A]||0;return W(w,e,r)}d==="bounce"&&(n*=2);const u=r.direction||"forward";if(u==="pause")return e;let m=0;if(d==="once")m=Math.min(n,1),u==="backward"&&(m=1-m);else if(d==="bounce"){let A=n%1;Math.floor(n)%2===1?m=1-A:m=A,u==="backward"&&(m=1-m)}else m=n%1,u==="backward"&&(m=1-m);const S=r.range;let _=0,F=1;if(S&&Array.isArray(S)&&S.length===2)_=S[0],F=S[1];else return e;return _+(F-_)*m}function W(s,e,p){const o=p.range;return o&&Array.isArray(o)&&o.length===2?o[0]+(o[1]-o[0])*s:e}function q(s,e,p={}){const{progress:o=0,time:r=performance.now(),effectStates:t,syncSettings:a={},fftLevels:l}=p;if(!e||e.length===0)return s;let i;if(Array.isArray(s.points)){i=new Float32Array(s.points.length*8);for(let n=0;n<s.points.length;n++){const f=s.points[n],d=n*8;i[d]=f.x,i[d+1]=f.y,i[d+2]=f.z||0,i[d+3]=f.r,i[d+4]=f.g,i[d+5]=f.b,i[d+6]=f.blanking?1:0,i[d+7]=f.lastPoint?1:0}}else i=new Float32Array(s.points);let c=i;const h=()=>c.length/8;for(const n of e){if(n.params.enabled===!1||!I.find(u=>u.id===n.id))continue;const d={...n.params};for(const u of Object.keys(d)){const m=n.instanceId?`${n.instanceId}.${u}`:`${n.id}.${u}`;a[m]&&(d[u]=X(u,d[u],a[m],p))}switch(n.id){case"rotate":V(c,h(),d,o,r);break;case"scale":G(c,h(),d);break;case"translate":z(c,h(),d);break;case"color":H(c,h(),d,r);break;case"wave":Q(c,h(),d,r);break;case"blanking":K(c,h(),d);break;case"strobe":j(c,h(),d,r);break;case"mirror":c=Z(c,h(),d);break;case"warp":J(c,h(),d,r);break;case"distortion":ee(c,h(),d,r);break;case"move":te(c,h(),d,r);break;case"delay":t&&n.instanceId&&(c=ae(c,h(),d,t,n.instanceId,p));break;case"chase":c=re(c,h(),d,r,p);break}}return{...s,points:c,isTypedArray:!0}}function V(s,e,p,o,r){const{angle:t,speed:a,direction:l}=L(p,I.find(d=>d.id==="rotate").defaultParams),i=l==="CCW"?-1:1,c=r*.001*a*i,h=t*Math.PI/180+c,n=Math.sin(h),f=Math.cos(h);for(let d=0;d<e;d++){const u=d*8,m=s[u],S=s[u+1];s[u]=m*f-S*n,s[u+1]=m*n+S*f}}function G(s,e,p){const{scaleX:o,scaleY:r}=L(p,I.find(t=>t.id==="scale").defaultParams);for(let t=0;t<e;t++){const a=t*8;s[a]*=o,s[a+1]*=r}}function z(s,e,p){const{translateX:o,translateY:r}=L(p,I.find(t=>t.id==="translate").defaultParams);for(let t=0;t<e;t++){const a=t*8;s[a]+=o,s[a+1]+=r}}function H(s,e,p,o){const{mode:r,r:t,g:a,b:l,cycleSpeed:i,rainbowSpread:c,rainbowOffset:h,rainbowPalette:n}=L(p,I.find(d=>d.id==="color").defaultParams),f=o*.001*i;if(r==="rainbow"){const d=n||"rainbow";for(let u=0;u<e;u++){const m=u*8,S=(u/e*c+f*.5+h/360)%1;let _,F,A;d==="rainbow"?[_,F,A]=U(S,1,.5):[_,F,A]=$(d,S),s[m+3]=_,s[m+4]=F,s[m+5]=A}}else if(i>0){const d=f*50%360,[u,m,S]=U(d/360,1,.5);for(let _=0;_<e;_++){const F=_*8;s[F+3]=u,s[F+4]=m,s[F+5]=S}}else for(let d=0;d<e;d++){const u=d*8;s[u+3]=t,s[u+4]=a,s[u+5]=l}}function $(s,e){const p={fire:[{r:255,g:0,b:0},{r:255,g:128,b:0},{r:255,g:255,b:0},{r:255,g:0,b:0}],ice:[{r:0,g:0,b:255},{r:0,g:255,b:255},{r:255,g:255,b:255},{r:0,g:0,b:255}],cyber:[{r:255,g:0,b:255},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:255,g:0,b:255}]},o=p[s]||p.fire,r=e*(o.length-1),t=Math.floor(r),a=r-t,l=o[t],i=o[t+1]||o[t];return[Math.round(l.r+(i.r-l.r)*a),Math.round(l.g+(i.g-l.g)*a),Math.round(l.b+(i.b-l.b)*a)]}function U(s,e,p){let o,r,t;{const a=(c,h,n)=>(n<0&&(n+=1),n>1&&(n-=1),n<.16666666666666666?c+(h-c)*6*n:n<.5?h:n<.6666666666666666?c+(h-c)*(.6666666666666666-n)*6:c),l=p+e-p*e,i=2*p-l;o=a(i,l,s+1/3),r=a(i,l,s),t=a(i,l,s-1/3)}return[Math.round(o*255),Math.round(r*255),Math.round(t*255)]}function Q(s,e,p,o){const{amplitude:r,frequency:t,speed:a,direction:l}=L(p,I.find(c=>c.id==="wave").defaultParams),i=o*.001*a;for(let c=0;c<e;c++){const h=c*8;l==="x"?s[h+1]+=r*Math.sin(s[h]*t+i):l==="y"&&(s[h]+=r*Math.sin(s[h+1]*t+i))}}function K(s,e,p){const{blankingInterval:o,spacing:r=0}=L(p,I.find(a=>a.id==="blanking").defaultParams);if(o<=0)return;const t=o+1+r;for(let a=0;a<e;a++)a%t>=o&&(s[a*8+6]=1)}function j(s,e,p,o){const{strobeSpeed:r,strobeAmount:t}=L(p,I.find(l=>l.id==="strobe").defaultParams);if(o%r/r<t)for(let l=0;l<e;l++)s[l*8+6]=1}function Z(s,e,p){const{mode:o}=L(p,I.find(i=>i.id==="mirror").defaultParams);if(o==="none")return s;let r=[];for(let i=0;i<e;i++){const c=i*8,h=s[c],n=s[c+1];let f=!1;o==="x-"&&(h<=0||o==="x+"&&(h>=0||o==="y-"&&(n<=0||o==="y+"&&n>=0)))&&(f=!0),f&&r.push({x:s[c],y:s[c+1],z:s[c+2],r:s[c+3],g:s[c+4],b:s[c+5],blk:s[c+6],last:s[c+7]})}const t=r.length*2,a=new Float32Array(t*8);let l=0;for(const i of r)a[l++]=i.x,a[l++]=i.y,a[l++]=i.z,a[l++]=i.r,a[l++]=i.g,a[l++]=i.b,a[l++]=i.blk,a[l++]=i.last;for(const i of r)o==="x-"||o==="x+"?a[l++]=-i.x:a[l++]=i.x,o==="y-"||o==="y+"?a[l++]=-i.y:a[l++]=i.y,a[l++]=i.z,a[l++]=i.r,a[l++]=i.g,a[l++]=i.b,a[l++]=i.blk,a[l++]=i.last;return a}function J(s,e,p,o){const{amount:r,chaos:t,speed:a}=L(p,I.find(i=>i.id==="warp").defaultParams),l=o*.001*a;for(let i=0;i<e;i++){const c=i*8,h=s[c],n=s[c+1],f=Math.abs(n);s[c]+=Math.sin(f*10*(1+t)+l)*r*Math.cos(l*t),s[c+1]+=Math.cos(Math.abs(h)*10*(1+t)+l)*r*Math.sin(l*t)}}function ee(s,e,p,o){const{amount:r,scale:t,speed:a}=L(p,I.find(i=>i.id==="distortion").defaultParams),l=o*.001*a;for(let i=0;i<e;i++){const c=i*8,h=Math.sin(s[c]*t+l)*Math.cos(s[c+1]*t-l),n=Math.cos(s[c]*t-l)*Math.sin(s[c+1]*t+l);s[c]+=h*r,s[c+1]+=n*r}}function te(s,e,p,o){const{speedX:r,speedY:t}=L(p,I.find(h=>h.id==="move").defaultParams),a=o*.001,l=a*r,i=a*t,c=4;for(let h=0;h<e;h++){const n=h*8;let f=s[n]+l,d=s[n+1]+i,u=(f+1)%c;u<0&&(u+=c),u>2&&(u=4-u),f=u-1;let m=(d+1)%c;m<0&&(m+=c),m>2&&(m=4-m),d=m-1,s[n]=f,s[n+1]=d}}function ae(s,e,p,o,r,t){const{mode:a="frame",delayAmount:l,decay:i,delayDirection:c,useCustomOrder:h,customOrder:n}=L(p,I.find(d=>d.id==="delay").defaultParams);o.has(r)||o.set(r,[]);const f=o.get(r);if(f.unshift(new Float32Array(s)),a==="frame"){const u=l*10+1;f.length>u&&(f.length=u);const m=new Float32Array(s.length);for(let S=0;S<e;S++){let _=0;const F=S/e;c==="left_to_right"?_=Math.floor(F*9):c==="right_to_left"?_=Math.floor((1-F)*9):c==="center_to_out"?_=Math.floor(Math.abs(F-.5)*2*9):c==="out_to_center"&&(_=Math.floor((1-Math.abs(F-.5)*2)*9));const A=_*l,w=A<f.length?f[A]:null,x=Math.pow(i,_),y=S*8;w&&w.length===s.length?(m[y]=w[y],m[y+1]=w[y+1],m[y+2]=w[y+2],m[y+3]=w[y+3]*x,m[y+4]=w[y+4]*x,m[y+5]=w[y+5]*x,m[y+6]=w[y+6],m[y+7]=w[y+7]):(m.set(s.subarray(y,y+8),y),m[y+3]=0,m[y+4]=0,m[y+5]=0,m[y+6]=1)}return m}else{const{assignedDacs:d}=t||{};let u=new Map,m=0;if(h||p.delayMode==="channel")(n&&n.length>0?n.map(g=>g.originalIndex):d?d.map((g,R)=>R):[0]).forEach((g,R)=>{u.set(g,R),m=Math.max(m,R)});else{const g=(d||[]).length||1;for(let R=0;R<g;R++){let b=R;c==="right_to_left"?b=g-1-R:c==="center_to_out"?b=Math.floor(Math.abs(R-(g-1)/2)):c==="out_to_center"&&(b=Math.min(R,g-1-R)),u.set(R,b),m=Math.max(m,b)}}const _=m+1,F=l*_+1;f.length>F&&(f.length=F);const A=[];for(let P=0;P<_;P++){const g=P*l;A.push({points:g<f.length?f[g]:null,factor:Math.pow(i,P),index:P})}const w=A.reduce((P,g)=>P+(g.points?g.points.length/8:s.length/8),0),x=new Float32Array(w*8);let y=0;const C=new Array(A.length);for(let P=0;P<A.length;P++){const g=A[P],R=g.points,b=R?R.length/8:s.length/8;C[P]=y;for(let M=0;M<b;M++){const v=M*8,B=y+M*8;R?(x[B]=R[v],x[B+1]=R[v+1],x[B+2]=R[v+2],x[B+3]=R[v+3]*g.factor,x[B+4]=R[v+4]*g.factor,x[B+5]=R[v+5]*g.factor,x[B+6]=R[v+6],x[B+7]=R[v+7]):x[B+6]=1}y+=b*8}const E=new Map;return u.forEach((P,g)=>{P<A.length&&E.set(g,{start:C[P],length:A[P].points?A[P].points.length:s.length})}),x._channelDistributions=E,x}}function re(s,e,p,o,r={}){const{mode:t="frame",steps:a,decay:l,speed:i,overlap:c,direction:h,useCustomOrder:n,customOrder:f,playStyle:d="loop"}=L(p,I.find(F=>F.id==="chase").defaultParams),{progress:u=0,clipDuration:m=1}=r,S=u*m,_=u!==void 0&&m>0?S:o*.001;if(t==="frame"){const F=a;let A=_*i;if(d==="bounce"){const x=F,y=A%(x*2);A=y>x?x*2-y:y}else d==="once"?A=Math.min(A,F):A=A%F;const w=new Float32Array(s.length);for(let x=0;x<e;x++){const y=x/e;let C=0;h==="left_to_right"?C=Math.floor(y*(F-1)):h==="right_to_left"?C=Math.floor((1-y)*(F-1)):h==="center_to_out"?C=Math.floor(Math.abs(y-.5)*2*(F-1)):h==="out_to_center"&&(C=Math.floor((1-Math.abs(y-.5)*2)*(F-1)));let E=Math.abs(A-C);E>F/2&&(E=F-E);let P=E<c?1-E/c:0;l>0&&(P=Math.pow(P,1-l));const g=x*8;w.set(s.subarray(g,g+8),g),w[g+3]*=P,w[g+4]*=P,w[g+5]*=P,P<.05&&(w[g+6]=1)}return w}else{const{assignedDacs:F}=r||{};let A=new Map,w=0;if(n)(f&&f.length>0?f.map(M=>M.originalIndex):F?F.map((M,v)=>v):[0]).forEach((M,v)=>{A.set(M,v),w++});else{w=(F?F.length:1)||1;for(let b=0;b<w;b++){let M=b;h==="right_to_left"?M=w-1-b:h==="center_to_out"?M=Math.floor(Math.abs(b-(w-1)/2)):h==="out_to_center"&&(M=Math.min(b,w-1-b)),A.set(b,M)}}const x=w;let y=_*i;if(d==="bounce"){const b=x,M=y%(b*2);y=M>b?b*2-M:M}else d==="once"?y=Math.min(y,x):y=y%x;const C=e*w,E=new Float32Array(C*8),P=new Map;let g=0;const R=Array.from(A.keys());R.length===0&&R.push(0);for(const b of R){const M=A.get(b)||0;let v=Math.abs(y-M);v>x/2&&(v=x-v);let B=v<c?1-v/c:0;l>0&&(B=Math.pow(B,1-l));const D=g;for(let O=0;O<e;O++){const T=O*8,k=g+O*8;E.set(s.subarray(T,T+8),k),E[k+3]*=B,E[k+4]*=B,E[k+5]*=B,B<.05&&(E[k+6]=1)}P.set(b,{start:D,length:e*8}),g+=e*8}return E._channelDistributions=P,E}}function oe(s,e){if(!e||!s||!s.points)return s;const{safetyZones:p,outputArea:o,transformationEnabled:r,transformationMode:t,flipX:a,flipY:l}=e;let i=s.points;const c=s.isTypedArray||i instanceof Float32Array,h=c?i.length/8:i.length;let n=c?new Float32Array(i):i.map(f=>({...f}));for(let f=0;f<h;f++){let d,u,m,S,_,F;if(c?(d=n[f*8],u=n[f*8+1],m=n[f*8+3],S=n[f*8+4],_=n[f*8+5],F=n[f*8+6]):(d=n[f].x,u=n[f].y,m=n[f].r,S=n[f].g,_=n[f].b,F=n[f].blanking?1:0),r&&o){let A=(d+1)/2,w=(1-u)/2;t==="crop"?(A<o.x||A>o.x+o.w||w<o.y||w>o.y+o.h)&&(m=0,S=0,_=0,F=1):t==="scale"&&(A=o.x+A*o.w,w=o.y+w*o.h,d=A*2-1,u=1-w*2)}if(p&&p.length>0){let A=(d+1)/2,w=(1-u)/2;for(const x of p)if(A>=x.x&&A<=x.x+x.w&&w>=x.y&&w<=x.y+x.h){m=0,S=0,_=0,F=1;break}}a&&(d=-d),l&&(u=-u),d=Math.max(-1,Math.min(1,d)),u=Math.max(-1,Math.min(1,u)),c?(n[f*8]=d,n[f*8+1]=u,n[f*8+3]=m,n[f*8+4]=S,n[f*8+5]=_,n[f*8+6]=F):(n[f].x=d,n[f].y=u,n[f].r=m,n[f].g=S,n[f].b=_,n[f].blanking=F>.5)}return{...s,points:n,isTypedArray:c}}class ne{constructor(e,p){if(this.canvas=e,this.type=p,this.gl=e.getContext("webgl")||e.getContext("experimental-webgl"),this.animationFrameId=null,this.frameIndexes=Array(10).fill(0),this.pointIndexes=Array(10).fill(0),this.showBeamEffect=!1,this.beamAlpha=.5,this.fadeAlpha=.13,this.beamRenderMode="both",this.positionBuffer=null,this.colorBuffer=null,this.alphaBuffer=null,this.lastPointDrawTime=0,!this.gl){console.error("WebGL not supported");return}this.setup()}setup(){const e=this.gl,p=`
      attribute vec2 aPosition;
      attribute vec3 aColor;
      attribute float aAlpha;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        gl_PointSize = 2.0;
        vColor = aColor;
        vAlpha = aAlpha;
      }
    `,o=`
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(vColor, vAlpha);
      }
    `,r=this.createShader(e.VERTEX_SHADER,p),t=this.createShader(e.FRAGMENT_SHADER,o),a=this.createProgram(r,t);this.program=a,this.positionAttributeLocation=e.getAttribLocation(a,"aPosition"),this.colorAttributeLocation=e.getAttribLocation(a,"aColor"),this.alphaAttributeLocation=e.getAttribLocation(a,"aAlpha"),this.quadPositionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer);const l=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(l),e.STATIC_DRAW),this.quadColorUniformLocation=e.getUniformLocation(a,"uColor"),this.quadAlphaUniformLocation=e.getUniformLocation(a,"uAlpha");const i=`
      attribute vec2 aPosition;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `,c=`
      precision mediump float;
      uniform vec4 uColor;
      void main() {
        gl_FragColor = uColor;
      }
    `,h=this.createShader(e.VERTEX_SHADER,i),n=this.createShader(e.FRAGMENT_SHADER,c);this.fadeProgram=this.createProgram(h,n),this.fadePositionAttributeLocation=e.getAttribLocation(this.fadeProgram,"aPosition"),this.fadeColorUniformLocation=e.getUniformLocation(this.fadeProgram,"uColor"),e.useProgram(a);const f=131072;this.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.bufferData(e.ARRAY_BUFFER,f*2*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.colorBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.colorBuffer),e.bufferData(e.ARRAY_BUFFER,f*3*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.alphaBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.alphaBuffer),e.bufferData(e.ARRAY_BUFFER,f*1*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.clearColor(0,0,0,1)}reset(){this.frameIndexes.fill(0),this.pointIndexes.fill(0),this.clearCanvas()}createShader(e,p){const o=this.gl,r=o.createShader(e);if(o.shaderSource(r,p),o.compileShader(r),o.getShaderParameter(r,o.COMPILE_STATUS))return r;console.error(o.getShaderInfoLog(r)),o.deleteShader(r)}createProgram(e,p){const o=this.gl,r=o.createProgram();if(o.attachShader(r,e),o.attachShader(r,p),o.linkProgram(r),o.getProgramParameter(r,o.LINK_STATUS))return r;console.error(o.getProgramInfoLog(r)),o.deleteProgram(r)}render(e){e.showBeamEffect!==void 0&&this.setBeamEffect(e.showBeamEffect),e.beamAlpha!==void 0&&this.setBeamAlpha(e.beamAlpha),e.fadeAlpha!==void 0&&this.setFadeAlpha(e.fadeAlpha),e.beamRenderMode!==void 0&&(this.beamRenderMode=e.beamRenderMode),this.type==="world"?this.renderWorld(e.worldData,e.previewScanRate,e.layerIntensities,e.masterIntensity,e.dacSettings,e.previewTime,e.fftLevels):this.renderSingle(e.ildaFrames,e.previewScanRate,e.intensity,e.effects,e.syncSettings,e.bpm,e.clipDuration,e.progress,e.previewTime,e.fftLevels,e.effectStates)}renderSingle(e,p,o,r,t={},a=120,l=1,i=null,c=null,h={low:0,mid:0,high:0},n=null){const f=this.gl;if(f.viewport(0,0,f.canvas.width,f.canvas.height),this.drawFadeQuad(),!e||e.length===0)return;const d=this.frameIndexes[0]%e.length,u=e[d],m=i!==null?i:d/e.length,S=c!==null?c:performance.now();this.draw(u,r,this.showBeamEffect,this.beamAlpha,p,this.beamRenderMode,o,0,m,S,t,a,l,h,n),this.frameIndexes[0]++,this.frameIndexes[0]>=e.length&&(this.frameIndexes[0]=0)}renderWorld(e,p,o,r,t,a=null,l={low:0,mid:0,high:0}){const i=this.gl;i.viewport(0,0,i.canvas.width,i.canvas.height),this.drawFadeQuad();const c=a!==null?a:performance.now();e.forEach(h=>{if(h&&h.frames&&h.frames.length>0){const n=h.frames[0];if(n){const f=h.layerIndex||0;if(h.syncSettings,h.bpm,f>=this.frameIndexes.length){const m=f+5;for(;this.frameIndexes.length<m;)this.frameIndexes.push(0),this.pointIndexes.push(0)}const u=(o[f]!==void 0?o[f]:1)*r;if(u>.001){const m=h.progress!==void 0?h.progress:this.frameIndexes[f]%h.frames.length/h.frames.length,{syncSettings:S={},bpm:_=120,clipDuration:F=1,effectStates:A=null}=h;let w=n;if(t){let x=n;if(t.dimmer!==void 0&&t.dimmer<1){const y=n.points,C=n.isTypedArray||y instanceof Float32Array,E=C?y.length/8:y.length,P=C?new Float32Array(y):y.map(g=>({...g}));for(let g=0;g<E;g++)C?(P[g*8+3]*=t.dimmer,P[g*8+4]*=t.dimmer,P[g*8+5]*=t.dimmer):(P[g].r*=t.dimmer,P[g].g*=t.dimmer,P[g].b*=t.dimmer);x={...n,points:P,isTypedArray:C}}w=oe(x,t)}this.draw(w,h.effects,this.showBeamEffect,this.beamAlpha,p,this.beamRenderMode,u,f,m,c,S,_,F,l,A)}}}}),e.forEach(h=>{if(h&&h.frames){const n=h.layerIndex||0;this.frameIndexes[n]++,this.frameIndexes[n]>=h.frames.length&&(this.frameIndexes[n]=0)}})}drawFadeQuad(){const e=this.gl;this.fadeProgram&&(e.useProgram(this.fadeProgram),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer),e.enableVertexAttribArray(this.fadePositionAttributeLocation),e.vertexAttribPointer(this.fadePositionAttributeLocation,2,e.FLOAT,!1,0,0),e.uniform4f(this.fadeColorUniformLocation,0,0,0,this.fadeAlpha),e.drawArrays(e.TRIANGLES,0,6))}setBeamEffect(e){this.showBeamEffect=e}setBeamAlpha(e){this.beamAlpha=e}setFadeAlpha(e){this.fadeAlpha=e}draw(e,p,o,r,t,a,l=1,i=0,c=0,h=performance.now(),n={},f=120,d=1,u={low:0,mid:0,high:0},m=null){if(this.gl,!e||!e.points)return;const S=q(e,p,{progress:c,time:h,syncSettings:n,bpm:f,clipDuration:d,fftLevels:u,effectStates:m}),_=S.points,F=S.isTypedArray,A=F?_.length/8:_.length;if(A===0)return;const w=Math.max(1,Math.floor(A/t));let x=this.pointIndexes[i]||0;x>=A&&(x=0);const y=g=>{const R=(x+g)%A;if(F){const b=R*8;return{x:_[b],y:_[b+1],r:_[b+3],g:_[b+4],b:_[b+5],blanking:_[b+6]===1}}else{const b=_[R];return{x:b.x,y:b.y,r:b.r,g:b.g,b:b.b,blanking:b.blanking}}},C=()=>{const g=a==="points"||a==="both",R=a==="lines"||a==="both";let b=[],M=[];for(let v=0;v<w;v++){const B=y(v);if(B.blanking){b.length>0&&(R&&this._drawSegment(new Float32Array(b),new Float32Array(M),1,b.length/2,!1),g&&this._drawSegment(new Float32Array(b),new Float32Array(M),1,b.length/2,!0),b=[],M=[]);continue}b.push(B.x,B.y),M.push(B.r/255*l,B.g/255*l,B.b/255*l)}b.length>0&&(R&&this._drawSegment(new Float32Array(b),new Float32Array(M),1,b.length/2,!1),g&&this._drawSegment(new Float32Array(b),new Float32Array(M),1,b.length/2,!0))},E=()=>{const g=[],R=[];for(let b=0;b<w;b++){const M=y(b);if(!M.blanking){g.push(0,0,M.x,M.y);const v=[M.r/255*l,M.g/255*l,M.b/255*l];R.push(...v,...v)}}g.length>0&&this._drawLines(new Float32Array(g),new Float32Array(R),r,g.length/2)},P=()=>{const g=[],R=[];let b=y(0);for(let M=1;M<w;M++){const v=y(M);if(!b.blanking&&!v.blanking){g.push(0,0,b.x,b.y,v.x,v.y);const B=[b.r/255*l,b.g/255*l,b.b/255*l],D=[v.r/255*l,v.g/255*l,v.b/255*l],O=[(B[0]+D[0])/2,(B[1]+D[1])/2,(B[2]+D[2])/2],T=.3,k=[B[0]*T,B[1]*T,B[2]*T],se=[D[0]*T,D[1]*T,D[2]*T];R.push(...O,...k,...se)}b=v}g.length>0&&this._drawTriangles(new Float32Array(g),new Float32Array(R),r,g.length/2)};C(),o&&(a==="points"?E():a==="lines"?P():a==="both"&&(P(),E())),this.pointIndexes[i]=(x+w)%A}_drawSegment(e,p,o,r,t=!1){const a=this.gl;a.useProgram(this.program),a.bindBuffer(a.ARRAY_BUFFER,this.positionBuffer),a.bufferSubData(a.ARRAY_BUFFER,0,e),a.enableVertexAttribArray(this.positionAttributeLocation),a.vertexAttribPointer(this.positionAttributeLocation,2,a.FLOAT,!1,0,0),a.bindBuffer(a.ARRAY_BUFFER,this.colorBuffer),a.bufferSubData(a.ARRAY_BUFFER,0,p),a.enableVertexAttribArray(this.colorAttributeLocation),a.vertexAttribPointer(this.colorAttributeLocation,3,a.FLOAT,!1,0,0);const l=new Float32Array(Array(r).fill(o));a.bindBuffer(a.ARRAY_BUFFER,this.alphaBuffer),a.bufferSubData(a.ARRAY_BUFFER,0,l),a.enableVertexAttribArray(this.alphaAttributeLocation),a.vertexAttribPointer(this.alphaAttributeLocation,1,a.FLOAT,!1,0,0),a.drawArrays(t?a.POINTS:a.LINE_STRIP,0,r)}_drawLines(e,p,o,r){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,p),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const a=new Float32Array(Array(r).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,a),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINES,0,r)}_drawTriangles(e,p,o,r){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,p),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const a=new Float32Array(Array(r).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,a),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLES,0,r)}clearCanvas(){const e=this.gl;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT)}destroy(){if(cancelAnimationFrame(this.animationFrameId),this.gl){const e=this.gl.getExtension("WEBGL_losing_context");e&&e.loseContext()}}}const Y=new Map;function N(s,e=0){const p=Y.get(s);if(!p)return;const o=performance.now();p.renderer.render(p.data),e=o,p.animationFrameId=requestAnimationFrame(()=>N(s,e))}self.onmessage=s=>{const{action:e,payload:p}=s.data;if(e==="register"){const{id:o,canvas:r,type:t,data:a}=p,l=new ne(r,t),i=requestAnimationFrame(()=>N(o));Y.set(o,{renderer:l,type:t,data:a,animationFrameId:i})}else if(e==="deregister"){const{id:o}=p,r=Y.get(o);r&&(cancelAnimationFrame(r.animationFrameId),Y.delete(o))}else if(e==="update"){const{id:o,data:r}=p,t=Y.get(o);t&&(t.data=r)}else if(e==="clear"){const{id:o}=p,r=Y.get(o);r&&r.renderer.clearCanvas()}}})();
