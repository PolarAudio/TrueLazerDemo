(function(){"use strict";const k=[{r:255,g:0,b:0},{r:0,g:255,b:0},{r:0,g:0,b:255},{r:255,g:255,b:0},{r:0,g:255,b:255},{r:255,g:0,b:255},{r:255,g:128,b:0},{r:128,g:255,b:0},{r:0,g:255,b:128},{r:0,g:128,b:255},{r:128,g:0,b:255},{r:255,g:0,b:128},{r:255,g:255,b:255},{r:128,g:128,b:128},{r:255,g:128,b:128},{r:128,g:255,b:128},{r:128,g:128,b:255},{r:255,g:255,b:128},{r:128,g:255,b:255},{r:255,g:128,b:255}],M=new Map;function U(l,s,p,m,i=k){const f=[],e=new DataView(l);let a=0;try{for(let o=0;o<m;o++){if(s===2){a+=p;continue}let w,b,t=0,n,c,y,r;s===0||s===4?(w=e.getInt16(a,!1)/32768,b=e.getInt16(a+2,!1)/32768,t=e.getInt16(a+4,!1)/32768,r=e.getUint8(a+6)):(w=e.getInt16(a,!1)/32768,b=e.getInt16(a+2,!1)/32768,r=e.getUint8(a+4));const d=(r&64)!==0,g=(r&128)!==0;if(d)n=0,c=0,y=0;else if(s===0||s===1){const h=e.getUint8(a+(s===0?7:5)),u=i||k,I=u[h%u.length]||k[0];n=I.r,c=I.g,y=I.b}else(s===4||s===5)&&(y=e.getUint8(a+(s===4?7:5)),c=e.getUint8(a+(s===4?8:6)),n=e.getUint8(a+(s===4?9:7)));if(f.push({x:w,y:b,z:t,r:n===void 0?255:n,g:c===void 0?255:c,b:y===void 0?255:y,blanking:d,lastPoint:g}),a+=p,g)break}}catch(o){console.warn("Parser: Error reading points:",o)}return f}function F(l){console.log("[ilda-parser.worker.js] parseIldaFile - Starting parsing.");const s=new DataView(l),p=[];let m=null,i=0,f=null;for(;i+32<=l.byteLength;){const e=i,a=String.fromCharCode(s.getUint8(e),s.getUint8(e+1),s.getUint8(e+2),s.getUint8(e+3));if(a!=="ILDA"){console.warn(`[ilda-parser.worker.js] Parser: Invalid ILDA signature at offset ${e}, got: ${a}. Skipping 32 bytes.`),i+=32;continue}const o=s.getUint8(e+7);if(m===null&&(m=o),o>5){console.warn(`[ilda-parser.worker.js] Parser: Unknown format code: ${o} at offset ${e}. Skipping 32 bytes.`),i+=32;continue}const w=String.fromCharCode(...new Uint8Array(l,e+8,8)).trim(),b=String.fromCharCode(...new Uint8Array(l,e+16,8)).trim();let t=s.getUint16(e+24,!1);const n=s.getUint16(e+26,!1),c=s.getUint16(e+28,!1),y=s.getUint8(e+30);let r;switch(o){case 0:r=8;break;case 1:r=6;break;case 2:r=4;break;case 4:r=10;break;case 5:r=8;break;default:console.warn(`Parser: Unsupported format ${o}, skipping 32 bytes.`),i+=32;continue}if(o===2){f=[];const u=i+32;for(let I=0;I<t;I++){const P=s.getUint8(u+I*4),D=s.getUint8(u+I*4+1),$=s.getUint8(u+I*4+2);f.push({r:P,g:D,b:$})}}let d=t*r,g=32+d;const h=l.byteLength-i;if(g<h){const u=h-g;u>0&&u<=32&&(console.warn(`Parser: Malformed frame, ${u} leftover bytes. Adjusting size.`),g+=u,d+=u,t=Math.floor(d/r))}if(e+g>l.byteLength){console.warn(`Parser: Incomplete frame data for ${t} points at offset ${e}. Expected ${g} bytes, but only ${l.byteLength-e} bytes remaining. Breaking.`);break}if(t===0){console.log("[ilda-parser.worker.js] Parser: Empty frame, skipping"),i+=g;continue}p.push({frameName:w,companyName:b,frameNumber:n,totalFrames:c,scannerHead:y,formatCode:o,recordSize:r,pointCount:t,pointDataOffset:e+32,pointDataSize:d,frameEndOffset:e+g,bounds:{minX:0,maxX:0,minY:0,maxY:0}}),i+=g}return console.log(`[ilda-parser.worker.js] parseIldaFile - Finished parsing. Found ${p.length} frames.`),{frames:p,error:p.length===0?"No valid frames found":null,firstFormatCode:m,ildaFileBuffer:l,colorPalette:f}}const x=new Map;self.onmessage=function(l){const{arrayBuffer:s,type:p,fileName:m,filePath:i,layerIndex:f,colIndex:e,workerId:a,frameIndex:o,isStillFrame:w,requestId:b}=l.data;if(p==="parse-ilda"){if(!s){self.postMessage({success:!1,error:"ArrayBuffer missing for parse-ilda command",type:"parse-ilda"});return}try{console.log("[ilda-parser.worker.js] Calling parseIldaFile for:",m);const t=F(s),n=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;M.set(n,{ildaFileBuffer:t.ildaFileBuffer,framesMetadata:t.frames,colorPalette:t.colorPalette}),console.log("[ilda-parser.worker.js] Posting success message for parse-ilda."),self.postMessage({success:!0,workerId:n,totalFrames:t.frames.length,ildaFormat:t.firstFormatCode,fileName:m,filePath:i,layerIndex:f,colIndex:e,type:"parse-ilda"}),self.postMessage({type:"parsing-status",status:!1,layerIndex:f,colIndex:e})}catch(t){console.error("[ilda-parser.worker.js] Error parsing file in onmessage handler:",t),self.postMessage({success:!1,error:t.message,type:"parse-ilda"}),self.postMessage({type:"parsing-status",status:!1,layerIndex:f,colIndex:e})}}else if(p==="load-and-parse-ilda"){const t=Math.random().toString(36).substring(2,15);x.set(t,{fileName:m,filePath:i,layerIndex:f,colIndex:e}),self.postMessage({type:"parsing-status",status:!0,layerIndex:f,colIndex:e}),self.postMessage({type:"request-file-content",filePath:i,requestId:t})}else if(p==="file-content-response"){const t=x.get(b);if(!t){console.error(`Worker: No context found for requestId: ${b}`);return}if(x.delete(b),l.data.error){console.error(`Worker: Error receiving file content: ${l.data.error}`),self.postMessage({success:!1,error:l.data.error,type:"parse-ilda",...t}),self.postMessage({type:"parsing-status",status:!1,layerIndex:t.layerIndex,colIndex:t.colIndex});return}try{console.log(`[ilda-parser.worker.js] Calling parseIldaFile for: ${t.fileName} (from file-content-response)`);const n=F(s),c=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;M.set(c,{ildaFileBuffer:n.ildaFileBuffer,framesMetadata:n.frames,colorPalette:n.colorPalette}),self.postMessage({success:!0,workerId:c,totalFrames:n.frames.length,ildaFormat:n.firstFormatCode,type:"parse-ilda",...t}),self.postMessage({type:"parsing-status",status:!1,layerIndex:t.layerIndex,colIndex:t.colIndex})}catch(n){console.error("[ilda-parser.worker.js] Error parsing file from content response:",n),self.postMessage({success:!1,error:n.message,type:"parse-ilda",...t}),self.postMessage({type:"parsing-status",status:!1,layerIndex:t.layerIndex,colIndex:t.colIndex})}}else if(p==="get-frame"){const t=M.get(a);if(!t){self.postMessage({success:!1,error:"ILDA data not found",type:"get-frame",workerId:a});return}const{ildaFileBuffer:n,framesMetadata:c,colorPalette:y}=t;if(o>=c.length||o<0){self.postMessage({success:!1,error:`Frame index ${o} out of bounds`,type:"get-frame",workerId:a});return}const r=c[o];let d=r.cachedPoints;if(!d){const h=n.slice(r.pointDataOffset,r.pointDataOffset+r.pointDataSize);d=U(h,r.formatCode,r.recordSize,r.pointCount,y),r.cachedPoints=d}const g={points:d};self.postMessage({success:!0,frame:g,type:"get-frame",workerId:a,frameIndex:o,isStillFrame:w,layerIndex:f,colIndex:e})}}})();
