(function(){"use strict";const I=[{id:"rotate",name:"Rotate",type:"transform",description:"Rotates the shape around its center.",defaultParams:{angle:0,speed:0,direction:"CW"},paramControls:[{id:"angle",label:"Angle",type:"range",min:0,max:360,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["CW","CCW"]}]},{id:"scale",name:"Scale",type:"transform",description:"Scales the shape.",defaultParams:{scaleX:1,scaleY:1},paramControls:[{id:"scaleX",label:"Scale X",type:"range",min:.01,max:5,step:.01},{id:"scaleY",label:"Scale Y",type:"range",min:.01,max:5,step:.01}]},{id:"translate",name:"Translate",type:"transform",description:"Moves the shape.",defaultParams:{translateX:0,translateY:0},paramControls:[{id:"translateX",label:"Translate X",type:"range",min:-1,max:1,step:.01},{id:"translateY",label:"Translate Y",type:"range",min:-1,max:1,step:.01}]},{id:"color",name:"Color",type:"color",description:"Changes the color of the shape with solid or rainbow modes.",defaultParams:{mode:"solid",r:255,g:255,b:255,cycleSpeed:0,rainbowSpread:1,rainbowOffset:0,rainbowPalette:"rainbow"},paramControls:[{id:"mode",label:"Mode",type:"select",options:["solid","rainbow"]},{id:"r",label:"Red",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"g",label:"Green",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"b",label:"Blue",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"cycleSpeed",label:"Cycle Speed",type:"range",min:0,max:10,step:.1},{id:"rainbowSpread",label:"Rainbow Spread",type:"range",min:.1,max:10,step:.1,showIf:{mode:"rainbow"}},{id:"rainbowOffset",label:"Rainbow Offset",type:"range",min:0,max:360,step:1,showIf:{mode:"rainbow"}},{id:"rainbowPalette",label:"Palette",type:"select",options:["rainbow","fire","ice","cyber"],showIf:{mode:"rainbow"}}]},{id:"wave",name:"Wave",type:"animation",description:"Applies a wave distortion to the shape.",defaultParams:{amplitude:.1,frequency:10,speed:1,direction:"x"},paramControls:[{id:"amplitude",label:"Amplitude",type:"range",min:.01,max:1,step:.01},{id:"frequency",label:"Frequency",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["x","y"]}]},{id:"warp",name:"Warp",type:"animation",description:"Symmetrical chaotic wave distortion.",defaultParams:{amount:.1,chaos:.5,speed:1},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"chaos",label:"Chaos",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1}]},{id:"distortion",name:"Distortion",type:"transform",description:"Distorts the point data.",defaultParams:{amount:.1,scale:10,speed:.5},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"scale",label:"Scale",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:5,step:.1}]},{id:"move",name:"Move (Bounce)",type:"transform",description:"Moves points and bounces them off the borders.",defaultParams:{speedX:.1,speedY:.1},paramControls:[{id:"speedX",label:"Speed X",type:"range",min:0,max:2,step:.01},{id:"speedY",label:"Speed Y",type:"range",min:0,max:2,step:.01}]},{id:"delay",name:"Delay",type:"effect",description:"Frame or Channel based delay effect.",defaultParams:{mode:"frame",playstyle:"repeat",useCustomOrder:!1,delayDirection:"left_to_right",delayAmount:5,decay:.8,customOrder:[],enabled:!0},paramControls:[{id:"mode",label:"Mode",type:"select",options:["frame","channel"]},{id:"playstyle",label:"Playstyle",type:"select",options:["once","repeat"]},{id:"useCustomOrder",label:"Custom Order",type:"checkbox",showIf:{mode:"channel"}},{id:"delayDirection",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}},{id:"delayAmount",label:"Delay Time",type:"range",min:1,max:60,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01}]},{id:"chase",name:"Chase",type:"effect",description:"Frame or Channel based chase effect.",defaultParams:{mode:"frame",playstyle:"repeat",steps:4,decay:.8,speed:1,overlap:1,direction:"left_to_right",useCustomOrder:!1,customOrder:[],enabled:!0},paramControls:[{id:"mode",label:"Mode",type:"select",options:["frame","channel"]},{id:"playstyle",label:"Playstyle",type:"select",options:["once","repeat","bounce"]},{id:"steps",label:"Steps",type:"range",min:2,max:16,step:1,showIf:{mode:"frame"}},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:5,step:.1},{id:"overlap",label:"Overlap",type:"range",min:1,max:4,step:1},{id:"useCustomOrder",label:"Custom Order",type:"checkbox",showIf:{mode:"channel"}},{id:"direction",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}}]},{id:"blanking",name:"Blanking",type:"animation",description:"Controls the blanking of the laser output.",defaultParams:{blankingInterval:0,spacing:0},paramControls:[{id:"blankingInterval",label:"Blanking Interval",type:"range",min:0,max:10,step:1},{id:"spacing",label:"Spacing",type:"range",min:0,max:20,step:1}]},{id:"strobe",name:"Strobe",type:"animation",description:"Applies a strobe effect to the laser output.",defaultParams:{strobeSpeed:100,strobeAmount:.5},paramControls:[{id:"strobeSpeed",label:"Strobe Speed (ms)",type:"range",min:10,max:1e3,step:10},{id:"strobeAmount",label:"Strobe Amount (0-1)",type:"range",min:0,max:1,step:.01}]},{id:"mirror",name:"Mirror",type:"transform",description:"Mirrors the shape from the center.",defaultParams:{mode:"none"},paramControls:[{id:"mode",label:"Mirror Mode",type:"select",options:["none","x+","x-","y+","y-"]}]}],L=(s,e)=>({...e,...s});function X(s,e,h,o){if(!h)return e;const a=typeof h=="string"?{syncMode:h}:h;if(!a.syncMode)return e;const{time:t,progress:r=0,bpm:l=120,clipDuration:i=0,fftLevels:c={low:0,mid:0,high:0},activationTime:d=0}=o;let n=0;const f=a.speedMultiplier||1,p=a.style||"loop";if(p==="once"&&d>0){const A=(t-d)*.001;let w=1;if(a.syncMode==="timeline")w=Math.max(.01,a.duration||1);else if(a.syncMode==="bpm"){const x=Math.max(.1,a.beats||4),y=l/60;w=x/(y||2)}else if(a.syncMode==="fps")return n=A*f,calculateAnimPhase(n,a,e);n=A/w*f}else if(a.syncMode==="fps")n=t*.001*f;else if(a.syncMode==="timeline"){const A=Math.max(.01,a.duration||1);i>0?n=r*i/A*f:n=0}else if(a.syncMode==="bpm"){const A=Math.max(.1,a.beats||4),w=l/60,x=A/(w||2);i>0?n=r*i/x*f:n=0}else if(a.syncMode==="fft"){const A=a.fftRange||"low",w=c[A]||0;return W(w,e,a)}p==="bounce"&&(n*=2);const b=a.direction||"forward";if(b==="pause")return e;let m=0;if(p==="once")m=Math.min(n,1),b==="backward"&&(m=1-m);else if(p==="bounce"){let A=n%1;Math.floor(n)%2===1?m=1-A:m=A,b==="backward"&&(m=1-m)}else m=n%1,b==="backward"&&(m=1-m);const S=a.range;let _=0,F=1;if(S&&Array.isArray(S)&&S.length===2)_=S[0],F=S[1];else return e;return _+(F-_)*m}function W(s,e,h){const o=h.range;return o&&Array.isArray(o)&&o.length===2?o[0]+(o[1]-o[0])*s:e}function q(s,e,h={}){const{progress:o=0,time:a=performance.now(),effectStates:t,syncSettings:r={},fftLevels:l}=h;if(!e||e.length===0)return s;let i;if(Array.isArray(s.points)){i=new Float32Array(s.points.length*8);for(let n=0;n<s.points.length;n++){const f=s.points[n],p=n*8;i[p]=f.x,i[p+1]=f.y,i[p+2]=f.z||0,i[p+3]=f.r,i[p+4]=f.g,i[p+5]=f.b,i[p+6]=f.blanking?1:0,i[p+7]=f.lastPoint?1:0}}else i=new Float32Array(s.points);let c=i;const d=()=>c.length/8;for(const n of e){if(n.params.enabled===!1||!I.find(b=>b.id===n.id))continue;const p={...n.params};for(const b of Object.keys(p)){const m=n.instanceId?`${n.instanceId}.${b}`:`${n.id}.${b}`;r[m]&&(p[b]=X(b,p[b],r[m],h))}switch(n.id){case"rotate":V(c,d(),p,o,a);break;case"scale":G(c,d(),p);break;case"translate":z(c,d(),p);break;case"color":H(c,d(),p,a);break;case"wave":Q(c,d(),p,a);break;case"blanking":K(c,d(),p);break;case"strobe":j(c,d(),p,a);break;case"mirror":c=Z(c,d(),p);break;case"warp":J(c,d(),p,a);break;case"distortion":ee(c,d(),p,a);break;case"move":te(c,d(),p,a);break;case"delay":t&&n.instanceId&&(c=re(c,d(),p,t,n.instanceId,h));break;case"chase":c=ae(c,d(),p,a,h);break}}return{...s,points:c,isTypedArray:!0}}function V(s,e,h,o,a){const{angle:t,speed:r,direction:l}=L(h,I.find(p=>p.id==="rotate").defaultParams),i=l==="CCW"?-1:1,c=a*.001*r*i,d=t*Math.PI/180+c,n=Math.sin(d),f=Math.cos(d);for(let p=0;p<e;p++){const b=p*8,m=s[b],S=s[b+1];s[b]=m*f-S*n,s[b+1]=m*n+S*f}}function G(s,e,h){const{scaleX:o,scaleY:a}=L(h,I.find(t=>t.id==="scale").defaultParams);for(let t=0;t<e;t++){const r=t*8;s[r]*=o,s[r+1]*=a}}function z(s,e,h){const{translateX:o,translateY:a}=L(h,I.find(t=>t.id==="translate").defaultParams);for(let t=0;t<e;t++){const r=t*8;s[r]+=o,s[r+1]+=a}}function H(s,e,h,o){const{mode:a,r:t,g:r,b:l,cycleSpeed:i,rainbowSpread:c,rainbowOffset:d,rainbowPalette:n}=L(h,I.find(p=>p.id==="color").defaultParams),f=o*.001*i;if(a==="rainbow"){const p=n||"rainbow";for(let b=0;b<e;b++){const m=b*8,S=(b/e*c+f*.5+d/360)%1;let _,F,A;p==="rainbow"?[_,F,A]=U(S,1,.5):[_,F,A]=$(p,S),s[m+3]=_,s[m+4]=F,s[m+5]=A}}else if(i>0){const p=f*50%360,[b,m,S]=U(p/360,1,.5);for(let _=0;_<e;_++){const F=_*8;s[F+3]=b,s[F+4]=m,s[F+5]=S}}else for(let p=0;p<e;p++){const b=p*8;s[b+3]=t,s[b+4]=r,s[b+5]=l}}function $(s,e){const h={fire:[{r:255,g:0,b:0},{r:255,g:128,b:0},{r:255,g:255,b:0},{r:255,g:0,b:0}],ice:[{r:0,g:0,b:255},{r:0,g:255,b:255},{r:255,g:255,b:255},{r:0,g:0,b:255}],cyber:[{r:255,g:0,b:255},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:255,g:0,b:255}]},o=h[s]||h.fire,a=e*(o.length-1),t=Math.floor(a),r=a-t,l=o[t],i=o[t+1]||o[t];return[Math.round(l.r+(i.r-l.r)*r),Math.round(l.g+(i.g-l.g)*r),Math.round(l.b+(i.b-l.b)*r)]}function U(s,e,h){let o,a,t;{const r=(c,d,n)=>(n<0&&(n+=1),n>1&&(n-=1),n<.16666666666666666?c+(d-c)*6*n:n<.5?d:n<.6666666666666666?c+(d-c)*(.6666666666666666-n)*6:c),l=h+e-h*e,i=2*h-l;o=r(i,l,s+1/3),a=r(i,l,s),t=r(i,l,s-1/3)}return[Math.round(o*255),Math.round(a*255),Math.round(t*255)]}function Q(s,e,h,o){const{amplitude:a,frequency:t,speed:r,direction:l}=L(h,I.find(c=>c.id==="wave").defaultParams),i=o*.001*r;for(let c=0;c<e;c++){const d=c*8;l==="x"?s[d+1]+=a*Math.sin(s[d]*t+i):l==="y"&&(s[d]+=a*Math.sin(s[d+1]*t+i))}}function K(s,e,h){const{blankingInterval:o,spacing:a=0}=L(h,I.find(r=>r.id==="blanking").defaultParams);if(o<=0)return;const t=o+1+a;for(let r=0;r<e;r++)r%t>=o&&(s[r*8+6]=1)}function j(s,e,h,o){const{strobeSpeed:a,strobeAmount:t}=L(h,I.find(l=>l.id==="strobe").defaultParams);if(o%a/a<t)for(let l=0;l<e;l++)s[l*8+6]=1}function Z(s,e,h){const{mode:o}=L(h,I.find(i=>i.id==="mirror").defaultParams);if(o==="none")return s;let a=[];for(let i=0;i<e;i++){const c=i*8,d=s[c],n=s[c+1];let f=!1;o==="x-"&&(d<=0||o==="x+"&&(d>=0||o==="y-"&&(n<=0||o==="y+"&&n>=0)))&&(f=!0),f&&a.push({x:s[c],y:s[c+1],z:s[c+2],r:s[c+3],g:s[c+4],b:s[c+5],blk:s[c+6],last:s[c+7]})}const t=a.length*2,r=new Float32Array(t*8);let l=0;for(const i of a)r[l++]=i.x,r[l++]=i.y,r[l++]=i.z,r[l++]=i.r,r[l++]=i.g,r[l++]=i.b,r[l++]=i.blk,r[l++]=i.last;for(const i of a)o==="x-"||o==="x+"?r[l++]=-i.x:r[l++]=i.x,o==="y-"||o==="y+"?r[l++]=-i.y:r[l++]=i.y,r[l++]=i.z,r[l++]=i.r,r[l++]=i.g,r[l++]=i.b,r[l++]=i.blk,r[l++]=i.last;return r}function J(s,e,h,o){const{amount:a,chaos:t,speed:r}=L(h,I.find(i=>i.id==="warp").defaultParams),l=o*.001*r;for(let i=0;i<e;i++){const c=i*8,d=s[c],n=s[c+1],f=Math.abs(n);s[c]+=Math.sin(f*10*(1+t)+l)*a*Math.cos(l*t),s[c+1]+=Math.cos(Math.abs(d)*10*(1+t)+l)*a*Math.sin(l*t)}}function ee(s,e,h,o){const{amount:a,scale:t,speed:r}=L(h,I.find(i=>i.id==="distortion").defaultParams),l=o*.001*r;for(let i=0;i<e;i++){const c=i*8,d=Math.sin(s[c]*t+l)*Math.cos(s[c+1]*t-l),n=Math.cos(s[c]*t-l)*Math.sin(s[c+1]*t+l);s[c]+=d*a,s[c+1]+=n*a}}function te(s,e,h,o){const{speedX:a,speedY:t}=L(h,I.find(d=>d.id==="move").defaultParams),r=o*.001,l=r*a,i=r*t,c=4;for(let d=0;d<e;d++){const n=d*8;let f=s[n]+l,p=s[n+1]+i,b=(f+1)%c;b<0&&(b+=c),b>2&&(b=4-b),f=b-1;let m=(p+1)%c;m<0&&(m+=c),m>2&&(m=4-m),p=m-1,s[n]=f,s[n+1]=p}}function re(s,e,h,o,a,t){const{mode:r="frame",delayAmount:l,decay:i,delayDirection:c,useCustomOrder:d,customOrder:n}=L(h,I.find(p=>p.id==="delay").defaultParams);o.has(a)||o.set(a,[]);const f=o.get(a);if(f.unshift(new Float32Array(s)),r==="frame"){const b=l*10+1;f.length>b&&(f.length=b);const m=new Float32Array(s.length);for(let S=0;S<e;S++){let _=0;const F=S/e;c==="left_to_right"?_=Math.floor(F*9):c==="right_to_left"?_=Math.floor((1-F)*9):c==="center_to_out"?_=Math.floor(Math.abs(F-.5)*2*9):c==="out_to_center"&&(_=Math.floor((1-Math.abs(F-.5)*2)*9));const A=_*l,w=A<f.length?f[A]:null,x=Math.pow(i,_),y=S*8;w&&w.length===s.length?(m[y]=w[y],m[y+1]=w[y+1],m[y+2]=w[y+2],m[y+3]=w[y+3]*x,m[y+4]=w[y+4]*x,m[y+5]=w[y+5]*x,m[y+6]=w[y+6],m[y+7]=w[y+7]):(m.set(s.subarray(y,y+8),y),m[y+3]=0,m[y+4]=0,m[y+5]=0,m[y+6]=1)}return m}else{const{assignedDacs:p}=t||{};let b=new Map,m=0;if(d||h.delayMode==="channel")(n&&n.length>0?n.map(g=>g.originalIndex):p?p.map((g,R)=>R):[0]).forEach((g,R)=>{b.set(g,R),m=Math.max(m,R)});else{const g=(p||[]).length||1;for(let R=0;R<g;R++){let u=R;c==="right_to_left"?u=g-1-R:c==="center_to_out"?u=Math.floor(Math.abs(R-(g-1)/2)):c==="out_to_center"&&(u=Math.min(R,g-1-R)),b.set(R,u),m=Math.max(m,u)}}const _=m+1,F=l*_+1;f.length>F&&(f.length=F);const A=[];for(let P=0;P<_;P++){const g=P*l;A.push({points:g<f.length?f[g]:null,factor:Math.pow(i,P),index:P})}const w=A.reduce((P,g)=>P+(g.points?g.points.length/8:s.length/8),0),x=new Float32Array(w*8);let y=0;const C=new Array(A.length);for(let P=0;P<A.length;P++){const g=A[P],R=g.points,u=R?R.length/8:s.length/8;C[P]=y;for(let M=0;M<u;M++){const v=M*8,B=y+M*8;R?(x[B]=R[v],x[B+1]=R[v+1],x[B+2]=R[v+2],x[B+3]=R[v+3]*g.factor,x[B+4]=R[v+4]*g.factor,x[B+5]=R[v+5]*g.factor,x[B+6]=R[v+6],x[B+7]=R[v+7]):x[B+6]=1}y+=u*8}const E=new Map;return b.forEach((P,g)=>{P<A.length&&E.set(g,{start:C[P],length:A[P].points?A[P].points.length:s.length})}),x._channelDistributions=E,x}}function ae(s,e,h,o,a={}){const{mode:t="frame",steps:r,decay:l,speed:i,overlap:c,direction:d,useCustomOrder:n,customOrder:f,playStyle:p="loop"}=L(h,I.find(F=>F.id==="chase").defaultParams),{progress:b=0,clipDuration:m=1}=a,S=b*m,_=b!==void 0&&m>0?S:o*.001;if(t==="frame"){const F=r;let A=_*i;if(p==="bounce"){const x=F,y=A%(x*2);A=y>x?x*2-y:y}else p==="once"?A=Math.min(A,F):A=A%F;const w=new Float32Array(s.length);for(let x=0;x<e;x++){const y=x/e;let C=0;d==="left_to_right"?C=Math.floor(y*(F-1)):d==="right_to_left"?C=Math.floor((1-y)*(F-1)):d==="center_to_out"?C=Math.floor(Math.abs(y-.5)*2*(F-1)):d==="out_to_center"&&(C=Math.floor((1-Math.abs(y-.5)*2)*(F-1)));let E=Math.abs(A-C);E>F/2&&(E=F-E);let P=E<c?1-E/c:0;l>0&&(P=Math.pow(P,1-l));const g=x*8;w.set(s.subarray(g,g+8),g),w[g+3]*=P,w[g+4]*=P,w[g+5]*=P,P<.05&&(w[g+6]=1)}return w}else{const{assignedDacs:F}=a||{};let A=new Map,w=0;if(n)(f&&f.length>0?f.map(M=>M.originalIndex):F?F.map((M,v)=>v):[0]).forEach((M,v)=>{A.set(M,v),w++});else{w=(F?F.length:1)||1;for(let u=0;u<w;u++){let M=u;d==="right_to_left"?M=w-1-u:d==="center_to_out"?M=Math.floor(Math.abs(u-(w-1)/2)):d==="out_to_center"&&(M=Math.min(u,w-1-u)),A.set(u,M)}}const x=w;let y=_*i;if(p==="bounce"){const u=x,M=y%(u*2);y=M>u?u*2-M:M}else p==="once"?y=Math.min(y,x):y=y%x;const C=e*w,E=new Float32Array(C*8),P=new Map;let g=0;const R=Array.from(A.keys());R.length===0&&R.push(0);for(const u of R){const M=A.get(u)||0;let v=Math.abs(y-M);v>x/2&&(v=x-v);let B=v<c?1-v/c:0;l>0&&(B=Math.pow(B,1-l));const D=g;for(let O=0;O<e;O++){const T=O*8,k=g+O*8;E.set(s.subarray(T,T+8),k),E[k+3]*=B,E[k+4]*=B,E[k+5]*=B,B<.05&&(E[k+6]=1)}P.set(u,{start:D,length:e*8}),g+=e*8}return E._channelDistributions=P,E}}function oe(s,e){if(!e||!s||!s.points)return s;const{safetyZones:h,outputArea:o,transformationEnabled:a,transformationMode:t,flipX:r,flipY:l}=e;let i=s.points;const c=s.isTypedArray||i instanceof Float32Array,d=c?i.length/8:i.length;let n=c?new Float32Array(i):i.map(f=>({...f}));for(let f=0;f<d;f++){let p,b,m,S,_,F;if(c?(p=n[f*8],b=n[f*8+1],m=n[f*8+3],S=n[f*8+4],_=n[f*8+5],F=n[f*8+6]):(p=n[f].x,b=n[f].y,m=n[f].r,S=n[f].g,_=n[f].b,F=n[f].blanking?1:0),r&&(p=-p),l&&(b=-b),a&&o){let A=(p+1)/2,w=(1-b)/2;t==="crop"?(A<o.x||A>o.x+o.w||w<o.y||w>o.y+o.h)&&(m=0,S=0,_=0,F=1):t==="scale"&&(A=o.x+A*o.w,w=o.y+w*o.h,p=A*2-1,b=1-w*2)}if(h&&h.length>0){let A=(p+1)/2,w=(1-b)/2;for(const x of h)if(A>=x.x&&A<=x.x+x.w&&w>=x.y&&w<=x.y+x.h){m=0,S=0,_=0,F=1;break}}c?(n[f*8]=p,n[f*8+1]=b,n[f*8+3]=m,n[f*8+4]=S,n[f*8+5]=_,n[f*8+6]=F):(n[f].x=p,n[f].y=b,n[f].r=m,n[f].g=S,n[f].b=_,n[f].blanking=F>.5)}return{...s,points:n,isTypedArray:c}}class ne{constructor(e,h){if(this.canvas=e,this.type=h,this.gl=e.getContext("webgl")||e.getContext("experimental-webgl"),this.animationFrameId=null,this.frameIndexes=Array(10).fill(0),this.pointIndexes=Array(10).fill(0),this.showBeamEffect=!1,this.beamAlpha=.5,this.fadeAlpha=.13,this.beamRenderMode="both",this.positionBuffer=null,this.colorBuffer=null,this.alphaBuffer=null,this.lastPointDrawTime=0,!this.gl){console.error("WebGL not supported");return}this.setup()}setup(){const e=this.gl,h=`
      attribute vec2 aPosition;
      attribute vec3 aColor;
      attribute float aAlpha;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        gl_PointSize = 2.0;
        vColor = aColor;
        vAlpha = aAlpha;
      }
    `,o=`
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(vColor, vAlpha);
      }
    `,a=this.createShader(e.VERTEX_SHADER,h),t=this.createShader(e.FRAGMENT_SHADER,o),r=this.createProgram(a,t);this.program=r,this.positionAttributeLocation=e.getAttribLocation(r,"aPosition"),this.colorAttributeLocation=e.getAttribLocation(r,"aColor"),this.alphaAttributeLocation=e.getAttribLocation(r,"aAlpha"),this.quadPositionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer);const l=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(l),e.STATIC_DRAW),this.quadColorUniformLocation=e.getUniformLocation(r,"uColor"),this.quadAlphaUniformLocation=e.getUniformLocation(r,"uAlpha");const i=`
      attribute vec2 aPosition;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `,c=`
      precision mediump float;
      uniform vec4 uColor;
      void main() {
        gl_FragColor = uColor;
      }
    `,d=this.createShader(e.VERTEX_SHADER,i),n=this.createShader(e.FRAGMENT_SHADER,c);this.fadeProgram=this.createProgram(d,n),this.fadePositionAttributeLocation=e.getAttribLocation(this.fadeProgram,"aPosition"),this.fadeColorUniformLocation=e.getUniformLocation(this.fadeProgram,"uColor"),e.useProgram(r);const f=131072;this.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.bufferData(e.ARRAY_BUFFER,f*2*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.colorBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.colorBuffer),e.bufferData(e.ARRAY_BUFFER,f*3*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.alphaBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.alphaBuffer),e.bufferData(e.ARRAY_BUFFER,f*1*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.clearColor(0,0,0,1)}reset(){this.frameIndexes.fill(0),this.pointIndexes.fill(0),this.clearCanvas()}createShader(e,h){const o=this.gl,a=o.createShader(e);if(o.shaderSource(a,h),o.compileShader(a),o.getShaderParameter(a,o.COMPILE_STATUS))return a;console.error(o.getShaderInfoLog(a)),o.deleteShader(a)}createProgram(e,h){const o=this.gl,a=o.createProgram();if(o.attachShader(a,e),o.attachShader(a,h),o.linkProgram(a),o.getProgramParameter(a,o.LINK_STATUS))return a;console.error(o.getProgramInfoLog(a)),o.deleteProgram(a)}render(e){e.showBeamEffect!==void 0&&this.setBeamEffect(e.showBeamEffect),e.beamAlpha!==void 0&&this.setBeamAlpha(e.beamAlpha),e.fadeAlpha!==void 0&&this.setFadeAlpha(e.fadeAlpha),e.beamRenderMode!==void 0&&(this.beamRenderMode=e.beamRenderMode),this.type==="world"?this.renderWorld(e.worldData,e.previewScanRate,e.layerIntensities,e.masterIntensity,e.dacSettings,e.previewTime,e.fftLevels):this.renderSingle(e.ildaFrames,e.previewScanRate,e.intensity,e.effects,e.syncSettings,e.bpm,e.clipDuration,e.progress,e.previewTime,e.fftLevels,e.effectStates)}renderSingle(e,h,o,a,t={},r=120,l=1,i=null,c=null,d={low:0,mid:0,high:0},n=null){const f=this.gl;if(f.viewport(0,0,f.canvas.width,f.canvas.height),this.drawFadeQuad(),!e||e.length===0)return;const p=this.frameIndexes[0]%e.length,b=e[p],m=i!==null?i:p/e.length,S=c!==null?c:performance.now();this.draw(b,a,this.showBeamEffect,this.beamAlpha,h,this.beamRenderMode,o,0,m,S,t,r,l,d,n),this.frameIndexes[0]++,this.frameIndexes[0]>=e.length&&(this.frameIndexes[0]=0)}renderWorld(e,h,o,a,t,r=null,l={low:0,mid:0,high:0}){const i=this.gl;i.viewport(0,0,i.canvas.width,i.canvas.height),this.drawFadeQuad();const c=r!==null?r:performance.now();e.forEach(d=>{if(d&&d.frames&&d.frames.length>0){const n=d.frames[0];if(n){const f=d.layerIndex||0;if(d.syncSettings,d.bpm,f>=this.frameIndexes.length){const m=f+5;for(;this.frameIndexes.length<m;)this.frameIndexes.push(0),this.pointIndexes.push(0)}const b=(o[f]!==void 0?o[f]:1)*a;if(b>.001){const m=d.progress!==void 0?d.progress:this.frameIndexes[f]%d.frames.length/d.frames.length,{syncSettings:S={},bpm:_=120,clipDuration:F=1,effectStates:A=null}=d;let w=n;if(t){let x=n;if(t.dimmer!==void 0&&t.dimmer<1){const y=n.points,C=n.isTypedArray||y instanceof Float32Array,E=C?y.length/8:y.length,P=C?new Float32Array(y):y.map(g=>({...g}));for(let g=0;g<E;g++)C?(P[g*8+3]*=t.dimmer,P[g*8+4]*=t.dimmer,P[g*8+5]*=t.dimmer):(P[g].r*=t.dimmer,P[g].g*=t.dimmer,P[g].b*=t.dimmer);x={...n,points:P,isTypedArray:C}}w=oe(x,t)}this.draw(w,d.effects,this.showBeamEffect,this.beamAlpha,h,this.beamRenderMode,b,f,m,c,S,_,F,l,A)}}}}),e.forEach(d=>{if(d&&d.frames){const n=d.layerIndex||0;this.frameIndexes[n]++,this.frameIndexes[n]>=d.frames.length&&(this.frameIndexes[n]=0)}})}drawFadeQuad(){const e=this.gl;this.fadeProgram&&(e.useProgram(this.fadeProgram),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer),e.enableVertexAttribArray(this.fadePositionAttributeLocation),e.vertexAttribPointer(this.fadePositionAttributeLocation,2,e.FLOAT,!1,0,0),e.uniform4f(this.fadeColorUniformLocation,0,0,0,this.fadeAlpha),e.drawArrays(e.TRIANGLES,0,6))}setBeamEffect(e){this.showBeamEffect=e}setBeamAlpha(e){this.beamAlpha=e}setFadeAlpha(e){this.fadeAlpha=e}draw(e,h,o,a,t,r,l=1,i=0,c=0,d=performance.now(),n={},f=120,p=1,b={low:0,mid:0,high:0},m=null){if(this.gl,!e||!e.points)return;const S=q(e,h,{progress:c,time:d,syncSettings:n,bpm:f,clipDuration:p,fftLevels:b,effectStates:m}),_=S.points,F=S.isTypedArray,A=F?_.length/8:_.length;if(A===0)return;const w=Math.max(1,Math.floor(A/t));let x=this.pointIndexes[i]||0;x>=A&&(x=0);const y=g=>{const R=(x+g)%A;if(F){const u=R*8;return{x:_[u],y:_[u+1],r:_[u+3],g:_[u+4],b:_[u+5],blanking:_[u+6]===1}}else{const u=_[R];return{x:u.x,y:u.y,r:u.r,g:u.g,b:u.b,blanking:u.blanking}}},C=()=>{const g=r==="points"||r==="both",R=r==="lines"||r==="both";let u=[],M=[];for(let v=0;v<w;v++){const B=y(v);if(B.blanking){u.length>0&&(R&&this._drawSegment(new Float32Array(u),new Float32Array(M),1,u.length/2,!1),g&&this._drawSegment(new Float32Array(u),new Float32Array(M),1,u.length/2,!0),u=[],M=[]);continue}u.push(B.x,B.y),M.push(B.r/255*l,B.g/255*l,B.b/255*l)}u.length>0&&(R&&this._drawSegment(new Float32Array(u),new Float32Array(M),1,u.length/2,!1),g&&this._drawSegment(new Float32Array(u),new Float32Array(M),1,u.length/2,!0))},E=()=>{const g=[],R=[];for(let u=0;u<w;u++){const M=y(u);if(!M.blanking){g.push(0,0,M.x,M.y);const v=[M.r/255*l,M.g/255*l,M.b/255*l];R.push(...v,...v)}}g.length>0&&this._drawLines(new Float32Array(g),new Float32Array(R),a,g.length/2)},P=()=>{const g=[],R=[];let u=y(0);for(let M=1;M<w;M++){const v=y(M);if(!u.blanking&&!v.blanking){g.push(0,0,u.x,u.y,v.x,v.y);const B=[u.r/255*l,u.g/255*l,u.b/255*l],D=[v.r/255*l,v.g/255*l,v.b/255*l],O=[(B[0]+D[0])/2,(B[1]+D[1])/2,(B[2]+D[2])/2],T=.3,k=[B[0]*T,B[1]*T,B[2]*T],se=[D[0]*T,D[1]*T,D[2]*T];R.push(...O,...k,...se)}u=v}g.length>0&&this._drawTriangles(new Float32Array(g),new Float32Array(R),a,g.length/2)};C(),o&&(r==="points"?E():r==="lines"?P():r==="both"&&(P(),E())),this.pointIndexes[i]=(x+w)%A}_drawSegment(e,h,o,a,t=!1){const r=this.gl;r.useProgram(this.program),r.bindBuffer(r.ARRAY_BUFFER,this.positionBuffer),r.bufferSubData(r.ARRAY_BUFFER,0,e),r.enableVertexAttribArray(this.positionAttributeLocation),r.vertexAttribPointer(this.positionAttributeLocation,2,r.FLOAT,!1,0,0),r.bindBuffer(r.ARRAY_BUFFER,this.colorBuffer),r.bufferSubData(r.ARRAY_BUFFER,0,h),r.enableVertexAttribArray(this.colorAttributeLocation),r.vertexAttribPointer(this.colorAttributeLocation,3,r.FLOAT,!1,0,0);const l=new Float32Array(Array(a).fill(o));r.bindBuffer(r.ARRAY_BUFFER,this.alphaBuffer),r.bufferSubData(r.ARRAY_BUFFER,0,l),r.enableVertexAttribArray(this.alphaAttributeLocation),r.vertexAttribPointer(this.alphaAttributeLocation,1,r.FLOAT,!1,0,0),r.drawArrays(t?r.POINTS:r.LINE_STRIP,0,a)}_drawLines(e,h,o,a){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,h),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const r=new Float32Array(Array(a).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,r),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINES,0,a)}_drawTriangles(e,h,o,a){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,h),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const r=new Float32Array(Array(a).fill(o));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,r),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLES,0,a)}clearCanvas(){const e=this.gl;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT)}destroy(){if(cancelAnimationFrame(this.animationFrameId),this.gl){const e=this.gl.getExtension("WEBGL_losing_context");e&&e.loseContext()}}}const Y=new Map;function N(s,e=0){const h=Y.get(s);if(!h)return;const o=performance.now();h.renderer.render(h.data),e=o,h.animationFrameId=requestAnimationFrame(()=>N(s,e))}self.onmessage=s=>{const{action:e,payload:h}=s.data;if(e==="register"){const{id:o,canvas:a,type:t,data:r}=h,l=new ne(a,t),i=requestAnimationFrame(()=>N(o));Y.set(o,{renderer:l,type:t,data:r,animationFrameId:i})}else if(e==="deregister"){const{id:o}=h,a=Y.get(o);a&&(cancelAnimationFrame(a.animationFrameId),Y.delete(o))}else if(e==="update"){const{id:o,data:a}=h,t=Y.get(o);t&&(t.data=a)}else if(e==="clear"){const{id:o}=h,a=Y.get(o);a&&a.renderer.clearCanvas()}}})();
