(function(){"use strict";const k=[{r:255,g:0,b:0},{r:0,g:255,b:0},{r:0,g:0,b:255},{r:255,g:255,b:0},{r:0,g:255,b:255},{r:255,g:0,b:255},{r:255,g:128,b:0},{r:128,g:255,b:0},{r:0,g:255,b:128},{r:0,g:128,b:255},{r:128,g:0,b:255},{r:255,g:0,b:128},{r:255,g:255,b:255},{r:128,g:128,b:128},{r:255,g:128,b:128},{r:128,g:255,b:128},{r:128,g:128,b:255},{r:255,g:255,b:128},{r:128,g:255,b:255},{r:255,g:128,b:255}],M=new Map,D=n=>{if(!n||n.length===0)return{minX:0,maxX:0,minY:0,maxY:0};let e=n[0].x,l=n[0].x,f=n[0].y,a=n[0].y;for(let t=1;t<n.length;t++){const i=n[t];e=Math.min(e,i.x),l=Math.max(l,i.x),f=Math.min(f,i.y),a=Math.max(a,i.y)}return{minX:e,maxX:l,minY:f,maxY:a}};function F(n){const e=new DataView(n),l=[];let f=null,a=0;for(;a+32<=n.byteLength;){const t=a,i=String.fromCharCode(e.getUint8(t),e.getUint8(t+1),e.getUint8(t+2),e.getUint8(t+3));if(i!=="ILDA"){console.warn(`Parser: Invalid ILDA signature at offset ${t}, got: ${i}. Skipping 32 bytes.`),a+=32;continue}const r=e.getUint8(t+7);if(f===null&&(f=r),r>5){console.warn(`Parser: Unknown format code: ${r} at offset ${t}. Skipping 32 bytes.`),a+=32;continue}let s=e.getUint16(t+24,!1);const b=e.getUint16(t+26,!1),C=e.getUint16(t+28,!1),L=e.getUint8(t+30);let c;switch(r){case 0:c=8;break;case 1:c=6;break;case 2:c=8;break;case 4:c=10;break;case 5:c=8;break;default:console.warn(`Parser: Unsupported format ${r}, skipping 32 bytes.`),a+=32;continue}let w=s*c,m=32+w;const $=n.byteLength-a;if(m<$){const g=$-m;g>0&&g<=32&&(console.warn(`Parser: Malformed frame, ${g} leftover bytes. Adjusting size.`),m+=g,w+=g,s=Math.floor(w/c))}if(t+m>n.byteLength){console.warn(`Parser: Incomplete frame data for ${s} points at offset ${t}. Expected ${m} bytes, but only ${n.byteLength-t} bytes remaining. Breaking.`);break}if(s===0){console.log("Parser: Empty frame, skipping"),a+=m;continue}const d=[];let o=t+32;try{for(let g=0;g<s;g++){let I,U,P=0,u,p,h,y;r===0||r===4?(I=e.getInt16(o,!1)/32768,U=e.getInt16(o+2,!1)/32768,P=e.getInt16(o+4,!1)/32768,y=e.getUint8(o+6)):(I=e.getInt16(o,!1)/32768,U=e.getInt16(o+2,!1)/32768,y=e.getUint8(o+4));const v=(y&64)===64,S=(y&128)===128;if(r===0||r===1){const z=e.getUint8(o+(r===0?7:5)),x=k[z%k.length]||k[0];u=x.r,p=x.g,h=x.b}else if(r===4||r===5)u=e.getUint8(o+(r===4?7:5)),p=e.getUint8(o+(r===4?8:6)),h=e.getUint8(o+(r===4?9:7));else if(r===2){o+=c;continue}if(d.push({x:I,y:U,z:P,r:u===void 0?255:u,g:p===void 0?255:p,b:h===void 0?255:h,blanking:v,lastPoint:S}),o+=c,S)break}}catch(g){console.warn("Parser: Error reading points:",g);break}d.length>0&&l.push({frameNumber:b,totalFrames:C,projectorNumber:L,points:d,bounds:D(d)}),a+=m}return{frames:l,error:l.length===0?"No valid frames found":null,firstFormatCode:f}}self.onmessage=function(n){const{arrayBuffer:e,type:l,fileName:f,layerIndex:a,colIndex:t,workerId:i,frameIndex:r}=n.data;if(l==="parse-ilda")try{const s=F(e),b=`ilda-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;M.set(b,s.frames),self.postMessage({success:!0,workerId:b,totalFrames:s.frames.length,ildaFormat:s.firstFormatCode,fileName:f,layerIndex:a,colIndex:t,type:"parse-ilda"})}catch(s){console.error("[ilda-parser.worker] Error parsing file:",s),self.postMessage({success:!1,error:s.message})}else if(l==="get-frame"){const s=M.get(i);s&&s[r]?self.postMessage({success:!0,frame:s[r],workerId:i,frameIndex:r,type:"get-frame"}):self.postMessage({success:!1,error:"Frame not found",workerId:i,frameIndex:r})}}})();
