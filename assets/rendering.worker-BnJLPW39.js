(function(){"use strict";const C=[{id:"rotate",name:"Rotate",type:"transform",description:"Rotates the shape around its center.",defaultParams:{angle:0,speed:0,direction:"CW"},paramControls:[{id:"angle",label:"Angle",type:"range",min:0,max:360,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["CW","CCW"]}]},{id:"scale",name:"Scale",type:"transform",description:"Scales the shape.",defaultParams:{scaleX:1,scaleY:1},paramControls:[{id:"scaleX",label:"Scale X",type:"range",min:.01,max:5,step:.01},{id:"scaleY",label:"Scale Y",type:"range",min:.01,max:5,step:.01}]},{id:"translate",name:"Translate",type:"transform",description:"Moves the shape.",defaultParams:{translateX:0,translateY:0},paramControls:[{id:"translateX",label:"Translate X",type:"range",min:-1,max:1,step:.01},{id:"translateY",label:"Translate Y",type:"range",min:-1,max:1,step:.01}]},{id:"color",name:"Color",type:"color",description:"Changes the color of the shape with solid or rainbow modes.",defaultParams:{mode:"solid",r:255,g:255,b:255,cycleSpeed:0,rainbowSpread:1,rainbowOffset:0,rainbowPalette:"rainbow"},paramControls:[{id:"mode",label:"Mode",type:"select",options:["solid","rainbow"]},{id:"r",label:"Red",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"g",label:"Green",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"b",label:"Blue",type:"range",min:0,max:255,step:1,showIf:{mode:"solid"}},{id:"cycleSpeed",label:"Cycle Speed",type:"range",min:0,max:10,step:.1},{id:"rainbowSpread",label:"Rainbow Spread",type:"range",min:.1,max:10,step:.1,showIf:{mode:"rainbow"}},{id:"rainbowOffset",label:"Rainbow Offset",type:"range",min:0,max:360,step:1,showIf:{mode:"rainbow"}},{id:"rainbowPalette",label:"Palette",type:"select",options:["rainbow","fire","ice","cyber"],showIf:{mode:"rainbow"}}]},{id:"wave",name:"Wave",type:"animation",description:"Applies a wave distortion to the shape.",defaultParams:{amplitude:.1,frequency:10,speed:1,direction:"x"},paramControls:[{id:"amplitude",label:"Amplitude",type:"range",min:.01,max:1,step:.01},{id:"frequency",label:"Frequency",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1},{id:"direction",label:"Direction",type:"select",options:["x","y"]}]},{id:"warp",name:"Warp",type:"animation",description:"Symmetrical chaotic wave distortion.",defaultParams:{amount:.1,chaos:.5,speed:1},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"chaos",label:"Chaos",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:10,step:.1}]},{id:"distortion",name:"Distortion",type:"transform",description:"Distorts the point data.",defaultParams:{amount:.1,scale:10,speed:.5},paramControls:[{id:"amount",label:"Amount",type:"range",min:0,max:1,step:.01},{id:"scale",label:"Scale",type:"range",min:1,max:50,step:1},{id:"speed",label:"Speed",type:"range",min:0,max:5,step:.1}]},{id:"move",name:"Move (Bounce)",type:"transform",description:"Moves points and bounces them off the borders.",defaultParams:{speedX:.1,speedY:.1},paramControls:[{id:"speedX",label:"Speed X",type:"range",min:0,max:2,step:.01},{id:"speedY",label:"Speed Y",type:"range",min:0,max:2,step:.01}]},{id:"delay",name:"Delay",type:"effect",description:"Channel-based delay effect.",defaultParams:{useCustomOrder:!1,delayDirection:"left_to_right",delayAmount:5,decay:.8,customOrder:[]},paramControls:[{id:"useCustomOrder",label:"Custom Order",type:"checkbox"},{id:"delayDirection",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}},{id:"delayAmount",label:"Delay Time",type:"range",min:1,max:60,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01}]},{id:"chase",name:"Chase",type:"effect",description:"Step-based chase effect.",defaultParams:{steps:4,decay:.8,speed:1,overlap:1,direction:"left_to_right",useCustomOrder:!1,customOrder:[]},paramControls:[{id:"steps",label:"Steps",type:"range",min:2,max:16,step:1},{id:"decay",label:"Decay",type:"range",min:0,max:1,step:.01},{id:"speed",label:"Speed",type:"range",min:.1,max:5,step:.1},{id:"overlap",label:"Overlap",type:"range",min:1,max:4,step:1},{id:"useCustomOrder",label:"Custom Order",type:"checkbox"},{id:"direction",label:"Direction",type:"select",options:["center_to_out","out_to_center","left_to_right","right_to_left"],showIf:{useCustomOrder:!1}}]},{id:"blanking",name:"Blanking",type:"animation",description:"Controls the blanking of the laser output.",defaultParams:{blankingInterval:0},paramControls:[{id:"blankingInterval",label:"Blanking Interval",type:"range",min:0,max:10,step:1}]},{id:"strobe",name:"Strobe",type:"animation",description:"Applies a strobe effect to the laser output.",defaultParams:{strobeSpeed:100,strobeAmount:.5},paramControls:[{id:"strobeSpeed",label:"Strobe Speed (ms)",type:"range",min:10,max:1e3,step:10},{id:"strobeAmount",label:"Strobe Amount (0-1)",type:"range",min:0,max:1,step:.01}]},{id:"mirror",name:"Mirror",type:"transform",description:"Mirrors the shape from the center.",defaultParams:{mode:"none"},paramControls:[{id:"mode",label:"Mirror Mode",type:"select",options:["none","x+","x-","y+","y-"]}]}],M=(o,e)=>({...e,...o});function H(o,e,f={}){const{progress:n=0,time:i=performance.now(),effectStates:t,syncSettings:c={}}=f;if(!e||e.length===0)return o;let s;if(Array.isArray(o.points)){s=new Float32Array(o.points.length*8);for(let l=0;l<o.points.length;l++){const h=o.points[l],d=l*8;s[d]=h.x,s[d+1]=h.y,s[d+2]=h.z||0,s[d+3]=h.r,s[d+4]=h.g,s[d+5]=h.b,s[d+6]=h.blanking?1:0,s[d+7]=h.lastPoint?1:0}}else s=new Float32Array(o.points);let a=s;const r=()=>a.length/8;for(const l of e){if(!C.find(p=>p.id===l.id))continue;const d={...l.params};switch(l.id){case"rotate":Q(a,r(),d,n,i);break;case"scale":K(a,r(),d);break;case"translate":Z(a,r(),d);break;case"color":$(a,r(),d,i);break;case"wave":J(a,r(),d,i);break;case"blanking":ee(a,r(),d);break;case"strobe":te(a,r(),d,i);break;case"mirror":a=re(a,r(),d);break;case"warp":ae(a,r(),d,i);break;case"distortion":oe(a,r(),d,i);break;case"move":ne(a,r(),d,i);break;case"delay":t&&l.instanceId&&(a=se(a,r(),d,t,l.instanceId,f));break;case"chase":a=ie(a,r(),d,i,f);break}}return{...o,points:a,isTypedArray:!0}}function Q(o,e,f,n,i){const{angle:t,speed:c,direction:s}=M(f,C.find(p=>p.id==="rotate").defaultParams),a=s==="CCW"?-1:1,r=i*.001*c*a,l=t*Math.PI/180+r,h=Math.sin(l),d=Math.cos(l);for(let p=0;p<e;p++){const b=p*8,R=o[b],_=o[b+1];o[b]=R*d-_*h,o[b+1]=R*h+_*d}}function K(o,e,f){const{scaleX:n,scaleY:i}=M(f,C.find(t=>t.id==="scale").defaultParams);for(let t=0;t<e;t++){const c=t*8;o[c]*=n,o[c+1]*=i}}function Z(o,e,f){const{translateX:n,translateY:i}=M(f,C.find(t=>t.id==="translate").defaultParams);for(let t=0;t<e;t++){const c=t*8;o[c]+=n,o[c+1]+=i}}function $(o,e,f,n){const{mode:i,r:t,g:c,b:s,cycleSpeed:a,rainbowSpread:r,rainbowOffset:l,rainbowPalette:h}=M(f,C.find(p=>p.id==="color").defaultParams),d=n*.001*a;if(i==="rainbow"){const p=h||"rainbow";for(let b=0;b<e;b++){const R=b*8,_=(b/e*r+d*.5+l/360)%1;let w,x,B;p==="rainbow"?[w,x,B]=O(_,1,.5):[w,x,B]=j(p,_),o[R+3]=w,o[R+4]=x,o[R+5]=B}}else if(a>0){const p=d*50%360,[b,R,_]=O(p/360,1,.5);for(let w=0;w<e;w++){const x=w*8;o[x+3]=b,o[x+4]=R,o[x+5]=_}}else for(let p=0;p<e;p++){const b=p*8;o[b+3]=t,o[b+4]=c,o[b+5]=s}}function j(o,e){const f={fire:[{r:255,g:0,b:0},{r:255,g:128,b:0},{r:255,g:255,b:0},{r:255,g:0,b:0}],ice:[{r:0,g:0,b:255},{r:0,g:255,b:255},{r:255,g:255,b:255},{r:0,g:0,b:255}],cyber:[{r:255,g:0,b:255},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:255,g:0,b:255}]},n=f[o]||f.fire,i=e*(n.length-1),t=Math.floor(i),c=i-t,s=n[t],a=n[t+1]||n[t];return[Math.round(s.r+(a.r-s.r)*c),Math.round(s.g+(a.g-s.g)*c),Math.round(s.b+(a.b-s.b)*c)]}function O(o,e,f){let n,i,t;{const c=(r,l,h)=>(h<0&&(h+=1),h>1&&(h-=1),h<.16666666666666666?r+(l-r)*6*h:h<.5?l:h<.6666666666666666?r+(l-r)*(.6666666666666666-h)*6:r),s=f+e-f*e,a=2*f-s;n=c(a,s,o+1/3),i=c(a,s,o),t=c(a,s,o-1/3)}return[Math.round(n*255),Math.round(i*255),Math.round(t*255)]}function J(o,e,f,n){const{amplitude:i,frequency:t,speed:c,direction:s}=M(f,C.find(r=>r.id==="wave").defaultParams),a=n*.001*c;for(let r=0;r<e;r++){const l=r*8;s==="x"?o[l+1]+=i*Math.sin(o[l]*t+a):s==="y"&&(o[l]+=i*Math.sin(o[l+1]*t+a))}}function ee(o,e,f){const{blankingInterval:n}=M(f,C.find(i=>i.id==="blanking").defaultParams);if(!(n<=0))for(let i=0;i<e;i++)i%(n+1)===n&&(o[i*8+6]=1)}function te(o,e,f,n){const{strobeSpeed:i,strobeAmount:t}=M(f,C.find(s=>s.id==="strobe").defaultParams);if(n%i/i<t)for(let s=0;s<e;s++)o[s*8+6]=1}function re(o,e,f){const{mode:n}=M(f,C.find(a=>a.id==="mirror").defaultParams);if(n==="none")return o;let i=[];for(let a=0;a<e;a++){const r=a*8,l=o[r],h=o[r+1];let d=!1;n==="x-"?l<=0&&(d=!0):n==="x+"?l>=0&&(d=!0):n==="y-"?h<=0&&(d=!0):n==="y+"&&h>=0&&(d=!0),d&&i.push({x:o[r],y:o[r+1],z:o[r+2],r:o[r+3],g:o[r+4],b:o[r+5],blk:o[r+6],last:o[r+7]})}const t=i.length*2,c=new Float32Array(t*8);let s=0;for(const a of i)c[s++]=a.x,c[s++]=a.y,c[s++]=a.z,c[s++]=a.r,c[s++]=a.g,c[s++]=a.b,c[s++]=a.blk,c[s++]=a.last;for(const a of i)n==="x-"||n==="x+"?c[s++]=-a.x:c[s++]=a.x,n==="y-"||n==="y+"?c[s++]=-a.y:c[s++]=a.y,c[s++]=a.z,c[s++]=a.r,c[s++]=a.g,c[s++]=a.b,c[s++]=a.blk,c[s++]=a.last;return c}function ae(o,e,f,n){const{amount:i,chaos:t,speed:c}=M(f,C.find(a=>a.id==="warp").defaultParams),s=n*.001*c;for(let a=0;a<e;a++){const r=a*8,l=o[r],h=o[r+1],d=Math.abs(h);o[r]+=Math.sin(d*10*(1+t)+s)*i*Math.cos(s*t),o[r+1]+=Math.cos(Math.abs(l)*10*(1+t)+s)*i*Math.sin(s*t)}}function oe(o,e,f,n){const{amount:i,scale:t,speed:c}=M(f,C.find(a=>a.id==="distortion").defaultParams),s=n*.001*c;for(let a=0;a<e;a++){const r=a*8,l=Math.sin(o[r]*t+s)*Math.cos(o[r+1]*t-s),h=Math.cos(o[r]*t-s)*Math.sin(o[r+1]*t+s);o[r]+=l*i,o[r+1]+=h*i}}function ne(o,e,f,n){const{speedX:i,speedY:t}=M(f,C.find(l=>l.id==="move").defaultParams),c=n*.001,s=c*i,a=c*t,r=4;for(let l=0;l<e;l++){const h=l*8;let d=o[h]+s,p=o[h+1]+a,b=(d+1)%r;b<0&&(b+=r),b>2&&(b=4-b),d=b-1;let R=(p+1)%r;R<0&&(R+=r),R>2&&(R=4-R),p=R-1,o[h]=d,o[h+1]=p}}function se(o,e,f,n,i,t){const c=C.find(m=>m.id==="delay").defaultParams,{delayAmount:s,decay:a,useCustomOrder:r,delayDirection:l,customOrder:h}=M(f,c),d=r||f.delayMode==="channel"||f.delayMode===!0;n.has(i)||n.set(i,[]);const p=n.get(i),b=new Float32Array(o);p.unshift(b);const{assignedDacs:R}=t||{};let _=new Map,w=0;if(d){let m=[];h&&Array.isArray(h)&&h.length>0?m=h.map(y=>y.originalIndex!==void 0?y.originalIndex:0):R?m=R.map((y,u)=>u):m=[0],m.forEach((y,u)=>{_.set(y,u),w=Math.max(w,u)})}else{const y=(R||[]).length||1;for(let u=0;u<y;u++){let P=0;l==="right_to_left"?P=y-1-u:l==="center_to_out"?P=Math.floor(Math.abs(u-(y-1)/2)):l==="out_to_center"?P=Math.min(u,y-1-u):P=u,_.set(u,P),w=Math.max(w,P)}y===0&&_.set(0,0)}const x=w+1,B=s*x+1;p.length>B&&(p.length=B);const v=[];for(let m=0;m<x;m++){const y=m*s;let u=null;y===0?u=o:y<p.length&&(u=p[y]);const P=Math.pow(a,m);v.push({points:u,factor:P,index:m})}if(v.length===0)return o;const E=e+v.reduce((m,y)=>m+(y.points?y.points.length/8:o.length/8),0),S=new Float32Array(E*8);let g=0;const F=new Array(v.length);for(let m=0;m<v.length;m++){const y=v[m],u=y.points,P=u?u.length/8:o.length/8,D=y.factor;F[m]=g;for(let Y=0;Y<P;Y++){const I=Y*8,L=g+Y*8;let N=0,X=0,W=0,V=0,q=0,G=0,k=1,z=0;u?(N=u[I],X=u[I+1],W=u[I+2],V=u[I+3],q=u[I+4],G=u[I+5],k=u[I+6],z=u[I+7]):k=1,S[L]=N,S[L+1]=X,S[L+2]=W,S[L+3]=V*D,S[L+4]=q*D,S[L+5]=G*D,S[L+6]=k,S[L+7]=z}g+=P*8}const A=new Map;return _.forEach((m,y)=>{if(m<v.length){const u=F[m],P=v[m].points?v[m].points.length:o.length;A.set(y,{start:u,length:P})}}),S._channelDistributions=A,S}function ie(o,e,f,n,i={}){const{decay:t,speed:c,overlap:s,direction:a,useCustomOrder:r,customOrder:l}=M(f,C.find(S=>S.id==="chase").defaultParams),{assignedDacs:h}=i||{};let d=new Map,p=0;if(r){let S=[];l&&Array.isArray(l)&&l.length>0?S=l.map(g=>g.originalIndex!==void 0?g.originalIndex:0):h?S=h.map((g,F)=>F):S=[0],S.forEach((g,F)=>{d.set(g,F),p++})}else{p=(h||[]).length||1;for(let g=0;g<p;g++){let F=g;a==="right_to_left"?F=p-1-g:a==="center_to_out"?F=Math.floor(Math.abs(g-(p-1)/2)):a==="out_to_center"&&(F=Math.min(g,p-1-g)),d.set(g,F)}}p===0&&(p=1);const b=p,R=n*.001*c%b,w=e*p,x=new Float32Array(w*8),B=new Map;let v=0;const E=Array.from(d.keys());E.length===0&&E.push(0);for(const S of E){const g=d.get(S)||0;let F=Math.abs(R-g);F>b/2&&(F=b-F);let A=0;F<s&&(A=1-F/s,A=Math.max(0,A),t>0&&(A=Math.pow(A,1-t)));const m=v;for(let y=0;y<e;y++){const u=y*8,P=v+y*8;x[P]=o[u],x[P+1]=o[u+1],x[P+2]=o[u+2]||0,x[P+3]=o[u+3]*A,x[P+4]=o[u+4]*A,x[P+5]=o[u+5]*A,x[P+6]=A<.05?1:o[u+6],x[P+7]=o[u+7]}B.set(S,{start:m,length:e}),v+=e*8}return x._channelDistributions=B,x}function le(o,e){if(!e||!o||!o.points)return o;const{safetyZones:f,outputArea:n,transformationEnabled:i,transformationMode:t}=e;let c=o.points;const s=o.isTypedArray||c instanceof Float32Array,a=s?c.length/8:c.length;let r;s?r=new Float32Array(c):r=c.map(l=>({...l}));for(let l=0;l<a;l++){let h,d,p,b,R,_;if(s?(h=r[l*8],d=r[l*8+1],p=r[l*8+3],b=r[l*8+4],R=r[l*8+5],_=r[l*8+6]):(h=r[l].x,d=r[l].y,p=r[l].r,b=r[l].g,R=r[l].b,_=r[l].blanking?1:0),i&&n){let w=(h+1)/2,x=(1-d)/2;t==="crop"?(w<n.x||w>n.x+n.w||x<n.y||x>n.y+n.h)&&(p=0,b=0,R=0,_=1):t==="scale"&&(w=n.x+w*n.w,x=n.y+x*n.h,h=w*2-1,d=1-x*2)}if(f&&f.length>0){let w=(h+1)/2,x=(1-d)/2;for(const B of f)if(w>=B.x&&w<=B.x+B.w&&x>=B.y&&x<=B.y+B.h){p=0,b=0,R=0,_=1;break}}s?(r[l*8]=h,r[l*8+1]=d,r[l*8+3]=p,r[l*8+4]=b,r[l*8+5]=R,r[l*8+6]=_):(r[l].x=h,r[l].y=d,r[l].r=p,r[l].g=b,r[l].b=R,r[l].blanking=_>.5)}return{...o,points:r,isTypedArray:s}}class ce{constructor(e,f){if(this.canvas=e,this.type=f,this.gl=e.getContext("webgl")||e.getContext("experimental-webgl"),this.animationFrameId=null,this.frameIndexes=Array(10).fill(0),this.pointIndexes=Array(10).fill(0),this.showBeamEffect=!1,this.beamAlpha=.5,this.fadeAlpha=.13,this.beamRenderMode="lines",this.positionBuffer=null,this.colorBuffer=null,this.alphaBuffer=null,this.lastPointDrawTime=0,!this.gl){console.error("WebGL not supported");return}this.setup()}setup(){const e=this.gl,f=`
      attribute vec2 aPosition;
      attribute vec3 aColor;
      attribute float aAlpha;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
        gl_PointSize = 2.0;
        vColor = aColor;
        vAlpha = aAlpha;
      }
    `,n=`
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        gl_FragColor = vec4(vColor, vAlpha);
      }
    `,i=this.createShader(e.VERTEX_SHADER,f),t=this.createShader(e.FRAGMENT_SHADER,n),c=this.createProgram(i,t);this.program=c,this.positionAttributeLocation=e.getAttribLocation(c,"aPosition"),this.colorAttributeLocation=e.getAttribLocation(c,"aColor"),this.alphaAttributeLocation=e.getAttribLocation(c,"aAlpha"),this.quadPositionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer);const s=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(s),e.STATIC_DRAW),this.quadColorUniformLocation=e.getUniformLocation(c,"uColor"),this.quadAlphaUniformLocation=e.getUniformLocation(c,"uAlpha");const a=`
      attribute vec2 aPosition;
      void main() {
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `,r=`
      precision mediump float;
      uniform vec4 uColor;
      void main() {
        gl_FragColor = uColor;
      }
    `,l=this.createShader(e.VERTEX_SHADER,a),h=this.createShader(e.FRAGMENT_SHADER,r);this.fadeProgram=this.createProgram(l,h),this.fadePositionAttributeLocation=e.getAttribLocation(this.fadeProgram,"aPosition"),this.fadeColorUniformLocation=e.getUniformLocation(this.fadeProgram,"uColor"),e.useProgram(c);const d=131072;this.positionBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.bufferData(e.ARRAY_BUFFER,d*2*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.colorBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.colorBuffer),e.bufferData(e.ARRAY_BUFFER,d*3*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),this.alphaBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.alphaBuffer),e.bufferData(e.ARRAY_BUFFER,d*1*Float32Array.BYTES_PER_ELEMENT,e.DYNAMIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.clearColor(0,0,0,1)}reset(){this.frameIndexes.fill(0),this.pointIndexes.fill(0),this.clearCanvas()}createShader(e,f){const n=this.gl,i=n.createShader(e);if(n.shaderSource(i,f),n.compileShader(i),n.getShaderParameter(i,n.COMPILE_STATUS))return i;console.error(n.getShaderInfoLog(i)),n.deleteShader(i)}createProgram(e,f){const n=this.gl,i=n.createProgram();if(n.attachShader(i,e),n.attachShader(i,f),n.linkProgram(i),n.getProgramParameter(i,n.LINK_STATUS))return i;console.error(n.getProgramInfoLog(i)),n.deleteProgram(i)}render(e){e.showBeamEffect!==void 0&&this.setBeamEffect(e.showBeamEffect),e.beamAlpha!==void 0&&this.setBeamAlpha(e.beamAlpha),e.fadeAlpha!==void 0&&this.setFadeAlpha(e.fadeAlpha),e.beamRenderMode!==void 0&&(this.beamRenderMode=e.beamRenderMode),this.type==="world"?this.renderWorld(e.worldData,e.previewScanRate,e.layerIntensities,e.masterIntensity,e.dacSettings):this.renderSingle(e.ildaFrames,e.previewScanRate,e.intensity,e.effects,e.syncSettings)}renderSingle(e,f,n,i,t={}){const c=this.gl;if(c.viewport(0,0,c.canvas.width,c.canvas.height),this.drawFadeQuad(),!e||e.length===0)return;const s=this.frameIndexes[0]%e.length,a=e[s],r=s/e.length,l=performance.now();this.draw(a,i,this.showBeamEffect,this.beamAlpha,f,this.beamRenderMode,n,0,r,l,t),this.frameIndexes[0]++,this.frameIndexes[0]>=e.length&&(this.frameIndexes[0]=0)}renderWorld(e,f,n,i,t){const c=this.gl;c.viewport(0,0,c.canvas.width,c.canvas.height),this.drawFadeQuad();const s=performance.now();e.forEach(a=>{if(a&&a.frames&&a.frames.length>0){const r=a.frames[0];if(r){const l=a.layerIndex||0,h=a.syncSettings||{};if(l>=this.frameIndexes.length){const b=l+5;for(;this.frameIndexes.length<b;)this.frameIndexes.push(0),this.pointIndexes.push(0)}const p=(n[l]!==void 0?n[l]:1)*i;if(p>.001){const b=this.frameIndexes[l]%a.frames.length/a.frames.length;let R=r;if(t){let _=r;if(t.dimmer!==void 0&&t.dimmer<1){const w=r.points,x=r.isTypedArray||w instanceof Float32Array,B=x?w.length/8:w.length,v=x?new Float32Array(w):w.map(E=>({...E}));for(let E=0;E<B;E++)x?(v[E*8+3]*=t.dimmer,v[E*8+4]*=t.dimmer,v[E*8+5]*=t.dimmer):(v[E].r*=t.dimmer,v[E].g*=t.dimmer,v[E].b*=t.dimmer);_={...r,points:v,isTypedArray:x}}R=le(_,t)}this.draw(R,a.effects,this.showBeamEffect,this.beamAlpha,f,this.beamRenderMode,p,l,b,s,h)}}}}),e.forEach(a=>{if(a&&a.frames){const r=a.layerIndex||0;this.frameIndexes[r]++,this.frameIndexes[r]>=a.frames.length&&(this.frameIndexes[r]=0)}})}drawFadeQuad(){const e=this.gl;this.fadeProgram&&(e.useProgram(this.fadeProgram),e.bindBuffer(e.ARRAY_BUFFER,this.quadPositionBuffer),e.enableVertexAttribArray(this.fadePositionAttributeLocation),e.vertexAttribPointer(this.fadePositionAttributeLocation,2,e.FLOAT,!1,0,0),e.uniform4f(this.fadeColorUniformLocation,0,0,0,this.fadeAlpha),e.drawArrays(e.TRIANGLES,0,6))}setBeamEffect(e){this.showBeamEffect=e}setBeamAlpha(e){this.beamAlpha=e}setFadeAlpha(e){this.fadeAlpha=e}draw(e,f,n,i,t,c,s=1,a=0,r=0,l=performance.now(),h={}){if(this.gl,!e||!e.points)return;const d=(f||[]).map(g=>{const F={...g.params},A=C.find(m=>m.id===g.id);return A&&A.paramControls.forEach(m=>{const y=`${g.id}.${m.id}`,u=h[y];if(u&&(m.type==="range"||m.type==="number")){let P=0;u==="fps"?P=l*.001%1:(u==="timeline"||u==="bpm")&&(P=r),F[m.id]=m.min+(m.max-m.min)*P}}),{...g,params:F}}),p=H(e,d,{progress:r,time:l}),b=p.points,R=p.isTypedArray,_=R?b.length/8:b.length;if(_===0)return;const w=Math.max(1,Math.floor(_/t));let x=this.pointIndexes[a]||0;x>=_&&(x=0);const B=g=>{const F=(x+g)%_;if(R){const A=F*8;return{x:b[A],y:b[A+1],r:b[A+3],g:b[A+4],b:b[A+5],blanking:b[A+6]===1}}else{const A=b[F];return{x:A.x,y:A.y,r:A.r,g:A.g,b:A.b,blanking:A.blanking}}},v=()=>{let g=[],F=[];for(let A=0;A<w;A++){const m=B(A);if(m.blanking){g.length>0&&(this._drawSegment(new Float32Array(g),new Float32Array(F),1,g.length/2),g=[],F=[]);continue}g.push(m.x,m.y),F.push(m.r/255*s,m.g/255*s,m.b/255*s)}g.length>0&&this._drawSegment(new Float32Array(g),new Float32Array(F),1,g.length/2)},E=()=>{const g=[],F=[];for(let A=0;A<w;A++){const m=B(A);if(!m.blanking){g.push(0,0,m.x,m.y);const y=[m.r/255*s,m.g/255*s,m.b/255*s];F.push(...y,...y)}}g.length>0&&this._drawLines(new Float32Array(g),new Float32Array(F),i,g.length/2)},S=()=>{const g=[],F=[];let A=B(0);for(let m=1;m<w;m++){const y=B(m);if(!A.blanking&&!y.blanking){g.push(0,0,A.x,A.y,y.x,y.y);const u=[A.r/255*s,A.g/255*s,A.b/255*s],P=[y.r/255*s,y.g/255*s,y.b/255*s],D=[(u[0]+P[0])/2,(u[1]+P[1])/2,(u[2]+P[2])/2];F.push(...D,...u,...P)}A=y}g.length>0&&this._drawTriangles(new Float32Array(g),new Float32Array(F),i,g.length/2)};v(),n&&(c==="points"?E():c==="lines"?S():c==="both"&&(S(),E())),this.pointIndexes[a]=(x+w)%_}_drawSegment(e,f,n,i){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,f),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(i).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINE_STRIP,0,i)}_drawLines(e,f,n,i){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,f),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(i).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.LINES,0,i)}_drawTriangles(e,f,n,i){const t=this.gl;t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e),t.enableVertexAttribArray(this.positionAttributeLocation),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.colorBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,f),t.enableVertexAttribArray(this.colorAttributeLocation),t.vertexAttribPointer(this.colorAttributeLocation,3,t.FLOAT,!1,0,0);const c=new Float32Array(Array(i).fill(n));t.bindBuffer(t.ARRAY_BUFFER,this.alphaBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,c),t.enableVertexAttribArray(this.alphaAttributeLocation),t.vertexAttribPointer(this.alphaAttributeLocation,1,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLES,0,i)}clearCanvas(){const e=this.gl;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT)}destroy(){cancelAnimationFrame(this.animationFrameId)}}const T=new Map;function U(o,e=0){const f=T.get(o);if(!f)return;const n=performance.now();f.renderer.render(f.data),e=n,f.animationFrameId=requestAnimationFrame(()=>U(o,e))}self.onmessage=o=>{const{action:e,payload:f}=o.data;if(e==="register"){const{id:n,canvas:i,type:t,data:c}=f,s=new ce(i,t),a=requestAnimationFrame(()=>U(n));T.set(n,{renderer:s,type:t,data:c,animationFrameId:a})}else if(e==="deregister"){const{id:n}=f,i=T.get(n);i&&(cancelAnimationFrame(i.animationFrameId),T.delete(n))}else if(e==="update"){const{id:n,data:i}=f,t=T.get(n);t&&(t.data=i)}else if(e==="clear"){const{id:n}=f,i=T.get(n);i&&i.renderer.clearCanvas()}}})();
